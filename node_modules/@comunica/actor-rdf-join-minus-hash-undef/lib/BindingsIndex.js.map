{"version":3,"file":"BindingsIndex.js","sourceRoot":"","sources":["BindingsIndex.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Bindings } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { termToString } from 'rdf-string';\n\n/**\n * A simple efficient tree-based index for maintaining bindings,\n * and checking whether or not a bindings is contained in this index.\n *\n * This will consider bindings with a variable term or a missing term\n * as a 'match-all' with other terms.\n */\nexport class BindingsIndex {\n  private readonly keys: RDF.Variable[];\n  private readonly data: IDataIndex = {};\n\n  public constructor(keys: RDF.Variable[]) {\n    this.keys = keys;\n  }\n\n  protected static hashTerm(term: RDF.Term | undefined): string {\n    return term && term.termType !== 'Variable' ? termToString(term) : '';\n  }\n\n  /**\n   * Add the given bindings to the index.\n   * @param {Bindings} bindings A bindings.\n   */\n  public add(bindings: Bindings): void {\n    if (this.isBindingsValid(bindings)) {\n      let dataIt = this.data;\n      for (const key of this.keys) {\n        const dataKey = BindingsIndex.hashTerm(bindings.get(key));\n        let subDataIt = dataIt[dataKey];\n        if (!subDataIt) {\n          subDataIt = dataIt[dataKey] = {};\n        }\n        dataIt = subDataIt;\n      }\n    }\n  }\n\n  /**\n   * Check if the given bindings is contained in this index.\n   * @param {Bindings} bindings A bindings.\n   * @return {boolean} If it exists in the index.\n   */\n  public contains(bindings: Bindings): boolean {\n    // Always return false if the bindings contain none of the expected keys\n    if (!this.isBindingsValid(bindings)) {\n      return false;\n    }\n\n    return this.containsRecursive(bindings, this.keys, [ this.data ]);\n  }\n\n  protected isBindingsValid(bindings: Bindings): boolean {\n    let validKeys = false;\n    for (const key of this.keys) {\n      if (bindings.get(key)) {\n        validKeys = true;\n        break;\n      }\n    }\n    return validKeys;\n  }\n\n  protected containsRecursive(bindings: Bindings, keys: RDF.Variable[], dataIndexes: IDataIndex[]): boolean {\n    if (keys.length === 0) {\n      return true;\n    }\n\n    let key: RDF.Variable;\n    // eslint-disable-next-line prefer-const\n    [ key, ...keys ] = keys;\n    for (const data of dataIndexes) {\n      // If the index contained a variable, all terms will match.\n      const dataKey = BindingsIndex.hashTerm(bindings.get(key));\n      if (!dataKey) {\n        // Iterate over all entries\n        let subDatas = Object.keys(data).map(subKey => data[subKey]);\n        if (subDatas.length === 0) {\n          subDatas = [{}];\n        }\n        if (this.containsRecursive(bindings, keys, subDatas)) {\n          return true;\n        }\n      } else {\n        // Check the entry for the term, and the variable term.\n        const subDatas = [ data[dataKey], data[''] ].filter(Boolean);\n        if (subDatas.length === 0) {\n          continue;\n        }\n        if (this.containsRecursive(bindings, keys, subDatas)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n\nexport interface IDataIndex {\n  [key: string]: IDataIndex;\n}\n"]}