{"version":3,"file":"BindingsToQuadsIterator.js","sourceRoot":"","sources":["BindingsToQuadsIterator.ts"],"names":[],"mappings":";;;AAGA,iDAAsE;AACtE,uDAA+C;AAC/C,yCAAqC;AAErC,MAAM,EAAE,GAAG,IAAI,8BAAW,EAAE,CAAC;AAE7B;;;;;GAKG;AACH,MAAa,uBAAwB,SAAQ,sCAA0C;IAKrF,YAAmB,QAAwB,EAAE,cAA8B,EAAE,kBAAkB,GAAG,IAAI;QACpG,KAAK,CAAC,cAAc,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC;QAC5C,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;QAC7C,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;IAC5B,CAAC;IAED;;;;;;;;;;;;OAYG;IACI,MAAM,CAAC,QAAQ,CAAC,QAAkB,EAAE,IAAc;QACvD,IAAI,IAAI,CAAC,QAAQ,KAAK,UAAU,EAAE;YAChC,OAAO,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;SAC3B;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;;;OAOG;IACI,MAAM,CAAC,QAAQ,CAAC,QAAkB,EAAE,OAAqB;QAC9D,IAAI;YACF,OAAO,IAAA,oBAAQ,EAAY,OAAO,EAAE,IAAI,CAAC,EAAE;gBACzC,MAAM,SAAS,GAAG,uBAAuB,CAAC,QAAQ,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;gBACnE,IAAI,CAAC,SAAS,EAAE;oBACd,MAAM,IAAI,KAAK,CAAC,cAAc,CAAC,CAAC;iBACjC;gBACD,OAAO,SAAS,CAAC;YACnB,CAAC,CAAC,CAAC;SACJ;QAAC,MAAM;YACN,aAAa;SACd;IACH,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,iBAAiB,CAAC,gBAAwB,EACtD,IAAc;QACd,IAAI,IAAI,CAAC,QAAQ,KAAK,WAAW,EAAE;YACjC,OAAO,EAAE,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,gBAAgB,EAAE,CAAC,CAAC;SACzD;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,YAAY,CAAC,gBAAwB,EACjD,OAAqB;QACrB,OAAO,IAAA,oBAAQ,EAAC,OAAO,EAAE,IAAI,CAAC,EAAE,CAAC,uBAAuB,CAAC,iBAAiB,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAC,CAAC;IACtG,CAAC;IAED;;;;;;OAMG;IACI,YAAY,CAAC,QAAkB,EAAE,QAAwB,EAAE,gBAAwB;QACxF,IAAI,KAAK,GAAoC,QAAQ;YACnD,gCAAgC;aAC/B,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,uBAAuB,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;YACnE,8DAA8D;aAC7D,MAAM,CAAC,OAAO,CAAC,CAAC;QACnB,IAAI,IAAI,CAAC,kBAAkB,EAAE;YAC3B,kHAAkH;YAClH,KAAK,GAAG,KAAK,CAAC,GAAG,CAAC,uBAAuB,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;SACtF;QACD,OAAoB,KAAK,CAAC;IAC5B,CAAC;IAEM,kBAAkB,CAAC,QAAkB;QAC1C,OAAO,IAAI,6BAAa,CAAC,IAAI,CAAC,YAAY,CACxC,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,gBAAgB,EAAE,CACjD,CAAC,CAAC;IACL,CAAC;CACF;AAzGD,0DAyGC","sourcesContent":["import type { Bindings, BindingsStream } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { ArrayIterator, MultiTransformIterator } from 'asynciterator';\nimport { DataFactory } from 'rdf-data-factory';\nimport { mapTerms } from 'rdf-terms';\n\nconst DF = new DataFactory();\n\n/**\n * Transforms a bindings stream into a quad stream given a quad template.\n *\n * This conforms to the SPARQL 1.1 spec on constructing triples:\n * https://www.w3.org/TR/sparql11-query/#rConstructTriples\n */\nexport class BindingsToQuadsIterator extends MultiTransformIterator<Bindings, RDF.Quad> {\n  protected readonly template: RDF.BaseQuad[];\n  protected readonly localizeBlankNodes: boolean;\n  protected blankNodeCounter: number;\n\n  public constructor(template: RDF.BaseQuad[], bindingsStream: BindingsStream, localizeBlankNodes = true) {\n    super(bindingsStream, { autoStart: false });\n    this.template = template;\n    this.localizeBlankNodes = localizeBlankNodes;\n    this.blankNodeCounter = 0;\n  }\n\n  /**\n   * Bind the given term.\n   * If the term is a variable and the variable is bound in the bindings object,\n   * return the bindings value.\n   * If the term is a variable and the variable is not bound in the bindings object,\n   * a falsy value is returned..\n   * Otherwise, the term itself is returned.\n   * @param {Bindings}  bindings A bindings object.\n   * @param {RDF.Term}  term     An RDF term.\n   * @return {RDF.Term}          If the given term is not a variable, the term itself is returned.\n   *                             If the given term is a variable, then the bound term is returned,\n   *                             or a falsy value if it did not exist in the bindings.\n   */\n  public static bindTerm(bindings: Bindings, term: RDF.Term): RDF.Term | undefined {\n    if (term.termType === 'Variable') {\n      return bindings.get(term);\n    }\n    return term;\n  }\n\n  /**\n   * Bind the given quad pattern.\n   * If one of the terms was a variable AND is not bound in the bindings,\n   * a falsy value will be returned.\n   * @param {Bindings} bindings A bindings object.\n   * @param {RDF.Quad} pattern  An RDF quad.\n   * @return {RDF.Quad}         A bound RDF quad or undefined.\n   */\n  public static bindQuad(bindings: Bindings, pattern: RDF.BaseQuad): RDF.Quad | undefined {\n    try {\n      return mapTerms(<RDF.Quad> pattern, term => {\n        const boundTerm = BindingsToQuadsIterator.bindTerm(bindings, term);\n        if (!boundTerm) {\n          throw new Error('Unbound term');\n        }\n        return boundTerm;\n      });\n    } catch {\n      // Do nothing\n    }\n  }\n\n  /**\n   * Convert a blank node to a unique blank node in the given context.\n   * If the given term is not a blank node, the term itself will be returned.\n   * @param             blankNodeCounter A counter value for the blank node.\n   * @param {RDF.Term}  term             The term that should be localized.\n   * @return {RDF.Term}                  A term.\n   */\n  public static localizeBlankNode(blankNodeCounter: number,\n    term: RDF.Term): RDF.Term {\n    if (term.termType === 'BlankNode') {\n      return DF.blankNode(`${term.value}${blankNodeCounter}`);\n    }\n    return term;\n  }\n\n  /**\n   * Convert the given quad to a quad that only contains unique blank nodes.\n   * @param            blankNodeCounter A counter value for the blank node.\n   * @param {RDF.BaseQuad} pattern          The pattern that should be localized.\n   * @return {RDF.BaseQuad}                 A quad.\n   */\n  public static localizeQuad(blankNodeCounter: number,\n    pattern: RDF.BaseQuad): RDF.BaseQuad {\n    return mapTerms(pattern, term => BindingsToQuadsIterator.localizeBlankNode(blankNodeCounter, term));\n  }\n\n  /**\n   * Convert the given template to a list of quads based on the given bindings.\n   * @param {Bindings}    bindings           A bindings object.\n   * @param {RDF.Quad[]}  template           A list of quad patterns.\n   * @param               blankNodeCounter   A counter value for the blank node.\n   * @return {RDF.Quad[]}                    A list of quads.\n   */\n  public bindTemplate(bindings: Bindings, template: RDF.BaseQuad[], blankNodeCounter: number): RDF.Quad[] {\n    let quads: RDF.BaseQuad[] = <RDF.BaseQuad[]> template\n      // Bind variables to bound terms\n      .map(x => BindingsToQuadsIterator.bindQuad.bind(null, bindings)(x))\n      // Remove quads that contained unbound terms, i.e., variables.\n      .filter(Boolean);\n    if (this.localizeBlankNodes) {\n      // Make sure the multiple instantiations of the template contain different blank nodes, as required by SPARQL 1.1.\n      quads = quads.map(BindingsToQuadsIterator.localizeQuad.bind(null, blankNodeCounter));\n    }\n    return <RDF.Quad[]> quads;\n  }\n\n  public _createTransformer(bindings: Bindings): AsyncIterator<RDF.Quad> {\n    return new ArrayIterator(this.bindTemplate(\n      bindings, this.template, this.blankNodeCounter++,\n    ));\n  }\n}\n"]}