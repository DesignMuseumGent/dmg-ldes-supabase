{"version":3,"file":"ActorRdfResolveHypermedia.js","sourceRoot":"","sources":["ActorRdfResolveHypermedia.ts"],"names":[],"mappings":";;;AAEA,yCAAuC;AAGvC;;;;;;;;;;GAUG;AACH,MAAsB,yBAA0B,SAAQ,YACS;IAG/D;;;OAGG;IACH,YAAmB,IAAoC,EAAE,UAAkB;QACzE,KAAK,CAAC,IAAI,CAAC,CAAC;QACZ,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;IAC/B,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,MAAmC;QACnD,IAAI,MAAM,CAAC,eAAe,IAAI,IAAI,CAAC,UAAU,KAAK,MAAM,CAAC,eAAe,EAAE;YACxE,MAAM,IAAI,KAAK,CAAC,SAAS,IAAI,CAAC,IAAI,sCAAsC,MAAM,CAAC,eAAe,GAAG,CAAC,CAAC;SACpG;QACD,OAAO,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;IACnC,CAAC;CAGF;AArBD,8DAqBC","sourcesContent":["import type { IQuadSource } from '@comunica/bus-rdf-resolve-quad-pattern';\nimport type { IAction, IActorArgs, IActorOutput, IActorTest, Mediate } from '@comunica/core';\nimport { Actor } from '@comunica/core';\nimport type * as RDF from '@rdfjs/types';\n\n/**\n * A comunica actor for rdf-resolve-hypermedia bus.\n *\n * Actor types:\n * * Input:  IActionRdfResolveHypermedia:      The metadata in the document and a query operation.\n * * Test:   <none>\n * * Output: IActorRdfResolveHypermediaOutput: An RDF source.\n *\n * @see IActionRdfResolveQuadPattern\n * @see IActorRdfResolveQuadPatternOutput\n */\nexport abstract class ActorRdfResolveHypermedia extends Actor<IActionRdfResolveHypermedia,\nIActorRdfResolveHypermediaTest, IActorRdfResolveHypermediaOutput> {\n  protected readonly sourceType: string;\n\n  /**\n   * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus\n   * @param sourceType The source type.\n   */\n  public constructor(args: IActorRdfResolveHypermediaArgs, sourceType: string) {\n    super(args);\n    this.sourceType = sourceType;\n  }\n\n  public async test(action: IActionRdfResolveHypermedia): Promise<IActorRdfResolveHypermediaTest> {\n    if (action.forceSourceType && this.sourceType !== action.forceSourceType) {\n      throw new Error(`Actor ${this.name} is not able to handle source type ${action.forceSourceType}.`);\n    }\n    return this.testMetadata(action);\n  }\n\n  public abstract testMetadata(action: IActionRdfResolveHypermedia): Promise<IActorRdfResolveHypermediaTest>;\n}\n\nexport interface IActionRdfResolveHypermedia extends IAction {\n  /**\n   * The URL of the source that was fetched.\n   */\n  url: string;\n  /**\n   * A metadata key-value mapping.\n   */\n  metadata: Record<string, any>;\n  /**\n   * A stream of data quads.\n   */\n  quads: RDF.Stream;\n  /**\n   * A hash of all datasets that have been handled.\n   */\n  handledDatasets?: Record<string, boolean>;\n  /**\n   * The explicitly requested source type.\n   * If set, the source type of the actor MUST explicitly match the given forced type.\n   */\n  forceSourceType?: string;\n}\n\nexport interface IActorRdfResolveHypermediaTest extends IActorTest {\n  /**\n   * A value from 0 to 1 indicating to what respect a source type is\n   * able to pre-filter the source based on the pattern.\n   * 1 indicates that the source can apply the whole pattern,\n   * and 0 indicates that the source can not apply the pattern at all (and local filtering must happen).\n   */\n  filterFactor: number;\n}\n\nexport interface IActorRdfResolveHypermediaOutput extends IActorOutput {\n  /**\n   * The new source of quads contained in the document.\n   */\n  source: IQuadSource;\n  /**\n   * The dataset that was handled.\n   */\n  dataset?: string;\n}\n\nexport type IActorRdfResolveHypermediaArgs = IActorArgs<\nIActionRdfResolveHypermedia, IActorRdfResolveHypermediaTest, IActorRdfResolveHypermediaOutput>;\n\nexport type MediatorRdfResolveHypermedia = Mediate<\nIActionRdfResolveHypermedia, IActorRdfResolveHypermediaOutput, IActorRdfResolveHypermediaTest>;\n"]}