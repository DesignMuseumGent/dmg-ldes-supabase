{"version":3,"file":"ActorAbstractPath.js","sourceRoot":"","sources":["ActorAbstractPath.ts"],"names":[],"mappings":"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","sourcesContent":["import { BindingsFactory } from '@comunica/bindings-factory';\nimport type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperation,\n  ActorQueryOperationTypedMediated,\n} from '@comunica/bus-query-operation';\nimport { KeysQueryOperation } from '@comunica/context-entries';\nimport type { IActorTest } from '@comunica/core';\nimport type { IQueryOperationResultBindings, Bindings, IActionContext, MetadataBindings } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport {\n  BufferedIterator, MultiTransformIterator,\n  TransformIterator, EmptyIterator,\n} from 'asynciterator';\nimport { DataFactory } from 'rdf-data-factory';\nimport { termToString } from 'rdf-string';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { Factory } from 'sparqlalgebrajs';\nimport { PathVariableObjectIterator } from './PathVariableObjectIterator';\n\nconst DF = new DataFactory();\nconst BF = new BindingsFactory();\n\n/**\n * An abstract actor that handles Path operations.\n *\n * Provides multiple helper functions used by the Path operation actors.\n */\nexport abstract class ActorAbstractPath extends ActorQueryOperationTypedMediated<Algebra.Path> {\n  protected static readonly FACTORY: Factory = new Factory();\n\n  protected readonly predicateType: string;\n\n  protected constructor(args: IActorQueryOperationTypedMediatedArgs, predicateType: string) {\n    super(args, 'path');\n    this.predicateType = predicateType;\n  }\n\n  public async testOperation(operation: Algebra.Path, context: IActionContext): Promise<IActorTest> {\n    if (operation.predicate.type !== this.predicateType) {\n      throw new Error(`This Actor only supports ${this.predicateType} Path operations.`);\n    }\n\n    return true;\n  }\n\n  // Generates a variable that does not yet occur in the path\n  public generateVariable(path?: Algebra.Path, name?: string): RDF.Variable {\n    if (!name) {\n      return this.generateVariable(path, 'b');\n    }\n\n    // Path predicates can't contain variables\n    if (path && (path.subject.value === name || path.object.value === name)) {\n      return this.generateVariable(path, `${name}b`);\n    }\n\n    return DF.variable(name);\n  }\n\n  // Such connectivity matching does not introduce duplicates (it does not incorporate any count of the number\n  // of ways the connection can be made) even if the repeated path itself would otherwise result in duplicates.\n  // https://www.w3.org/TR/sparql11-query/#propertypaths\n  public async isPathArbitraryLengthDistinct(context: IActionContext, path: Algebra.Path):\n  Promise<{ context: IActionContext; operation: IQueryOperationResultBindings | undefined }> {\n    if (!context.get(KeysQueryOperation.isPathArbitraryLengthDistinctKey)) {\n      context = context.set(KeysQueryOperation.isPathArbitraryLengthDistinctKey, true);\n      return { context,\n        operation: ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n          operation: ActorAbstractPath.FACTORY.createDistinct(path),\n          context,\n        })) };\n    }\n\n    context = context.set(KeysQueryOperation.isPathArbitraryLengthDistinctKey, false);\n    return { context, operation: undefined };\n  }\n\n  private async predicateStarGraphVariable(\n    subject: RDF.Term,\n    object: RDF.Variable,\n    predicate: Algebra.PropertyPathSymbol,\n    graph: RDF.Variable,\n    context: IActionContext,\n  ): Promise<IPathResultStream> {\n    // TODO: refactor this with an iterator just like PathVariableObjectIterator so we handle backpressure correctly\n    // Construct path to obtain all graphs where subject exists\n    const predVar = this.generateVariable(ActorAbstractPath.FACTORY\n      .createPath(subject, predicate, object, graph));\n    const findGraphs = ActorAbstractPath.FACTORY.createUnion([\n      ActorAbstractPath.FACTORY.createPattern(subject, predVar, object, graph),\n      ActorAbstractPath.FACTORY.createPattern(object, predVar, subject, graph),\n    ]);\n    const results = ActorQueryOperation.getSafeBindings(\n      await this.mediatorQueryOperation.mediate({ context, operation: findGraphs }),\n    );\n\n    const passedGraphs: Set<string> = new Set();\n\n    const bindingsStream = new MultiTransformIterator<Bindings, Bindings>(\n      results.bindingsStream,\n      {\n        multiTransform: (bindings: Bindings) => {\n          // Extract the graph and start a predicate* search starting from subject in each graph\n          const graphValue: RDF.Term = bindings.get(graph)!;\n          if (passedGraphs.has(graphValue.value)) {\n            return new EmptyIterator();\n          }\n          passedGraphs.add(graphValue.value);\n          return new TransformIterator<Bindings>(\n            async() => {\n              const it = new BufferedIterator<RDF.Term>();\n              await this.getObjectsPredicateStar(subject, predicate, graphValue, context, {}, it, { count: 0 });\n              return it.transform<Bindings>({\n                transform(item, next, push) {\n                  push(BF.bindings([\n                    [ object, item ],\n                    [ graph, graphValue ],\n                  ]));\n                  next();\n                },\n              });\n            }, { maxBufferSize: 128 },\n          );\n        },\n        autoStart: false,\n      },\n    );\n\n    return {\n      bindingsStream,\n      metadata: results.metadata,\n    };\n  }\n\n  /**\n   * Returns an iterator with Bindings of the query subject predicate* ?o or subject predicate+ ?o\n   * If graph is a variable, it will also be in those bindings\n   * @param {Term} subject Term of where we start the predicate* search.\n   * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.\n   * @param {Variable} object Variable of the zeroOrMore-query.\n   * @param {Term} graph The graph in which we search for the pattern. (Possibly a variable)\n   * @param {ActionContext} context The context to pass to sub-opertations\n   * @param emitFirstSubject If the path operation is predicate*, otherwise it is predicate+.\n   * @return {Promise<AsyncIterator<Bindings>} Iterator to where all bindings of query should have been pushed.\n   */\n  public async getObjectsPredicateStarEval(\n    subject: RDF.Term,\n    predicate: Algebra.PropertyPathSymbol,\n    object: RDF.Variable,\n    graph: RDF.Term,\n    context: IActionContext,\n    emitFirstSubject: boolean,\n  ): Promise<IPathResultStream> {\n    if (graph.termType === 'Variable') {\n      return this.predicateStarGraphVariable(subject, object, predicate, graph, context);\n    }\n\n    const it = new PathVariableObjectIterator(\n      subject,\n      predicate,\n      graph,\n      context,\n      this.mediatorQueryOperation,\n      emitFirstSubject,\n    );\n\n    const bindingsStream = it.transform<Bindings>({\n      autoStart: false,\n      transform(item, next, push) {\n        push(BF.bindings([[ object, item ]]));\n        next();\n      },\n    });\n\n    return {\n      bindingsStream,\n      metadata: () => new Promise(resolve => it.getProperty('metadata', (metadata: any) => resolve(metadata()))),\n    };\n  }\n\n  /**\n     * Pushes all terms to iterator `it` that are a solution of object predicate* ?o.\n     * @param {Term} object Term of where we start the predicate* search.\n     * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.\n     * @param {Term} graph The graph in which we search for the pattern.\n     * @param {ActionContext} context\n     * @param {Record<string, Term>} termHashes Remembers the objects we've already searched for.\n     * @param {BufferedIterator<Term>} it Iterator to push terms to.\n     * @param {any} counter Counts how many searches are in progress to close it when needed (when counter == 0).\n     * @return {Promise<IPathResultStream['metadata']>} The results metadata.\n     */\n  public async getObjectsPredicateStar(\n    object: RDF.Term,\n    predicate: Algebra.PropertyPathSymbol,\n    graph: RDF.Term,\n    context: IActionContext,\n    termHashes: Record<string, RDF.Term>,\n    it: BufferedIterator<RDF.Term>,\n    counter: any,\n  ): Promise<IPathResultStream['metadata'] | undefined> {\n    const termString = termToString(object);\n    if (termHashes[termString]) {\n      return;\n    }\n\n    (<any> it)._push(object);\n    termHashes[termString] = object;\n    counter.count++;\n\n    const thisVariable = this.generateVariable();\n    const path = ActorAbstractPath.FACTORY.createPath(object, predicate, thisVariable, graph);\n    const results = ActorQueryOperation.getSafeBindings(\n      await this.mediatorQueryOperation.mediate({ operation: path, context }),\n    );\n    results.bindingsStream.on('data', async(bindings: Bindings) => {\n      const result = bindings.get(thisVariable);\n      await this.getObjectsPredicateStar(result!, predicate, graph, context, termHashes, it, counter);\n    });\n    results.bindingsStream.on('end', () => {\n      if (--counter.count === 0) {\n        it.close();\n      }\n    });\n\n    return results.metadata;\n  }\n\n  /**\n     * Pushes all terms to iterator `it` that are a solution of ?s predicate* ?o.\n     * @param {string} subjectVar String representation of subjectVariable\n     * @param {string} objectVar String representation of objectVariable\n     * @param {Term} subjectVal Term of where we start the predicate* search.\n     * @param {Term} objectVal Found solution for an object, start for the new step.\n     * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.\n     * @param {Term} graph The graph in which we search for the pattern.\n     * @param {ActionContext} context\n     * @param {{[id: string]: Promise<Term[]>}} termHashesGlobal\n     * Remembers solutions for when objectVal is already been calculated, can be reused when same objectVal occurs\n     * @param {{[id: string]: Term}} termHashesCurrentSubject\n     * Remembers the pairs we've already searched for, can stop searching if so.\n     * @param {BufferedIterator<Bindings>} it Iterator to push terms to.\n     * @param {any} counter Counts how many searches are in progress to close it when needed (when counter == 0).\n     * @return {Promise<void>} All solutions of query should have been pushed to it by then.\n     */\n  // Let the iterator `it` emit all bindings of size 2, with subjectStringVariable as value subjectVal\n  // and objectStringVariable as value all nodes reachable through predicate* beginning at objectVal\n  public async getSubjectAndObjectBindingsPredicateStar(\n    subjectVar: RDF.Variable,\n    objectVar: RDF.Variable,\n    subjectVal: RDF.Term,\n    objectVal: RDF.Term,\n    predicate: Algebra.PropertyPathSymbol,\n    graph: RDF.Term,\n    context: IActionContext,\n    termHashesGlobal: Record<string, Promise<RDF.Term[]>>,\n    termHashesCurrentSubject: Record<string, boolean>,\n    it: BufferedIterator<Bindings>,\n    counter: any,\n  ): Promise<void> {\n    const termString = termToString(objectVal) + termToString(graph);\n\n    // If this combination of subject and object already done, return nothing\n    if (termHashesCurrentSubject[termString]) {\n      return;\n    }\n\n    counter.count++;\n    termHashesCurrentSubject[termString] = true;\n    (<any> it)._push(BF.bindings([\n      [ subjectVar, subjectVal ],\n      [ objectVar, objectVal ],\n    ]));\n\n    // If every reachable node from object has already been calculated, use these for current subject too\n    if (termString in termHashesGlobal) {\n      const objects = await termHashesGlobal[termString];\n      for (const object of objects) {\n        await this.getSubjectAndObjectBindingsPredicateStar(\n          subjectVar,\n          objectVar,\n          subjectVal,\n          object,\n          predicate,\n          graph,\n          context,\n          termHashesGlobal,\n          termHashesCurrentSubject,\n          it,\n          counter,\n        );\n      }\n      if (--counter.count === 0) {\n        it.close();\n      }\n\n      return;\n    }\n\n    // Construct promise to calculate all reachable nodes from this object\n    const promise = new Promise<RDF.Term[]>(async(resolve, reject) => {\n      const objectsArray: RDF.Term[] = [];\n\n      // Construct path that leads us one step through predicate\n      const thisVariable = this.generateVariable();\n      const path = ActorAbstractPath.FACTORY.createPath(objectVal, predicate, thisVariable, graph);\n      const results = ActorQueryOperation.getSafeBindings(\n        await this.mediatorQueryOperation.mediate({ operation: path, context }),\n      );\n\n      // Recursive call on all neighbours\n      results.bindingsStream.on('data', async(bindings: RDF.Bindings) => {\n        const result: RDF.Term = bindings.get(thisVariable)!;\n        objectsArray.push(result);\n        await this.getSubjectAndObjectBindingsPredicateStar(\n          subjectVar,\n          objectVar,\n          subjectVal,\n          result,\n          predicate,\n          graph,\n          context,\n          termHashesGlobal,\n          termHashesCurrentSubject,\n          it,\n          counter,\n        );\n      });\n      results.bindingsStream.on('error', reject);\n      results.bindingsStream.on('end', () => {\n        if (--counter.count === 0) {\n          it.close();\n        }\n        resolve(objectsArray);\n      });\n    });\n\n    // Set it in the termHashesGlobal when this object occurs again they can wait for this promise\n    termHashesGlobal[termString] = promise;\n  }\n}\n\nexport interface IPathResultStream {\n  bindingsStream: AsyncIterator<Bindings>;\n  metadata: () => Promise<MetadataBindings>;\n}\n"]}