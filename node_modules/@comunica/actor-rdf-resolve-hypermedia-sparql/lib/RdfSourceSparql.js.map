{"version":3,"file":"RdfSourceSparql.js","sourceRoot":"","sources":["RdfSourceSparql.ts"],"names":[],"mappings":"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","sourcesContent":["import { BindingsFactory } from '@comunica/bindings-factory';\nimport type { MediatorHttp } from '@comunica/bus-http';\nimport type { IQuadSource } from '@comunica/bus-rdf-resolve-quad-pattern';\nimport type { Bindings, BindingsStream, IActionContext } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { wrap } from 'asynciterator';\nimport { SparqlEndpointFetcher } from 'fetch-sparql-endpoint';\nimport { DataFactory } from 'rdf-data-factory';\nimport { getTerms, getVariables, mapTerms } from 'rdf-terms';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { Factory, toSparql } from 'sparqlalgebrajs';\n\nconst DF = new DataFactory();\nconst BF = new BindingsFactory();\nconst VAR_COUNT = DF.variable('count');\n\nexport class RdfSourceSparql implements IQuadSource {\n  protected static readonly FACTORY: Factory = new Factory();\n\n  private readonly url: string;\n  private readonly context: IActionContext;\n  private readonly mediatorHttp: MediatorHttp;\n\n  private readonly endpointFetcher: SparqlEndpointFetcher;\n\n  public constructor(url: string, context: IActionContext, mediatorHttp: MediatorHttp, forceHttpGet: boolean) {\n    this.url = url;\n    this.context = context;\n    this.mediatorHttp = mediatorHttp;\n    this.endpointFetcher = new SparqlEndpointFetcher({\n      method: forceHttpGet ? 'GET' : 'POST',\n      fetch: (input: Request | string, init?: RequestInit) => this.mediatorHttp.mediate(\n        { input, init, context: this.context },\n      ),\n      prefixVariableQuestionMark: true,\n    });\n  }\n\n  /**\n   * Replace all blank nodes in a pattern with variables.\n   * If the pattern contains no blank nodes the original pattern gets returned.\n   * @param {RDF.BaseQuad} pattern A quad pattern.\n   * @return {RDF.BaseQuad} A quad pattern with no blank nodes.\n   */\n  public static replaceBlankNodes(pattern: RDF.BaseQuad): RDF.BaseQuad {\n    const variableNames: string[] = getVariables(getTerms(pattern)).map(variableTerm => variableTerm.value);\n    // Track the names the blank nodes get mapped to (required if the name has to change)\n    const blankMap: Record<string, string> = {};\n    let changed = false;\n\n    // For every position, convert to a variable if there is a blank node\n    const result = mapTerms(pattern, term => {\n      if (term.termType === 'BlankNode') {\n        let name = term.value;\n        if (blankMap[name]) {\n          name = blankMap[name];\n        } else {\n          if (variableNames.includes(name)) {\n            // Increase index added to name until we find one that is available (2 loops at most)\n            let idx = 0;\n            while (variableNames.includes(`${name}${idx}`)) {\n              ++idx;\n            }\n            name += idx;\n          }\n          blankMap[term.value] = name;\n          variableNames.push(name);\n        }\n        changed = true;\n        return DF.variable(name);\n      }\n      return term;\n    });\n\n    return changed ? result : pattern;\n  }\n\n  /**\n   * Convert a quad pattern to a BGP with only that pattern.\n   * @param {RDF.pattern} quad A quad pattern.\n   * @return {Bgp} A BGP.\n   */\n  public static patternToBgp(pattern: RDF.BaseQuad): Algebra.Bgp {\n    return RdfSourceSparql.FACTORY.createBgp([ RdfSourceSparql.FACTORY\n      .createPattern(pattern.subject, pattern.predicate, pattern.object, pattern.graph) ]);\n  }\n\n  /**\n   * Convert a quad pattern to a select query for this pattern.\n   * @param {RDF.Quad} pattern A quad pattern.\n   * @return {string} A select query string.\n   */\n  public static patternToSelectQuery(pattern: RDF.BaseQuad): string {\n    const variables: RDF.Variable[] = getVariables(getTerms(pattern));\n    return toSparql(RdfSourceSparql.FACTORY.createProject(\n      RdfSourceSparql.patternToBgp(pattern),\n      variables,\n    ));\n  }\n\n  /**\n   * Convert a quad pattern to a count query for the number of matching triples for this pattern.\n   * @param {RDF.Quad} pattern A quad pattern.\n   * @return {string} A count query string.\n   */\n  public static patternToCountQuery(pattern: RDF.BaseQuad): string {\n    return toSparql(RdfSourceSparql.FACTORY.createProject(\n      RdfSourceSparql.FACTORY.createExtend(\n        RdfSourceSparql.FACTORY.createGroup(\n          RdfSourceSparql.patternToBgp(pattern),\n          [],\n          [ RdfSourceSparql.FACTORY.createBoundAggregate(\n            DF.variable('var0'),\n            'count',\n            RdfSourceSparql.FACTORY.createWildcardExpression(),\n            false,\n          ) ],\n        ),\n        DF.variable('count'),\n        RdfSourceSparql.FACTORY.createTermExpression(DF.variable('var0')),\n      ),\n      [ DF.variable('count') ],\n    ));\n  }\n\n  /**\n   * Send a SPARQL query to a SPARQL endpoint and retrieve its bindings as a stream.\n   * @param {string} endpoint A SPARQL endpoint URL.\n   * @param {string} query A SPARQL query string.\n   * @return {BindingsStream} A stream of bindings.\n   */\n  public queryBindings(endpoint: string, query: string): BindingsStream {\n    const rawStream = this.endpointFetcher.fetchBindings(endpoint, query);\n    return wrap<any>(rawStream, { autoStart: false, maxBufferSize: Number.POSITIVE_INFINITY })\n      .map((rawData: Record<string, RDF.Term>) => BF.bindings(Object.entries(rawData)\n        .map(([ key, value ]) => [ DF.variable(key.slice(1)), value ])));\n  }\n\n  public match(subject: RDF.Term, predicate: RDF.Term, object: RDF.Term, graph: RDF.Term): AsyncIterator<RDF.Quad> {\n    const pattern = RdfSourceSparql.replaceBlankNodes(RdfSourceSparql.FACTORY.createPattern(\n      subject,\n      predicate,\n      object,\n      graph,\n    ));\n    const countQuery: string = RdfSourceSparql.patternToCountQuery(pattern);\n    const selectQuery: string = RdfSourceSparql.patternToSelectQuery(pattern);\n\n    // Emit metadata containing the estimated count (reject is never called)\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    new Promise<Record<string, any>>(resolve => {\n      const bindingsStream: BindingsStream = this.queryBindings(this.url, countQuery);\n      bindingsStream.on('data', (bindings: Bindings) => {\n        const count = bindings.get(VAR_COUNT);\n        if (count) {\n          const cardinality: number = Number.parseInt(count.value, 10);\n          if (Number.isNaN(cardinality)) {\n            return resolve({ cardinality: Number.POSITIVE_INFINITY });\n          }\n          return resolve({ cardinality });\n        }\n        return resolve({ cardinality: Number.POSITIVE_INFINITY });\n      });\n      bindingsStream.on('error', () => resolve({ cardinality: Number.POSITIVE_INFINITY }));\n      bindingsStream.on('end', () => resolve({ cardinality: Number.POSITIVE_INFINITY }));\n    })\n      .then(metadata => quads.setProperty('metadata', { ...metadata, canContainUndefs: true }));\n\n    // Materialize the queried pattern using each found binding.\n    const quads: AsyncIterator<RDF.Quad> & RDF.Stream = this.queryBindings(this.url, selectQuery)\n      .map((bindings: Bindings) => <RDF.Quad> mapTerms(pattern, (value: RDF.Term) => {\n        if (value.termType === 'Variable') {\n          const boundValue = bindings.get(value);\n          if (!boundValue) {\n            quads.destroy(new Error(`The endpoint ${this.url} failed to provide a binding for ${value.value}.`));\n          }\n          return boundValue!;\n        }\n        return value;\n      }));\n\n    return quads;\n  }\n}\n"]}