{"version":3,"file":"ActorQueryOperationService.js","sourceRoot":"","sources":["ActorQueryOperationService.ts"],"names":[],"mappings":";;;AAAA,iEAA6D;AAE7D,uEAAsG;AACtG,+DAAqF;AAGrF,iDAAkD;AAGlD,MAAM,EAAE,GAAG,IAAI,kCAAe,EAAE,CAAC;AAEjC;;;GAGG;AACH,MAAa,0BAA2B,SAAQ,sDAAiD;IAG/F,YAAmB,IAAqC;QACtD,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;IACzB,CAAC;IAEM,KAAK,CAAC,aAAa,CAAC,SAA0B,EAAE,OAAuB;QAC5E,IAAI,SAAS,CAAC,IAAI,CAAC,QAAQ,KAAK,WAAW,EAAE;YAC3C,MAAM,IAAI,KAAK,CAAC,GAAG,IAAI,CAAC,IAAI,4CAA4C,SAAS,CAAC,IAAI,CAAC,QAAQ,aAAa,CAAC,CAAC;SAC/G;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,YAAY,CAAC,SAA0B,EAAE,OAAuB;QAE3E,MAAM,QAAQ,GAAW,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC;QAE9C,yDAAyD;QACzD,IAAI,UAAU,GAAmB,OAAO;aACrC,MAAM,CAAC,2CAAyB,CAAC,MAAM,CAAC;aACxC,MAAM,CAAC,2CAAyB,CAAC,OAAO,CAAC;aACzC,MAAM,CAAC,+BAAa,CAAC,WAAW,CAAC,CAAC;QACrC,MAAM,UAAU,GAAG,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC;QACnE,UAAU,GAAG,UAAU,CAAC,GAAG,CAAC,2CAAyB,CAAC,OAAO,EAAE,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,QAAQ,EAAE,CAAC,CAAC,CAAC;QACxG,mBAAmB;QACnB,IAAI,MAAqC,CAAC;QAC1C,IAAI;YACF,MAAM,GAAG,yCAAmB,CAAC,eAAe,CAC1C,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,EAAE,SAAS,EAAE,SAAS,CAAC,KAAK,EAAE,OAAO,EAAE,UAAU,EAAE,CAAC,CAC/F,CAAC;SACH;QAAC,OAAO,KAAc,EAAE;YACvB,IAAI,SAAS,CAAC,MAAM,EAAE;gBACpB,8BAA8B;gBAC9B,MAAM,GAAG;oBACP,cAAc,EAAE,IAAI,iCAAiB,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC;oBACpD,IAAI,EAAE,UAAU;oBAChB,QAAQ,EAAE,KAAK,IAAG,EAAE,CAAC,CAAC,EAAE,WAAW,EAAE,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,EAAE,gBAAgB,EAAE,KAAK,EAAE,SAAS,EAAE,EAAE,EAAC,CAAC;iBAC3G,CAAC;aACH;iBAAM;gBACL,MAAM,KAAK,CAAC;aACb;SACF;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AA9CD,gEA8CC","sourcesContent":["import { BindingsFactory } from '@comunica/bindings-factory';\nimport type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport { ActorQueryOperation, ActorQueryOperationTypedMediated } from '@comunica/bus-query-operation';\nimport { KeysInitQuery, KeysRdfResolveQuadPattern } from '@comunica/context-entries';\nimport type { IActorTest } from '@comunica/core';\nimport type { IActionContext, IQueryOperationResult, IQueryOperationResultBindings } from '@comunica/types';\nimport { SingletonIterator } from 'asynciterator';\nimport type { Algebra } from 'sparqlalgebrajs';\n\nconst BF = new BindingsFactory();\n\n/**\n * A comunica Service Query Operation Actor.\n * It unwraps the SERVICE operation and executes it on the given source.\n */\nexport class ActorQueryOperationService extends ActorQueryOperationTypedMediated<Algebra.Service> {\n  public readonly forceSparqlEndpoint: boolean;\n\n  public constructor(args: IActorQueryOperationServiceArgs) {\n    super(args, 'service');\n  }\n\n  public async testOperation(operation: Algebra.Service, context: IActionContext): Promise<IActorTest> {\n    if (operation.name.termType !== 'NamedNode') {\n      throw new Error(`${this.name} can only query services by IRI, while a ${operation.name.termType} was given.`);\n    }\n    return true;\n  }\n\n  public async runOperation(operation: Algebra.Service, context: IActionContext):\n  Promise<IQueryOperationResult> {\n    const endpoint: string = operation.name.value;\n\n    // Adjust our context to only have the endpoint as source\n    let subContext: IActionContext = context\n      .delete(KeysRdfResolveQuadPattern.source)\n      .delete(KeysRdfResolveQuadPattern.sources)\n      .delete(KeysInitQuery.queryString);\n    const sourceType = this.forceSparqlEndpoint ? 'sparql' : undefined;\n    subContext = subContext.set(KeysRdfResolveQuadPattern.sources, [{ type: sourceType, value: endpoint }]);\n    // Query the source\n    let output: IQueryOperationResultBindings;\n    try {\n      output = ActorQueryOperation.getSafeBindings(\n        await this.mediatorQueryOperation.mediate({ operation: operation.input, context: subContext }),\n      );\n    } catch (error: unknown) {\n      if (operation.silent) {\n        // Emit a single empty binding\n        output = {\n          bindingsStream: new SingletonIterator(BF.bindings()),\n          type: 'bindings',\n          metadata: async() => ({ cardinality: { type: 'exact', value: 1 }, canContainUndefs: false, variables: []}),\n        };\n      } else {\n        throw error;\n      }\n    }\n\n    return output;\n  }\n}\n\nexport interface IActorQueryOperationServiceArgs extends IActorQueryOperationTypedMediatedArgs {\n  /**\n   * If the SERVICE target should be assumed to be a SPARQL endpoint.\n   * @default {false}\n   */\n  forceSparqlEndpoint: boolean;\n}\n"]}