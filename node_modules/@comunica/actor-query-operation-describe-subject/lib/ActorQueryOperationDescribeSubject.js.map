{"version":3,"file":"ActorQueryOperationDescribeSubject.js","sourceRoot":"","sources":["ActorQueryOperationDescribeSubject.ts"],"names":[],"mappings":";;;AAAA,uFAAiF;AAEjF,uEAEuC;AACvC,+DAA+D;AAI/D,iDAA8C;AAC9C,uDAA+C;AAC/C,qDAA0C;AAE1C,MAAM,EAAE,GAAG,IAAI,8BAAW,EAAgB,CAAC;AAE3C;;GAEG;AACH,MAAa,kCAAmC,SAAQ,sDAAkD;IACxG,YAAmB,IAA2C;QAC5D,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;IAC1B,CAAC;IAEM,KAAK,CAAC,aAAa,CAAC,SAA2B,EAAE,OAAuB;QAC7E,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,YAAY,CAAC,iBAAmC,EAAE,OAAuB;QAEpF,+DAA+D;QAC/D,MAAM,UAAU,GAAwB,iBAAiB,CAAC,KAAK;aAC5D,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,KAAK,UAAU,CAAC;aAC5C,GAAG,CAAC,CAAC,IAAc,EAAE,EAAE;YACtB,kGAAkG;YAClG,MAAM,QAAQ,GAAmB;gBAC/B,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE,EAAE,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;aACnE,CAAC;YACF,4CAA4C;YAC5C,QAAQ,CAAC,OAAO,CAAC,CAAC,eAAoB,EAAE,EAAE,CAAC,eAAe,CAAC,IAAI,GAAG,SAAS,CAAC,CAAC;YAC7E,MAAM,iBAAiB,GAAsB;gBAC3C,IAAI,EAAE,yBAAO,CAAC,KAAK,CAAC,GAAG;gBACvB,QAAQ,EAAsB,QAAQ;aACvC,CAAC;YAEF,2BAA2B;YAC3B,OAA2B;gBACzB,KAAK,EAAE,iBAAiB;gBACxB,QAAQ,EAAsB,QAAQ;gBACtC,IAAI,EAAE,WAAW;aAClB,CAAC;QACJ,CAAC,CAAC,CAAC;QAEL,yCAAyC;QACzC,gGAAgG;QAChG,IAAI,UAAU,CAAC,MAAM,KAAK,iBAAiB,CAAC,KAAK,CAAC,MAAM,EAAE;YACxD,IAAI,gBAAgB,GAAsB,EAAE,CAAC;YAC7C,iBAAiB,CAAC,KAAK;iBACpB,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,KAAK,UAAU,CAAC;iBAC5C,OAAO,CAAC,CAAC,IAAc,EAAE,CAAS,EAAE,EAAE;gBACrC,qEAAqE;gBACrE,MAAM,QAAQ,GAAmB;oBAC/B,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,EAAE,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;iBAC3E,CAAC;gBACF,4CAA4C;gBAC5C,QAAQ,CAAC,OAAO,CAAC,CAAC,eAAoB,EAAE,EAAE,CAAC,eAAe,CAAC,IAAI,GAAG,SAAS,CAAC,CAAC;gBAC7E,gBAAgB,GAAG,CAAE,GAAG,gBAAgB,EAAE,GAAuB,QAAQ,CAAE,CAAC;YAC9E,CAAC,CAAC,CAAC;YAEL,2CAA2C;YAC3C,kGAAkG;YAClG,UAAU,CAAC,IAAI,CAAC;gBACd,KAAK,EAAE;oBACL,IAAI,EAAE,yBAAO,CAAC,KAAK,CAAC,IAAI;oBACxB,KAAK,EAAE;wBACL,iBAAiB,CAAC,KAAK;wBACvB,EAAE,IAAI,EAAE,yBAAO,CAAC,KAAK,CAAC,GAAG,EAAE,QAAQ,EAAE,gBAAgB,EAAE;qBACxD;iBACF;gBACD,QAAQ,EAAE,gBAAgB;gBAC1B,IAAI,EAAE,yBAAO,CAAC,KAAK,CAAC,SAAS;aAC9B,CAAC,CAAC;SACJ;QAED,kCAAkC;QAClC,wFAAwF;QACxF,MAAM,iBAAiB,GAAG,OAAO,CAAC,GAAG,CAAC,oCAAkB,CAAC,kBAAkB,CAAC,CAAC;QAC7E,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC,oCAAkB,CAAC,kBAAkB,EAAE,iBAAiB,KAAK,SAAS,CAAC,CAAC;YAClF,iBAAiB,CAAC,CAAC;YAC7B,KAAK,CAAC,CAAC;QACT,iCAAiC;QACjC,MAAM,OAAO,GAAiC,CAAC,MAAM,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAC7E,SAAS,CAAC,EAAE,CAAC,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,CAAC,CACzE,CAAC,CAAC;aACA,GAAG,CAAC,yCAAmB,CAAC,YAAY,CAAC,CAAC;QAEzC,qCAAqC;QACrC,MAAM,UAAU,GAAG,IAAI,6BAAa,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC;QAErG,yBAAyB;QACzB,MAAM,QAAQ,GAAiC,GAAG,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO;aACrE,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;aACvB,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,sDAAwB,CAAC,aAAa,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC;QAE/E,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,UAAU,EAAE,QAAQ,EAAE,CAAC;IACjD,CAAC;CACF;AAvFD,gFAuFC","sourcesContent":["import { ActorQueryOperationUnion } from '@comunica/actor-query-operation-union';\nimport type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperation, ActorQueryOperationTypedMediated,\n} from '@comunica/bus-query-operation';\nimport { KeysQueryOperation } from '@comunica/context-entries';\nimport type { IActorTest } from '@comunica/core';\nimport type { IQueryOperationResultQuads, IActionContext, IQueryOperationResult, MetadataQuads } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { UnionIterator } from 'asynciterator';\nimport { DataFactory } from 'rdf-data-factory';\nimport { Algebra } from 'sparqlalgebrajs';\n\nconst DF = new DataFactory<RDF.BaseQuad>();\n\n/**\n * A comunica Describe Subject Query Operation Actor.\n */\nexport class ActorQueryOperationDescribeSubject extends ActorQueryOperationTypedMediated<Algebra.Describe> {\n  public constructor(args: IActorQueryOperationTypedMediatedArgs) {\n    super(args, 'describe');\n  }\n\n  public async testOperation(operation: Algebra.Describe, context: IActionContext): Promise<IActorTest> {\n    return true;\n  }\n\n  public async runOperation(operationOriginal: Algebra.Describe, context: IActionContext):\n  Promise<IQueryOperationResult> {\n    // Create separate construct queries for all non-variable terms\n    const operations: Algebra.Construct[] = operationOriginal.terms\n      .filter(term => term.termType !== 'Variable')\n      .map((term: RDF.Term) => {\n        // Transform each term to a separate construct operation with S ?p ?o patterns (BGP) for all terms\n        const patterns: RDF.BaseQuad[] = [\n          DF.quad(term, DF.variable('__predicate'), DF.variable('__object')),\n        ];\n        // eslint-disable-next-line no-return-assign\n        patterns.forEach((templatePattern: any) => templatePattern.type = 'pattern');\n        const templateOperation: Algebra.Operation = {\n          type: Algebra.types.BGP,\n          patterns: <Algebra.Pattern[]> patterns,\n        };\n\n        // Create a construct query\n        return <Algebra.Construct> {\n          input: templateOperation,\n          template: <Algebra.Pattern[]> patterns,\n          type: 'construct',\n        };\n      });\n\n    // If we have variables in the term list,\n    // create one separate construct operation to determine these variables using the input pattern.\n    if (operations.length !== operationOriginal.terms.length) {\n      let variablePatterns: Algebra.Pattern[] = [];\n      operationOriginal.terms\n        .filter(term => term.termType === 'Variable')\n        .forEach((term: RDF.Term, i: number) => {\n          // Transform each term to an S ?p ?o pattern in a non-conflicting way\n          const patterns: RDF.BaseQuad[] = [\n            DF.quad(term, DF.variable(`__predicate${i}`), DF.variable(`__object${i}`)),\n          ];\n          // eslint-disable-next-line no-return-assign\n          patterns.forEach((templatePattern: any) => templatePattern.type = 'pattern');\n          variablePatterns = [ ...variablePatterns, ...<Algebra.Pattern[]> patterns ];\n        });\n\n      // Add a single construct for the variables\n      // This requires a join between the input pattern and our variable patterns that form a simple BGP\n      operations.push({\n        input: {\n          type: Algebra.types.JOIN,\n          input: [\n            operationOriginal.input,\n            { type: Algebra.types.BGP, patterns: variablePatterns },\n          ],\n        },\n        template: variablePatterns,\n        type: Algebra.types.CONSTRUCT,\n      });\n    }\n\n    // Set the blank node localization\n    // If it was not provided by the context it will set to false and added into the context\n    const localizeBlankNode = context.get(KeysQueryOperation.localizeBlankNodes);\n    context = context.set(KeysQueryOperation.localizeBlankNodes, localizeBlankNode !== undefined ?\n      <boolean> localizeBlankNode :\n      false);\n    // Evaluate the construct queries\n    const outputs: IQueryOperationResultQuads[] = (await Promise.all(operations.map(\n      operation => this.mediatorQueryOperation.mediate({ operation, context }),\n    )))\n      .map(ActorQueryOperation.getSafeQuads);\n\n    // Take the union of all quad streams\n    const quadStream = new UnionIterator(outputs.map(output => output.quadStream), { autoStart: false });\n\n    // Take union of metadata\n    const metadata: () => Promise<MetadataQuads> = () => Promise.all(outputs\n      .map(x => x.metadata()))\n      .then(metadatas => ActorQueryOperationUnion.unionMetadata(metadatas, false));\n\n    return { type: 'quads', quadStream, metadata };\n  }\n}\n"]}