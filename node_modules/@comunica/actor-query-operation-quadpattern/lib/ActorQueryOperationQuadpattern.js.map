{"version":3,"file":"ActorQueryOperationQuadpattern.js","sourceRoot":"","sources":["ActorQueryOperationQuadpattern.ts"],"names":[],"mappings":"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","sourcesContent":["import { BindingsFactory } from '@comunica/bindings-factory';\nimport type { IActionQueryOperation } from '@comunica/bus-query-operation';\nimport { ActorQueryOperationTyped, ClosableTransformIterator } from '@comunica/bus-query-operation';\nimport type { MediatorRdfResolveQuadPattern } from '@comunica/bus-rdf-resolve-quad-pattern';\nimport { KeysQueryOperation } from '@comunica/context-entries';\nimport type { IActorArgs, IActorTest } from '@comunica/core';\nimport type { BindingsStream,\n  IQueryOperationResult,\n  IActionContext, MetadataBindings,\n  MetadataQuads, TermsOrder } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { DataFactory } from 'rdf-data-factory';\nimport type { QuadTermName } from 'rdf-terms';\nimport { getTerms, QUAD_TERM_NAMES, reduceTerms, TRIPLE_TERM_NAMES, uniqTerms } from 'rdf-terms';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { Factory } from 'sparqlalgebrajs';\n\nconst BF = new BindingsFactory();\nconst DF = new DataFactory();\nconst AF = new Factory();\n\n/**\n * A comunica actor for handling 'quadpattern' query operations.\n */\nexport class ActorQueryOperationQuadpattern extends ActorQueryOperationTyped<Algebra.Pattern>\n  implements IActorQueryOperationQuadpatternArgs {\n  public readonly mediatorResolveQuadPattern: MediatorRdfResolveQuadPattern;\n  public readonly unionDefaultGraph: boolean;\n\n  public constructor(args: IActorQueryOperationQuadpatternArgs) {\n    super(args, 'pattern');\n  }\n\n  /**\n   * Check if a term is a variable.\n   * @param {RDF.Term} term An RDF term.\n   * @return {any} If the term is a variable or blank node.\n   */\n  public static isTermVariable(term: RDF.Term): any {\n    return term.termType === 'Variable';\n  }\n\n  /**\n   * Get all variables in the given pattern.\n   * No duplicates are returned.\n   * @param {RDF.BaseQuad} pattern A quad pattern.\n   */\n  public static getVariables(pattern: RDF.BaseQuad): RDF.Variable[] {\n    return <RDF.Variable[]> uniqTerms(getTerms(pattern)\n      .filter(ActorQueryOperationQuadpattern.isTermVariable));\n  }\n\n  /**\n   * A helper function to find a hash with quad elements that have duplicate variables.\n   *\n   * @param {RDF.Quad} pattern A quad pattern.\n   *\n   * @return {{[p: string]: string[]}} If no equal variable names are present in the four terms, this returns undefined.\n   *                                   Otherwise, this maps quad elements ('subject', 'predicate', 'object', 'graph')\n   *                                   to the list of quad elements it shares a variable name with.\n   *                                   If no links for a certain element exist, this element will\n   *                                   not be included in the hash.\n   *                                   Note 1: Quad elements will never have a link to themselves.\n   *                                           So this can never occur: { subject: [ 'subject'] },\n   *                                           instead 'null' would be returned.\n   *                                   Note 2: Links only exist in one direction,\n   *                                           this means that { subject: [ 'predicate'], predicate: [ 'subject' ] }\n   *                                           will not occur, instead only { subject: [ 'predicate'] }\n   *                                           will be returned.\n   */\n  public static getDuplicateElementLinks(pattern: RDF.BaseQuad): Record<string, string[]> | undefined {\n    // Collect a variable to quad elements mapping.\n    const variableElements: Record<string, string[]> = {};\n    let duplicateVariables = false;\n    for (const key of QUAD_TERM_NAMES) {\n      if (pattern[key].termType === 'Variable') {\n        const val = pattern[key].value;\n        const length = (variableElements[val] || (variableElements[val] = [])).push(key);\n        duplicateVariables = duplicateVariables || length > 1;\n      }\n    }\n\n    if (!duplicateVariables) {\n      return;\n    }\n\n    // Collect quad element to elements with equal variables mapping.\n    const duplicateElementLinks: Record<string, string[]> = {};\n    for (const variable in variableElements) {\n      const elements = variableElements[variable];\n      const remainingElements = elements.slice(1);\n      // Only store the elements that have at least one equal element.\n      if (remainingElements.length > 0) {\n        duplicateElementLinks[elements[0]] = remainingElements;\n      }\n    }\n\n    return duplicateElementLinks;\n  }\n\n  /**\n   * Ensure that the given raw metadata object contains all required metadata entries.\n   * @param metadataRaw A raw metadata object.\n   */\n  public static validateMetadata(metadataRaw: Record<string, any>): MetadataQuads {\n    for (const key of [ 'cardinality', 'canContainUndefs' ]) {\n      if (!(key in metadataRaw)) {\n        throw new Error(`Invalid metadata: missing ${key} in ${JSON.stringify(metadataRaw)}`);\n      }\n    }\n    return <MetadataQuads> metadataRaw;\n  }\n\n  /**\n   * Get the metadata of the given action on a quad stream.\n   *\n   * @param {AsyncIterator<Quad>} data The data stream that is guaranteed to emit the metadata property.\n   * @param elementVariables Mapping of quad term name to variable name.\n   * @param variables Variables to include in the metadata\n   * @return {() => Promise<{[p: string]: any}>} A lazy promise behind a callback resolving to a metadata object.\n   */\n  protected static getMetadata(\n    data: AsyncIterator<RDF.Quad>,\n    elementVariables: Record<string, string>,\n    variables: RDF.Variable[],\n  ): () => Promise<MetadataBindings> {\n    return () => new Promise<Record<string, any>>((resolve, reject) => {\n      data.getProperty('metadata', (metadata: Record<string, any>) => resolve(metadata));\n      data.on('error', reject);\n    }).then(metadataRaw => {\n      if (!('canContainUndefs' in metadataRaw)) {\n        metadataRaw.canContainUndefs = false;\n      }\n      return ActorQueryOperationQuadpattern.quadsMetadataToBindingsMetadata(\n        ActorQueryOperationQuadpattern.validateMetadata(metadataRaw),\n        elementVariables,\n        variables,\n      );\n    });\n  }\n\n  protected static quadsMetadataToBindingsMetadata(\n    metadataQuads: MetadataQuads,\n    elementVariables: Record<string, string>,\n    variables: RDF.Variable[],\n  ): MetadataBindings {\n    return {\n      ...metadataQuads,\n      order: metadataQuads.order ?\n        ActorQueryOperationQuadpattern.quadsOrderToBindingsOrder(metadataQuads.order, elementVariables) :\n        undefined,\n      availableOrders: metadataQuads.availableOrders ?\n        metadataQuads.availableOrders.map(orderDef => ({\n          cost: orderDef.cost,\n          terms: ActorQueryOperationQuadpattern.quadsOrderToBindingsOrder(orderDef.terms, elementVariables),\n        })) :\n        undefined,\n      variables,\n    };\n  }\n\n  protected static quadsOrderToBindingsOrder(\n    quadsOrder: TermsOrder<RDF.QuadTermName>,\n    elementVariables: Record<string, string>,\n  ): TermsOrder<RDF.Variable> {\n    const mappedVariables: Record<string, boolean> = {};\n    return <TermsOrder<RDF.Variable>> quadsOrder.map(entry => {\n      // Omit entries that do not map to a variable\n      const variableName = elementVariables[entry.term];\n      if (!variableName) {\n        return;\n      }\n\n      // Omit entries that have been mapped already\n      if (mappedVariables[variableName]) {\n        return;\n      }\n\n      mappedVariables[variableName] = true;\n      return {\n        term: DF.variable(variableName),\n        direction: entry.direction,\n      };\n    }).filter(entry => Boolean(entry));\n  }\n\n  public async testOperation(operation: Algebra.Pattern, context: IActionContext): Promise<IActorTest> {\n    return true;\n  }\n\n  public async runOperation(pattern: Algebra.Pattern, context: IActionContext):\n  Promise<IQueryOperationResult> {\n    // Apply the (optional) pattern-specific context\n    if (pattern.context) {\n      context = context.merge(pattern.context);\n    }\n\n    // Modify pattern with default graph when using union default graph semantics\n    let patternInner = pattern;\n    const unionDefaultGraph = this.unionDefaultGraph || context.get(KeysQueryOperation.unionDefaultGraph);\n    if (pattern.graph.termType === 'DefaultGraph' && unionDefaultGraph) {\n      patternInner = AF.createPattern(\n        pattern.subject,\n        pattern.predicate,\n        pattern.object,\n        DF.variable('__comunica:defaultGraph'),\n      );\n    }\n\n    // Resolve the quad pattern\n    const result = await this.mediatorResolveQuadPattern.mediate({ pattern: patternInner, context });\n\n    // Collect all variables from the pattern\n    const variables = ActorQueryOperationQuadpattern.getVariables(pattern);\n\n    // Convenience datastructure for mapping quad elements to variables\n    const elementVariables: Record<string, string> = reduceTerms(pattern,\n      (acc: Record<string, string>, term: RDF.Term, key: QuadTermName) => {\n        if (term.termType === 'Variable') {\n          acc[key] = term.value;\n        }\n        return acc;\n      },\n      {});\n    const quadBindingsReducer = (acc: [RDF.Variable, RDF.Term][], term: RDF.Term, key: QuadTermName):\n    [RDF.Variable, RDF.Term][] => {\n      const variable: string = elementVariables[key];\n      if (variable) {\n        acc.push([ DF.variable(variable), term ]);\n      }\n      return acc;\n    };\n\n    // Create the metadata callback\n    const metadata = ActorQueryOperationQuadpattern.getMetadata(result.data, elementVariables, variables);\n\n    // Optionally filter, and construct bindings\n    const bindingsStream: BindingsStream = new ClosableTransformIterator(async() => {\n      let filteredOutput = result.data;\n\n      // Detect duplicate variables in the pattern\n      const duplicateElementLinks: Record<string, string[]> | undefined = ActorQueryOperationQuadpattern\n        .getDuplicateElementLinks(pattern);\n\n      // SPARQL query semantics allow graph variables to only match with named graphs, excluding the default graph\n      // But this is not the case when using union default graph semantics\n      if (pattern.graph.termType === 'Variable' && !unionDefaultGraph) {\n        filteredOutput = filteredOutput.filter(quad => quad.graph.termType !== 'DefaultGraph');\n      }\n\n      // If there are duplicate variables in the search pattern,\n      // make sure that we filter out the triples that don't have equal values for those triple elements,\n      // as QPF ignores variable names.\n      if (duplicateElementLinks) {\n        filteredOutput = filteredOutput.filter(quad => {\n          // No need to check the graph, because an equal element already would have to be found in s, p, or o.\n          for (const element1 of TRIPLE_TERM_NAMES) {\n            for (const element2 of duplicateElementLinks[element1] || []) {\n              if (!(<any> quad)[element1].equals((<any> quad)[element2])) {\n                return false;\n              }\n            }\n          }\n          return true;\n        });\n      }\n\n      return filteredOutput.map(quad => BF.bindings(reduceTerms(quad, quadBindingsReducer, [])));\n    }, {\n      autoStart: false,\n      onClose: () => result.data.destroy(),\n    });\n\n    return { type: 'bindings', bindingsStream, metadata };\n  }\n}\n\nexport interface IActorQueryOperationQuadpatternArgs extends\n  IActorArgs<IActionQueryOperation, IActorTest, IQueryOperationResult> {\n  /**\n   * The quad pattern resolve mediator\n   */\n  mediatorResolveQuadPattern: MediatorRdfResolveQuadPattern;\n  /**\n   * If the default graph should also contain the union of all named graphs.\n   * This can be overridden by {@link KeysQueryOperation#unionDefaultGraph}.\n   * @default {false}\n   */\n  unionDefaultGraph: boolean;\n}\n"]}