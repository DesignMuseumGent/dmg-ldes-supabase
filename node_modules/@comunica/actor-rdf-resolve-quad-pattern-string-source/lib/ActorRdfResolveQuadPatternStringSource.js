"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorRdfResolveQuadPatternStringSource = void 0;
const bus_rdf_resolve_quad_pattern_1 = require("@comunica/bus-rdf-resolve-quad-pattern");
const context_entries_1 = require("@comunica/context-entries");
const LRUCache = require("lru-cache");
const rdf_store_stream_1 = require("rdf-store-stream");
const readable_stream_1 = require("readable-stream");
/**
 * A comunica RDF Resolve Quad Pattern String Source RDF Resolve Quad Pattern Actor.
 */
class ActorRdfResolveQuadPatternStringSource extends bus_rdf_resolve_quad_pattern_1.ActorRdfResolveQuadPattern {
    constructor(args) {
        super(args);
        this.cache = this.cacheSize ? new LRUCache({ max: this.cacheSize }) : undefined;
    }
    async test(action) {
        const source = (0, bus_rdf_resolve_quad_pattern_1.getContextSource)(action.context);
        if (!source) {
            throw new Error(`Actor ${this.name} can only resolve quad pattern queries against a source.`);
        }
        if (!this.isStringSource(source.valueOf())) {
            throw new Error(`Actor ${this.name} can only resolve stringSource quad pattern`);
        }
        return true;
    }
    run(action) {
        const source = (0, bus_rdf_resolve_quad_pattern_1.getContextSource)(action.context);
        // A source should only be parsed once (see getRdfSource comment), so if it has been parsed,
        // that earlier result should be used. Note: if the object is identical value-wise, but is not
        // the same exact object, it will get parsed again and saved in the cache as its own entry!
        let rdfSourcePromise = this.cache?.get(source);
        if (!rdfSourcePromise) {
            rdfSourcePromise = this.getRdfSource(action.context, source);
            if (this.cache) {
                this.cache.set(source, rdfSourcePromise);
            }
        }
        return new Promise((resolve, reject) => rdfSourcePromise
            .then(rdfSource => {
            const resolveQuadAction = {
                pattern: action.pattern,
                context: action.context.set(context_entries_1.KeysRdfResolveQuadPattern.source, {
                    value: rdfSource,
                    type: 'rdfjsSource',
                }),
            };
            resolve(this.mediatorRdfResolveQuadPattern.mediate(resolveQuadAction));
        }).catch(reject));
    }
    /**
     * Parses the string data source through the RDF parse bus, returning the RDF source.
     * Parsing a source with blank nodes may produce different identifiers for the same nodes
     * on different parses, for example if the source gets parsed separately for each pattern
     * in a query. Consequently, a single source should only be parsed once, and the parse result cached.
     * @param context The run action context
     * @param source The source from the run action context
     * @returns Parsed RDF source that can be passed to quad pattern resolve mediator as an rdfjsSource
     */
    async getRdfSource(context, source) {
        const textStream = new readable_stream_1.Readable({ objectMode: true });
        /* istanbul ignore next */
        textStream._read = () => {
            // Do nothing
        };
        textStream.push(source.value);
        textStream.push(null);
        const parseAction = {
            context,
            handle: {
                metadata: { baseIRI: source.baseIRI },
                data: textStream,
                context,
            },
            handleMediaType: source.mediaType,
        };
        const parseResult = await this.mediatorRdfParse.mediate(parseAction);
        return await (0, rdf_store_stream_1.storeStream)(parseResult.handle.data);
    }
    isStringSource(datasource) {
        if (!('type' in datasource)) {
            if (!(typeof datasource.value === 'string')) {
                return false;
            }
            return 'mediaType' in datasource;
        }
        return datasource.type === ActorRdfResolveQuadPatternStringSource.sourceType;
    }
}
exports.ActorRdfResolveQuadPatternStringSource = ActorRdfResolveQuadPatternStringSource;
ActorRdfResolveQuadPatternStringSource.sourceType = 'stringSource';
//# sourceMappingURL=ActorRdfResolveQuadPatternStringSource.js.map