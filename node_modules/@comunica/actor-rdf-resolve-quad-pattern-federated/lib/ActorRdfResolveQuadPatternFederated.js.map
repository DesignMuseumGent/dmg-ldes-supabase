{"version":3,"file":"ActorRdfResolveQuadPatternFederated.js","sourceRoot":"","sources":["ActorRdfResolveQuadPatternFederated.ts"],"names":[],"mappings":";;;AAIA,yFAEgD;AAIhD,+DAA4D;AAE5D;;GAEG;AACH,MAAa,mCAAoC,SAAQ,+DAAgC;IAOvF,YAAmB,IAA8C;QAC/D,KAAK,CAAC,IAAI,CAAC,CAAC;QAHK,kBAAa,GAAiC,IAAI,GAAG,EAAE,CAAC;IAI3E,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,MAAoC;QACpD,MAAM,OAAO,GAAG,IAAA,gDAAiB,EAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QAClD,IAAI,CAAC,OAAO,EAAE;YACZ,MAAM,IAAI,KAAK,CAAC,SAAS,IAAI,CAAC,IAAI,iEAAiE,CAAC,CAAC;SACtG;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAES,KAAK,CAAC,SAAS,CAAC,OAAuB;QAC/C,OAAO,IAAI,yCAAmB,CAC5B,IAAI,CAAC,0BAA0B,EAC/B,OAAO,EACP,IAAI,CAAC,aAAa,EAClB,IAAI,CAAC,iBAAiB,CACvB,CAAC;IACJ,CAAC;CACF;AA3BD,kFA2BC","sourcesContent":["import type {\n  IActionRdfResolveQuadPattern, IActorRdfResolveQuadPatternArgs,\n  IQuadSource, MediatorRdfResolveQuadPattern,\n} from '@comunica/bus-rdf-resolve-quad-pattern';\nimport {\n  ActorRdfResolveQuadPatternSource, getContextSources,\n} from '@comunica/bus-rdf-resolve-quad-pattern';\nimport type { IActorTest } from '@comunica/core';\nimport type { IActionContext, IDataSource } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { FederatedQuadSource } from './FederatedQuadSource';\n\n/**\n * A comunica Federated RDF Resolve Quad Pattern Actor.\n */\nexport class ActorRdfResolveQuadPatternFederated extends ActorRdfResolveQuadPatternSource\n  implements IActorRdfResolveQuadPatternFederatedArgs {\n  public readonly mediatorResolveQuadPattern: MediatorRdfResolveQuadPattern;\n  public readonly skipEmptyPatterns: boolean;\n\n  protected readonly emptyPatterns: Map<IDataSource, RDF.Quad[]> = new Map();\n\n  public constructor(args: IActorRdfResolveQuadPatternFederatedArgs) {\n    super(args);\n  }\n\n  public async test(action: IActionRdfResolveQuadPattern): Promise<IActorTest> {\n    const sources = getContextSources(action.context);\n    if (!sources) {\n      throw new Error(`Actor ${this.name} can only resolve quad pattern queries against a sources array.`);\n    }\n    return true;\n  }\n\n  protected async getSource(context: IActionContext): Promise<IQuadSource> {\n    return new FederatedQuadSource(\n      this.mediatorResolveQuadPattern,\n      context,\n      this.emptyPatterns,\n      this.skipEmptyPatterns,\n    );\n  }\n}\n\nexport interface IActorRdfResolveQuadPatternFederatedArgs extends IActorRdfResolveQuadPatternArgs {\n  /**\n   * The quad pattern resolve mediator.\n   */\n  mediatorResolveQuadPattern: MediatorRdfResolveQuadPattern;\n  /**\n   * If quad patterns that are sub-patterns of empty quad patterns should be skipped.\n   * This assumes that sources remain static during query evaluation.\n   * @default {false}\n   */\n  skipEmptyPatterns?: boolean;\n}\n"]}