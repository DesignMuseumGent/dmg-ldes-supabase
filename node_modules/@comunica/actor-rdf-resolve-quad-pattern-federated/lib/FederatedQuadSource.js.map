{"version":3,"file":"FederatedQuadSource.js","sourceRoot":"","sources":["FederatedQuadSource.ts"],"names":[],"mappings":"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","sourcesContent":["import { ClosableTransformIterator } from '@comunica/bus-query-operation';\nimport type {\n  IActorRdfResolveQuadPatternOutput,\n  IQuadSource,\n  MediatorRdfResolveQuadPattern,\n} from '@comunica/bus-rdf-resolve-quad-pattern';\nimport { getDataSourceContext } from '@comunica/bus-rdf-resolve-quad-pattern';\nimport { KeysRdfResolveQuadPattern } from '@comunica/context-entries';\nimport { BlankNodeScoped } from '@comunica/data-factory';\nimport type { IActionContext, DataSources, IDataSource, MetadataQuads } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { ArrayIterator, UnionIterator } from 'asynciterator';\nimport { DataFactory } from 'rdf-data-factory';\nimport { mapTerms } from 'rdf-terms';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { Factory } from 'sparqlalgebrajs';\n\nconst DF = new DataFactory();\n\n/**\n * A FederatedQuadSource can evaluate quad pattern queries over the union of different heterogeneous sources.\n * It will call the given mediator to evaluate each quad pattern query separately.\n */\nexport class FederatedQuadSource implements IQuadSource {\n  private static readonly SKOLEM_PREFIX = 'urn:comunica_skolem:source_';\n\n  protected readonly mediatorResolveQuadPattern: MediatorRdfResolveQuadPattern;\n\n  protected readonly sources: DataSources;\n  protected readonly contextDefault: IActionContext;\n  protected readonly emptyPatterns: Map<IDataSource, RDF.BaseQuad[]>;\n  protected readonly sourceIds: Map<IDataSource, string>;\n  protected readonly skipEmptyPatterns: boolean;\n  protected readonly algebraFactory: Factory;\n\n  public constructor(mediatorResolveQuadPattern: MediatorRdfResolveQuadPattern,\n    context: IActionContext, emptyPatterns: Map<IDataSource, RDF.Quad[]>,\n    skipEmptyPatterns: boolean) {\n    this.mediatorResolveQuadPattern = mediatorResolveQuadPattern;\n    this.sources = context.get(KeysRdfResolveQuadPattern.sources)!;\n    this.contextDefault = context.delete(KeysRdfResolveQuadPattern.sources);\n    this.emptyPatterns = emptyPatterns;\n    this.sourceIds = context.get(KeysRdfResolveQuadPattern.sourceIds) ?? new Map();\n    this.skipEmptyPatterns = skipEmptyPatterns;\n    this.algebraFactory = new Factory();\n\n    // Initialize sources in the emptyPatterns datastructure\n    if (this.skipEmptyPatterns) {\n      for (const source of this.sources) {\n        if (!this.emptyPatterns.has(source)) {\n          this.emptyPatterns.set(source, []);\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if the given RDF term is not bound to an exact value.\n   * I.e., if it is not a Variable.\n   * @param {RDF.Term} term An RDF term.\n   * @return {boolean} If it is not bound.\n   */\n  public static isTermBound(term: RDF.Term): boolean {\n    return term.termType !== 'Variable';\n  }\n\n  /**\n   * Checks if the given (child) pattern is a more bound version of the given (parent) pattern.\n   * This will also return true if the patterns are equal.\n   * @param {RDF.BaseQuad} child A child pattern.\n   * @param {RDF.BaseQuad} parent A parent pattern.\n   * @return {boolean} If child is a sub-pattern of parent\n   */\n  public static isSubPatternOf(child: RDF.BaseQuad, parent: RDF.BaseQuad): boolean {\n    return (!FederatedQuadSource.isTermBound(parent.subject) || parent.subject.equals(child.subject)) &&\n      (!FederatedQuadSource.isTermBound(parent.predicate) || parent.predicate.equals(child.predicate)) &&\n      (!FederatedQuadSource.isTermBound(parent.object) || parent.object.equals(child.object)) &&\n      (!FederatedQuadSource.isTermBound(parent.graph) || parent.graph.equals(child.graph));\n  }\n\n  /**\n   * If the given term is a blank node, return a deterministic named node for it\n   * based on the source id and the blank node value.\n   * @param term Any RDF term.\n   * @param sourceId A source identifier.\n   * @return If the given term was a blank node, this will return a skolemized named node, otherwise the original term.\n   */\n  public static skolemizeTerm(term: RDF.Term, sourceId: string): RDF.Term | BlankNodeScoped {\n    if (term.termType === 'BlankNode') {\n      return new BlankNodeScoped(`bc_${sourceId}_${term.value}`,\n        DF.namedNode(`${FederatedQuadSource.SKOLEM_PREFIX}${sourceId}:${term.value}`));\n    }\n    return term;\n  }\n\n  /**\n   * Skolemize all terms in the given quad.\n   * @param quad An RDF quad.\n   * @param sourceId A source identifier.\n   * @return The skolemized quad.\n   */\n  public static skolemizeQuad<Q extends RDF.BaseQuad = RDF.Quad>(quad: Q, sourceId: string): Q {\n    return mapTerms(quad, term => FederatedQuadSource.skolemizeTerm(term, sourceId));\n  }\n\n  /**\n   * If a given term was a skolemized named node for the given source id,\n   * deskolemize it again to a blank node.\n   * If the given term was a skolemized named node for another source, return false.\n   * If the given term was not a skolemized named node, return the original term.\n   * @param term Any RDF term.\n   * @param sourceId A source identifier.\n   */\n  public static deskolemizeTerm(term: RDF.Term, sourceId: string): RDF.Term | null {\n    if (term.termType === 'BlankNode' && 'skolemized' in term) {\n      term = (<BlankNodeScoped> term).skolemized;\n    }\n    if (term.termType === 'NamedNode' && term.value.startsWith(FederatedQuadSource.SKOLEM_PREFIX)) {\n      const colonSeparator = term.value.indexOf(':', FederatedQuadSource.SKOLEM_PREFIX.length);\n      const termSourceId = term.value.slice(FederatedQuadSource.SKOLEM_PREFIX.length, colonSeparator);\n      // We had a skolemized term\n      if (termSourceId === sourceId) {\n        // It came from the correct source\n        const termLabel = term.value.slice(colonSeparator + 1, term.value.length);\n        return DF.blankNode(termLabel);\n      }\n      // It came from a different source\n      return null;\n    }\n    return term;\n  }\n\n  /**\n   * Deskolemize all terms in the given quad.\n   * @param quad An RDF quad.\n   * @param sourceId A source identifier.\n   * @return The deskolemized quad.\n   */\n  public static deskolemizeQuad<Q extends RDF.BaseQuad = RDF.Quad>(quad: Q, sourceId: string): Q {\n    return mapTerms(quad, (term: RDF.Term): RDF.Term => {\n      const newTerm = FederatedQuadSource.deskolemizeTerm(term, sourceId);\n      // If the term was skolemized in a different source then dont deskolemize it\n      return !newTerm ? term : newTerm;\n    });\n  }\n\n  /**\n   * If the given source is guaranteed to produce an empty result for the given pattern.\n   *\n   * This prediction is done based on the 'emptyPatterns' datastructure that is stored within this actor.\n   * Every time an empty pattern is passed, this pattern is stored in this datastructure for this source.\n   * If this pattern (or a more bound pattern) is queried, we know for certain that it will be empty again.\n   * This is under the assumption that sources will remain static during query evaluation.\n   *\n   * @param {IQuerySource} source\n   * @param {RDF.BaseQuad} pattern\n   * @return {boolean}\n   */\n  public isSourceEmpty(source: IDataSource, pattern: RDF.BaseQuad): boolean {\n    if (!this.skipEmptyPatterns) {\n      return false;\n    }\n    const emptyPatterns: RDF.BaseQuad[] | undefined = this.emptyPatterns.get(source);\n    if (emptyPatterns) {\n      for (const emptyPattern of emptyPatterns) {\n        if (FederatedQuadSource.isSubPatternOf(pattern, emptyPattern)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get the unique, deterministic id for the given source.\n   * @param source A data source.\n   * @return The id of the given source.\n   */\n  public getSourceId(source: IDataSource): string {\n    let sourceId = this.sourceIds.get(source);\n    if (sourceId === undefined) {\n      sourceId = `${this.sourceIds.size}`;\n      this.sourceIds.set(source, sourceId);\n    }\n    return sourceId;\n  }\n\n  public match(subject: RDF.Term, predicate: RDF.Term, object: RDF.Term, graph: RDF.Term): AsyncIterator<RDF.Quad> {\n    // Counters for our metadata\n    const metadata: MetadataQuads = { cardinality: { type: 'exact', value: 0 }, canContainUndefs: false };\n    let remainingSources = this.sources.length;\n\n    // Anonymous function to handle cardinality from metadata\n    const checkEmitMetadata = (currentTotalItems: number, source: IDataSource,\n      pattern: RDF.BaseQuad | undefined, lastMetadata?: MetadataQuads): void => {\n      if (this.skipEmptyPatterns && !currentTotalItems && pattern && !this.isSourceEmpty(source, pattern)) {\n        this.emptyPatterns.get(source)!.push(pattern);\n      }\n      if (!remainingSources) {\n        if (lastMetadata && this.sources.length === 1) {\n          // If we only had one source, emit the metadata as-is.\n          it.setProperty('metadata', lastMetadata);\n        } else {\n          it.setProperty('metadata', metadata);\n        }\n      }\n    };\n\n    const proxyIt: Promise<AsyncIterator<RDF.Quad>[]> = Promise.all(this.sources.map(async source => {\n      const sourceId = this.getSourceId(source);\n\n      // Deskolemize terms, so we send the original blank nodes to each source.\n      // Note that some sources may not match bnodes by label. SPARQL endpoints for example consider them variables.\n      const patternS = FederatedQuadSource.deskolemizeTerm(subject, sourceId);\n      const patternP = FederatedQuadSource.deskolemizeTerm(predicate, sourceId);\n      const patternO = FederatedQuadSource.deskolemizeTerm(object, sourceId);\n      const patternG = FederatedQuadSource.deskolemizeTerm(graph, sourceId);\n      let pattern: Algebra.Pattern | undefined;\n\n      // Prepare the context for this specific source\n      let context: IActionContext = getDataSourceContext(source, this.contextDefault);\n\n      context = context.set(KeysRdfResolveQuadPattern.source, source);\n\n      let output: IActorRdfResolveQuadPatternOutput;\n      // If any of the deskolemized blank nodes originate from another source,\n      // or if we can predict that the given source will have no bindings for the given pattern,\n      // return an empty iterator.\n      if (!patternS || !patternP || !patternO || !patternG ||\n        // eslint-disable-next-line no-cond-assign\n        this.isSourceEmpty(source, pattern = this.algebraFactory\n          .createPattern(patternS, patternP, patternO, patternG))) {\n        output = { data: new ArrayIterator([], { autoStart: false }) };\n        output.data.setProperty('metadata', { cardinality: 0, canContainUndefs: false });\n      } else {\n        output = await this.mediatorResolveQuadPattern.mediate({ pattern, context });\n      }\n\n      // Handle the metadata from this source\n      output.data.getProperty('metadata', (subMetadata: MetadataQuads) => {\n        if (!subMetadata.cardinality || !Number.isFinite(subMetadata.cardinality.value)) {\n          // We're already at infinite, so ignore any later metadata\n          metadata.cardinality.type = 'estimate';\n          metadata.cardinality.value = Number.POSITIVE_INFINITY;\n          remainingSources = 0;\n        } else {\n          if (subMetadata.cardinality.type === 'estimate') {\n            metadata.cardinality.type = 'estimate';\n          }\n          metadata.cardinality.value += subMetadata.cardinality.value;\n          remainingSources--;\n        }\n        if (metadata.requestTime || subMetadata.requestTime) {\n          metadata.requestTime = metadata.requestTime || 0;\n          subMetadata.requestTime = subMetadata.requestTime || 0;\n          metadata.requestTime += subMetadata.requestTime;\n        }\n        if (metadata.pageSize || subMetadata.pageSize) {\n          metadata.pageSize = metadata.pageSize || 0;\n          subMetadata.pageSize = subMetadata.pageSize || 0;\n          metadata.pageSize += subMetadata.pageSize;\n        }\n        if (subMetadata.canContainUndefs) {\n          metadata.canContainUndefs = true;\n        }\n        checkEmitMetadata(metadata.cardinality.value, source, pattern, subMetadata);\n      });\n\n      // Determine the data stream from this source\n      const data = output.data.map(quad => FederatedQuadSource.skolemizeQuad(quad, sourceId));\n\n      // Forward errors to our final iterator\n      data.on('error', error => it.emit('error', error));\n\n      return data;\n    }));\n\n    // Take the union of all source streams\n    const it = new ClosableTransformIterator(async() => new UnionIterator(await proxyIt), {\n      autoStart: false,\n      onClose() {\n        // Destroy the sub-iterators\n        proxyIt.then(proxyItResolved => {\n          for (const subIt of proxyItResolved) {\n            subIt.destroy();\n          }\n        }, () => {\n          // Void errors\n        });\n      },\n    });\n\n    // If we have 0 sources, immediately emit metadata\n    if (this.sources.length === 0) {\n      it.setProperty('metadata', metadata);\n    }\n\n    return it;\n  }\n}\n"]}