{"version":3,"file":"ActorQueryOperationPathZeroOrMore.js","sourceRoot":"","sources":["ActorQueryOperationPathZeroOrMore.ts"],"names":[],"mappings":"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","sourcesContent":["import { ActorAbstractPath } from '@comunica/actor-abstract-path';\nimport { BindingsFactory } from '@comunica/bindings-factory';\nimport type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport { ActorQueryOperation } from '@comunica/bus-query-operation';\nimport type { Bindings, IQueryOperationResult, IActionContext } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { MultiTransformIterator, TransformIterator, EmptyIterator, BufferedIterator } from 'asynciterator';\nimport { termToString } from 'rdf-string';\nimport { Algebra } from 'sparqlalgebrajs';\n\nconst BF = new BindingsFactory();\n\n/**\n * A comunica Path ZeroOrMore Query Operation Actor.\n */\nexport class ActorQueryOperationPathZeroOrMore extends ActorAbstractPath {\n  public constructor(args: IActorQueryOperationTypedMediatedArgs) {\n    super(args, Algebra.types.ZERO_OR_MORE_PATH);\n  }\n\n  public async runOperation(operation: Algebra.Path, context: IActionContext): Promise<IQueryOperationResult> {\n    const distinct = await this.isPathArbitraryLengthDistinct(context, operation);\n    if (distinct.operation) {\n      return distinct.operation;\n    }\n\n    context = distinct.context;\n\n    const predicate = <Algebra.ZeroOrMorePath> operation.predicate;\n\n    const sVar = operation.subject.termType === 'Variable';\n    const oVar = operation.object.termType === 'Variable';\n\n    if (operation.subject.termType === 'Variable' && operation.object.termType === 'Variable') {\n      // Query ?s ?p ?o, to get all possible namedNodes in de the db\n      const predVar = this.generateVariable(operation);\n      const single = ActorAbstractPath.FACTORY\n        .createPattern(operation.subject, predVar, operation.object, operation.graph);\n      const results = ActorQueryOperation.getSafeBindings(\n        await this.mediatorQueryOperation.mediate({ context, operation: single }),\n      );\n      const subjectVar = operation.subject;\n      const objectVar = operation.object;\n\n      // Set with all namedNodes we have already started a predicate* search from\n      const entities: Set<string> = new Set();\n\n      const termHashes = {};\n\n      const bindingsStream: MultiTransformIterator<Bindings, Bindings> = new MultiTransformIterator(\n        results.bindingsStream,\n        {\n          multiTransform: (bindings: Bindings) => {\n            // Get the subject and object of the triples (?s ?p ?o) and extract graph if it was a variable\n            const subject: RDF.Term = bindings.get(subjectVar)!;\n            const object: RDF.Term = bindings.get(objectVar)!;\n            const graph: RDF.Term = operation.graph.termType === 'Variable' ?\n              bindings.get(operation.graph)! :\n              operation.graph;\n            // Make a hash of namedNode + graph to remember from where we already started a search\n            const subjectGraphHash = termToString(subject) + termToString(graph);\n            const objectGraphHash = termToString(object) + termToString(graph);\n            return new TransformIterator<Bindings>(\n              async() => {\n                // If no new namedNodes in this triple, return nothing\n                if (entities.has(subjectGraphHash) && entities.has(objectGraphHash)) {\n                  return new EmptyIterator();\n                }\n                // Set up an iterator to which getSubjectAndObjectBindingsPredicateStar will push solutions\n                const it = new BufferedIterator<Bindings>();\n                const counter = { count: 0 };\n                // If not started from this namedNode (subject in triple) in this graph, start a search\n                if (!entities.has(subjectGraphHash)) {\n                  entities.add(subjectGraphHash);\n                  await this.getSubjectAndObjectBindingsPredicateStar(\n                    subjectVar,\n                    objectVar,\n                    subject,\n                    subject,\n                    predicate.path,\n                    graph,\n                    context,\n                    termHashes,\n                    {},\n                    it,\n                    counter,\n                  );\n                }\n                // If not started from this namedNode (object in triple) in this graph, start a search\n                if (!entities.has(objectGraphHash)) {\n                  entities.add(objectGraphHash);\n                  await this.getSubjectAndObjectBindingsPredicateStar(\n                    subjectVar,\n                    objectVar,\n                    object,\n                    object,\n                    predicate.path,\n                    graph,\n                    context,\n                    termHashes,\n                    {},\n                    it,\n                    counter,\n                  );\n                }\n                return it.transform<Bindings>({\n                  transform(item, next, push) {\n                    // If the graph was a variable, fill in it's binding (we got it from the ?s ?p ?o binding)\n                    if (operation.graph.termType === 'Variable') {\n                      item = item.set(operation.graph, graph);\n                    }\n                    push(item);\n                    next();\n                  },\n                });\n              },\n            );\n          },\n        },\n      );\n      const variables: RDF.Variable[] = operation.graph.termType === 'Variable' ?\n        [ subjectVar, operation.object, operation.graph ] :\n        [ subjectVar, operation.object ];\n      return {\n        type: 'bindings',\n        bindingsStream,\n        metadata: async() => ({ ...await results.metadata(), variables }),\n      };\n    }\n    if (!sVar && !oVar) {\n      const variable = this.generateVariable();\n      const starEval = await this.getObjectsPredicateStarEval(\n        operation.subject,\n        predicate.path,\n        variable,\n        operation.graph,\n        context,\n        true,\n      );\n      const bindingsStream = starEval.bindingsStream.transform<Bindings>({\n        filter: item => operation.object.equals(item.get(variable)),\n        transform(item, next, push) {\n          // Return graph binding if graph was a variable, otherwise empty binding\n          const binding = operation.graph.termType === 'Variable' ?\n            BF.bindings([[ operation.graph, item.get(operation.graph)! ]]) :\n            BF.bindings();\n          push(binding);\n          next();\n        },\n      });\n      return {\n        type: 'bindings',\n        bindingsStream,\n        metadata: async() => ({\n          ...await starEval.metadata(),\n          variables: operation.graph.termType === 'Variable' ? [ operation.graph ] : [],\n        }),\n      };\n    }\n    // If (sVar || oVar)\n    const subject = sVar ? operation.object : operation.subject;\n    const value: RDF.Variable = <RDF.Variable> (sVar ? operation.subject : operation.object);\n    const pred = sVar ? ActorAbstractPath.FACTORY.createInv(predicate.path) : predicate.path;\n    const starEval = await this.getObjectsPredicateStarEval(\n      subject,\n      pred,\n      value,\n      operation.graph,\n      context,\n      true,\n    );\n    const variables: RDF.Variable[] = operation.graph.termType === 'Variable' ? [ value, operation.graph ] : [ value ];\n    return {\n      type: 'bindings',\n      bindingsStream: starEval.bindingsStream,\n      metadata: async() => ({ ...await starEval.metadata(), variables }),\n    };\n  }\n}\n"]}