{"version":3,"file":"ActorRdfJoinSelectivityVariableCounting.js","sourceRoot":"","sources":["ActorRdfJoinSelectivityVariableCounting.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActionRdfJoinSelectivity, IActorRdfJoinSelectivityOutput } from '@comunica/bus-rdf-join-selectivity';\nimport { ActorRdfJoinSelectivity } from '@comunica/bus-rdf-join-selectivity';\nimport type { IActorArgs } from '@comunica/core';\nimport type { IMediatorTypeAccuracy } from '@comunica/mediatortype-accuracy';\nimport { Algebra, Util } from 'sparqlalgebrajs';\n\n/**\n * A comunica Variable Counting RDF Join Selectivity Actor.\n * Based on the \"variable counting predicates\" heuristic from\n * \"SPARQL basic graph pattern optimization using selectivity estimation.\"\n */\nexport class ActorRdfJoinSelectivityVariableCounting extends ActorRdfJoinSelectivity {\n  // Calculated as sum of unbound join type costs times 2 (best-case)\n  public static MAX_PAIRWISE_COST = 41 * 2;\n\n  public constructor(\n    args: IActorArgs<IActionRdfJoinSelectivity, IMediatorTypeAccuracy, IActorRdfJoinSelectivityOutput>,\n  ) {\n    super(args);\n  }\n\n  public async test(action: IActionRdfJoinSelectivity): Promise<IMediatorTypeAccuracy> {\n    return { accuracy: 0.5 };\n  }\n\n  public static getPatternCost(pattern: Algebra.Pattern | Algebra.Path): number {\n    let cost = 1;\n    if (pattern.subject.termType === 'Variable') {\n      cost += 4;\n    }\n    if (pattern.predicate.termType === 'Variable' || pattern.type === Algebra.types.PATH) {\n      cost += 1;\n    }\n    if (pattern.object.termType === 'Variable') {\n      cost += 2;\n    }\n    if (pattern.graph.termType === 'Variable') {\n      cost += 1;\n    }\n    return cost / 9;\n  }\n\n  public static getJoinTypes(\n    operation1: Algebra.Pattern | Algebra.Path,\n    operation2: Algebra.Pattern | Algebra.Path,\n  ): JoinTypes[] {\n    const joinTypes: JoinTypes[] = [];\n\n    // Check operation1.subject\n    if (operation1.subject.termType === 'Variable') {\n      if (operation1.subject.equals(operation2.subject)) {\n        joinTypes.push(JoinTypes.unboundSS);\n      }\n      if (operation2.type === 'pattern' && operation1.subject.equals(operation2.predicate)) {\n        joinTypes.push(JoinTypes.unboundSP);\n      }\n      if (operation1.subject.equals(operation2.object)) {\n        joinTypes.push(JoinTypes.unboundSO);\n      }\n      if (operation1.subject.equals(operation2.graph)) {\n        joinTypes.push(JoinTypes.unboundSG);\n      }\n    } else {\n      if (operation1.subject.equals(operation2.subject)) {\n        joinTypes.push(JoinTypes.boundSS);\n      }\n      if (operation2.type === 'pattern' && operation1.subject.equals(operation2.predicate)) {\n        joinTypes.push(JoinTypes.boundSP);\n      }\n      if (operation1.subject.equals(operation2.object)) {\n        joinTypes.push(JoinTypes.boundSO);\n      }\n      if (operation1.subject.equals(operation2.graph)) {\n        joinTypes.push(JoinTypes.boundSG);\n      }\n    }\n\n    // Check operation1.predicate\n    if (operation1.type === 'pattern') {\n      if (operation1.predicate.termType === 'Variable') {\n        if (operation1.predicate.equals(operation2.subject)) {\n          joinTypes.push(JoinTypes.unboundPS);\n        }\n        if (operation2.type === 'pattern' && operation1.predicate.equals(operation2.predicate)) {\n          joinTypes.push(JoinTypes.unboundPP);\n        }\n        if (operation1.predicate.equals(operation2.object)) {\n          joinTypes.push(JoinTypes.unboundPO);\n        }\n        if (operation1.predicate.equals(operation2.graph)) {\n          joinTypes.push(JoinTypes.unboundPG);\n        }\n      } else {\n        if (operation1.predicate.equals(operation2.subject)) {\n          joinTypes.push(JoinTypes.boundPS);\n        }\n        if (operation2.type === 'pattern' && operation1.predicate.equals(operation2.predicate)) {\n          joinTypes.push(JoinTypes.boundPP);\n        }\n        if (operation1.predicate.equals(operation2.object)) {\n          joinTypes.push(JoinTypes.boundPO);\n        }\n        if (operation1.predicate.equals(operation2.graph)) {\n          joinTypes.push(JoinTypes.boundPG);\n        }\n      }\n    }\n\n    // Check operation1.object\n    if (operation1.object.termType === 'Variable') {\n      if (operation1.object.equals(operation2.subject)) {\n        joinTypes.push(JoinTypes.unboundOS);\n      }\n      if (operation2.type === 'pattern' && operation1.object.equals(operation2.predicate)) {\n        joinTypes.push(JoinTypes.unboundOP);\n      }\n      if (operation1.object.equals(operation2.object)) {\n        joinTypes.push(JoinTypes.unboundOO);\n      }\n      if (operation1.object.equals(operation2.graph)) {\n        joinTypes.push(JoinTypes.unboundOG);\n      }\n    } else {\n      if (operation1.object.equals(operation2.subject)) {\n        joinTypes.push(JoinTypes.boundOS);\n      }\n      if (operation2.type === 'pattern' && operation1.object.equals(operation2.predicate)) {\n        joinTypes.push(JoinTypes.boundOP);\n      }\n      if (operation1.object.equals(operation2.object)) {\n        joinTypes.push(JoinTypes.boundOO);\n      }\n      if (operation1.object.equals(operation2.graph)) {\n        joinTypes.push(JoinTypes.boundOG);\n      }\n    }\n\n    // Check operation1.graph\n    if (operation1.graph.termType === 'Variable') {\n      if (operation1.graph.equals(operation2.subject)) {\n        joinTypes.push(JoinTypes.unboundGS);\n      }\n      if (operation2.type === 'pattern' && operation1.graph.equals(operation2.predicate)) {\n        joinTypes.push(JoinTypes.unboundGP);\n      }\n      if (operation1.graph.equals(operation2.object)) {\n        joinTypes.push(JoinTypes.unboundGO);\n      }\n      if (operation1.graph.equals(operation2.graph)) {\n        joinTypes.push(JoinTypes.unboundGG);\n      }\n    } else {\n      if (operation1.graph.equals(operation2.subject)) {\n        joinTypes.push(JoinTypes.boundGS);\n      }\n      if (operation2.type === 'pattern' && operation1.graph.equals(operation2.predicate)) {\n        joinTypes.push(JoinTypes.boundGP);\n      }\n      if (operation1.graph.equals(operation2.object)) {\n        joinTypes.push(JoinTypes.boundGO);\n      }\n      if (operation1.graph.equals(operation2.graph)) {\n        joinTypes.push(JoinTypes.boundGG);\n      }\n    }\n\n    return joinTypes;\n  }\n\n  public static getOperationsPairwiseJoinCost(\n    operation1: Algebra.Pattern | Algebra.Path,\n    operation2: Algebra.Pattern | Algebra.Path,\n  ): number {\n    let cost = ActorRdfJoinSelectivityVariableCounting.MAX_PAIRWISE_COST;\n\n    for (const joinType of ActorRdfJoinSelectivityVariableCounting.getJoinTypes(operation1, operation2)) {\n      switch (joinType) {\n        case JoinTypes.boundSS:\n          cost -= 2 * 2;\n          break;\n        case JoinTypes.boundSP:\n          cost -= 3 * 2;\n          break;\n        case JoinTypes.boundSO:\n          cost -= 1 * 2;\n          break;\n        case JoinTypes.boundSG:\n          cost -= 3 * 2;\n          break;\n        case JoinTypes.boundPS:\n          cost -= 3 * 2;\n          break;\n        case JoinTypes.boundPP:\n          // Special case: patterns with equal (bound) predicates have the highest cost\n          return 1;\n        case JoinTypes.boundPO:\n          cost -= 3 * 2;\n          break;\n        case JoinTypes.boundPG:\n          cost -= 3 * 2;\n          break;\n        case JoinTypes.boundOS:\n          cost -= 1 * 2;\n          break;\n        case JoinTypes.boundOP:\n          cost -= 3 * 2;\n          break;\n        case JoinTypes.boundOO:\n          cost -= 1 * 2;\n          break;\n        case JoinTypes.boundOG:\n          cost -= 3 * 2;\n          break;\n        case JoinTypes.boundGS:\n          cost -= 3 * 2;\n          break;\n        case JoinTypes.boundGP:\n          cost -= 3 * 2;\n          break;\n        case JoinTypes.boundGO:\n          cost -= 3 * 2;\n          break;\n        case JoinTypes.boundGG:\n          cost -= 3 * 2;\n          break;\n        case JoinTypes.unboundSS:\n          cost -= 2;\n          break;\n        case JoinTypes.unboundSP:\n          cost -= 3;\n          break;\n        case JoinTypes.unboundSO:\n          cost -= 1;\n          break;\n        case JoinTypes.unboundSG:\n          cost -= 3;\n          break;\n        case JoinTypes.unboundPS:\n          cost -= 3;\n          break;\n        case JoinTypes.unboundPP:\n          cost -= 3;\n          break;\n        case JoinTypes.unboundPO:\n          cost -= 3;\n          break;\n        case JoinTypes.unboundPG:\n          cost -= 3;\n          break;\n        case JoinTypes.unboundOS:\n          cost -= 1;\n          break;\n        case JoinTypes.unboundOP:\n          cost -= 3;\n          break;\n        case JoinTypes.unboundOO:\n          cost -= 1;\n          break;\n        case JoinTypes.unboundOG:\n          cost -= 3;\n          break;\n        case JoinTypes.unboundGS:\n          cost -= 3;\n          break;\n        case JoinTypes.unboundGP:\n          cost -= 3;\n          break;\n        case JoinTypes.unboundGO:\n          cost -= 3;\n          break;\n        case JoinTypes.unboundGG:\n          cost -= 3;\n          break;\n      }\n    }\n\n    return cost / ActorRdfJoinSelectivityVariableCounting.MAX_PAIRWISE_COST;\n  }\n\n  public static getOperationsJoinCost(operations: Algebra.Operation[]): number {\n    // Determine all operations that select values (patterns and paths)\n    const patterns: (Algebra.Pattern | Algebra.Path)[] = [];\n    for (const operation of operations) {\n      Util.recurseOperation(operation, {\n        [Algebra.types.PATTERN](pattern: Algebra.Pattern): boolean {\n          patterns.push(pattern);\n          return false;\n        },\n        [Algebra.types.PATH](path: Algebra.Path): boolean {\n          patterns.push(path);\n          return false;\n        },\n      });\n    }\n\n    // Determine pairwise costs\n    let totalCost = 0;\n    let costEntries = 0;\n    for (const pattern1 of patterns) {\n      for (const pattern2 of patterns) {\n        if (pattern1 !== pattern2) {\n          totalCost += ActorRdfJoinSelectivityVariableCounting.getOperationsPairwiseJoinCost(pattern1, pattern2);\n          costEntries++;\n        }\n      }\n    }\n\n    // Combine all pairwise costs, and multiply with costs of each pattern separately\n    return totalCost / costEntries * patterns\n      .reduce((factor, pattern) => factor * ActorRdfJoinSelectivityVariableCounting.getPatternCost(pattern), 1);\n  }\n\n  public async run(action: IActionRdfJoinSelectivity): Promise<IActorRdfJoinSelectivityOutput> {\n    if (action.entries.length <= 1) {\n      return { selectivity: 1 };\n    }\n    return {\n      selectivity: ActorRdfJoinSelectivityVariableCounting\n        .getOperationsJoinCost(action.entries.map(entry => entry.operation)),\n    };\n  }\n}\n\nexport enum JoinTypes {\n  boundSS,\n  boundSP,\n  boundSO,\n  boundSG,\n  boundPS,\n  boundPP,\n  boundPO,\n  boundPG,\n  boundOS,\n  boundOP,\n  boundOO,\n  boundOG,\n  boundGS,\n  boundGP,\n  boundGO,\n  boundGG,\n\n  unboundSS,\n  unboundSP,\n  unboundSO,\n  unboundSG,\n  unboundPS,\n  unboundPP,\n  unboundPO,\n  unboundPG,\n  unboundOS,\n  unboundOP,\n  unboundOO,\n  unboundOG,\n  unboundGS,\n  unboundGP,\n  unboundGO,\n  unboundGG,\n}\n"]}