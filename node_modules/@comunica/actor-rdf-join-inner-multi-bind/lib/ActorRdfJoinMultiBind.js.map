{"version":3,"file":"ActorRdfJoinMultiBind.js","sourceRoot":"","sources":["ActorRdfJoinMultiBind.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MediatorQueryOperation } from '@comunica/bus-query-operation';\nimport { ActorQueryOperation, materializeOperation } from '@comunica/bus-query-operation';\nimport type {\n  IActionRdfJoin,\n  IActorRdfJoinOutputInner,\n  IActorRdfJoinArgs,\n} from '@comunica/bus-rdf-join';\nimport { ActorRdfJoin } from '@comunica/bus-rdf-join';\nimport type { MediatorRdfJoinEntriesSort } from '@comunica/bus-rdf-join-entries-sort';\nimport { KeysQueryOperation } from '@comunica/context-entries';\nimport type { IMediatorTypeJoinCoefficients } from '@comunica/mediatortype-join-coefficients';\nimport type { Bindings, BindingsStream, IQueryOperationResultBindings,\n  MetadataBindings, IActionContext, IJoinEntryWithMetadata } from '@comunica/types';\nimport { MultiTransformIterator, TransformIterator, UnionIterator } from 'asynciterator';\nimport { Factory, Algebra } from 'sparqlalgebrajs';\n\n/**\n * A comunica Multi-way Bind RDF Join Actor.\n */\nexport class ActorRdfJoinMultiBind extends ActorRdfJoin {\n  public readonly bindOrder: BindOrder;\n  public readonly selectivityModifier: number;\n  public readonly mediatorJoinEntriesSort: MediatorRdfJoinEntriesSort;\n  public readonly mediatorQueryOperation: MediatorQueryOperation;\n\n  public static readonly FACTORY = new Factory();\n\n  public constructor(args: IActorRdfJoinMultiBindArgs) {\n    super(args, {\n      logicalType: 'inner',\n      physicalName: 'bind',\n      canHandleUndefs: true,\n    });\n  }\n\n  /**\n   * Create a new bindings stream that takes every binding of the base stream\n   * and binds it to the remaining patterns, evaluates those patterns, and emits all their bindings.\n   *\n   * @param bindOrder The order in which elements should be bound.\n   * @param baseStream The base stream.\n   * @param operations The operations to bind with each binding of the base stream.\n   * @param operationBinder A callback to retrieve the bindings stream of bound operations.\n   * @param optional If the original bindings should be emitted when the resulting bindings stream is empty.\n   * @return {BindingsStream}\n   */\n  public static createBindStream(\n    bindOrder: BindOrder,\n    baseStream: BindingsStream,\n    operations: Algebra.Operation[],\n    operationBinder: (boundOperations: Algebra.Operation[], operationBindings: Bindings)\n    => Promise<BindingsStream>,\n    optional: boolean,\n  ): BindingsStream {\n    // Create bindings function\n    const binder = (bindings: Bindings): BindingsStream => {\n      // We don't bind the filter because filters are always handled last,\n      // and we need to avoid binding filters of sub-queries, which are to be handled first. (see spec test bind10)\n      const subOperations = operations\n        .map(operation => materializeOperation(operation, bindings, { bindFilter: false }));\n      const bindingsMerger = (subBindings: Bindings): Bindings | undefined => subBindings.merge(bindings);\n      return new TransformIterator(async() => (await operationBinder(subOperations, bindings))\n        .transform({ map: bindingsMerger }), { maxBufferSize: 128, autoStart: false });\n    };\n\n    // Create an iterator that binds elements from the base stream in different orders\n    switch (bindOrder) {\n      case 'depth-first':\n        return new MultiTransformIterator(baseStream, { autoStart: false, multiTransform: binder, optional });\n      case 'breadth-first':\n        return new UnionIterator(baseStream.transform({\n          map: binder,\n          optional,\n        }), { autoStart: false });\n      default:\n        throw new Error(`Received request for unknown bind order: ${bindOrder}`);\n    }\n  }\n\n  /**\n   * Order the given join entries using the join-entries-sort bus.\n   * @param {IJoinEntryWithMetadata[]} entries An array of join entries.\n   * @param context The action context.\n   * @return {IJoinEntryWithMetadata[]} The sorted join entries.\n   */\n  public async sortJoinEntries(\n    entries: IJoinEntryWithMetadata[],\n    context: IActionContext,\n  ): Promise<IJoinEntryWithMetadata[]> {\n    // If there is a stream that can contain undefs, we don't modify the join order.\n    const canContainUndefs = entries.some(entry => entry.metadata.canContainUndefs);\n    if (canContainUndefs) {\n      return entries;\n    }\n\n    // Calculate number of occurrences of each variable\n    const variableOccurrences: Record<string, number> = {};\n    for (const entry of entries) {\n      for (const variable of entry.metadata.variables) {\n        let counter = variableOccurrences[variable.value];\n        if (!counter) {\n          counter = 0;\n        }\n        variableOccurrences[variable.value] = ++counter;\n      }\n    }\n\n    // Determine variables that occur in at least two join entries\n    const multiOccurrenceVariables: string[] = [];\n    for (const [ variable, count ] of Object.entries(variableOccurrences)) {\n      if (count >= 2) {\n        multiOccurrenceVariables.push(variable);\n      }\n    }\n\n    // Reject if no entries have common variables\n    if (multiOccurrenceVariables.length === 0) {\n      throw new Error(`Bind join can only join entries with at least one common variable`);\n    }\n\n    // Determine entries without common variables\n    // These will be placed in the back of the sorted array\n    const entriesWithoutCommonVariables: IJoinEntryWithMetadata[] = [];\n    for (const entry of entries) {\n      let hasCommon = false;\n      for (const variable of entry.metadata.variables) {\n        if (multiOccurrenceVariables.includes(variable.value)) {\n          hasCommon = true;\n          break;\n        }\n      }\n      if (!hasCommon) {\n        entriesWithoutCommonVariables.push(entry);\n      }\n    }\n\n    return (await this.mediatorJoinEntriesSort.mediate({ entries, context })).entries\n      .sort((entryLeft, entryRight) => {\n        // Sort to make sure that entries without common variables come last in the array.\n        // For all other entries, the original order is kept.\n        const leftWithoutCommonVariables = entriesWithoutCommonVariables.includes(entryLeft);\n        const rightWithoutCommonVariables = entriesWithoutCommonVariables.includes(entryRight);\n        if (leftWithoutCommonVariables === rightWithoutCommonVariables) {\n          return 0;\n        }\n        return leftWithoutCommonVariables ?\n          1 :\n          -1;\n      });\n  }\n\n  public async getOutput(action: IActionRdfJoin): Promise<IActorRdfJoinOutputInner> {\n    // Order the entries so we can pick the first one (usually the one with the lowest cardinality)\n    const entriesUnsorted = await ActorRdfJoin.getEntriesWithMetadatas(action.entries);\n    const entries = await this.sortJoinEntries(entriesUnsorted, action.context);\n\n    this.logDebug(action.context,\n      'First entry for Bind Join: ',\n      () => ({ entry: entries[0].operation, metadata: entries[0].metadata }));\n\n    // Close the non-smallest streams\n    for (const [ i, element ] of entries.entries()) {\n      if (i !== 0) {\n        element.output.bindingsStream.close();\n      }\n    }\n\n    // Take the stream with the lowest cardinality\n    const smallestStream: IQueryOperationResultBindings = entries[0].output;\n    const remainingEntries = [ ...entries ];\n    remainingEntries.splice(0, 1);\n\n    // Bind the remaining patterns for each binding in the stream\n    const subContext = action.context\n      .set(KeysQueryOperation.joinLeftMetadata, entries[0].metadata)\n      .set(KeysQueryOperation.joinRightMetadatas, remainingEntries.map(entry => entry.metadata));\n    const bindingsStream: BindingsStream = ActorRdfJoinMultiBind.createBindStream(\n      this.bindOrder,\n      smallestStream.bindingsStream,\n      remainingEntries.map(entry => entry.operation),\n      async(operations: Algebra.Operation[], operationBindings: Bindings) => {\n        // Send the materialized patterns to the mediator for recursive join evaluation.\n        const operation = operations.length === 1 ?\n          operations[0] :\n          ActorRdfJoinMultiBind.FACTORY.createJoin(operations);\n        const output = ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate(\n          { operation, context: subContext?.set(KeysQueryOperation.joinBindings, operationBindings) },\n        ));\n        return output.bindingsStream;\n      },\n      false,\n    );\n\n    return {\n      result: {\n        type: 'bindings',\n        bindingsStream,\n        metadata: () => this.constructResultMetadata(entries, entries.map(entry => entry.metadata), action.context),\n      },\n      physicalPlanMetadata: {\n        bindIndex: entriesUnsorted.indexOf(entries[0]),\n        bindOrder: this.bindOrder,\n      },\n    };\n  }\n\n  public async getJoinCoefficients(\n    action: IActionRdfJoin,\n    metadatas: MetadataBindings[],\n  ): Promise<IMediatorTypeJoinCoefficients> {\n    // Order the entries so we can pick the first one (usually the one with the lowest cardinality)\n    const entries = await this.sortJoinEntries(action.entries\n      .map((entry, i) => ({ ...entry, metadata: metadatas[i] })), action.context);\n    metadatas = entries.map(entry => entry.metadata);\n\n    const requestInitialTimes = ActorRdfJoin.getRequestInitialTimes(metadatas);\n    const requestItemTimes = ActorRdfJoin.getRequestItemTimes(metadatas);\n\n    // Determine first stream and remaining ones\n    const remainingEntries = [ ...entries ];\n    const remainingRequestInitialTimes = [ ...requestInitialTimes ];\n    const remainingRequestItemTimes = [ ...requestItemTimes ];\n    remainingEntries.splice(0, 1);\n    remainingRequestInitialTimes.splice(0, 1);\n    remainingRequestItemTimes.splice(0, 1);\n\n    // Reject binding on some operation types\n    if (remainingEntries\n      .some(entry => entry.operation.type === Algebra.types.EXTEND || entry.operation.type === Algebra.types.GROUP)) {\n      throw new Error(`Actor ${this.name} can not bind on Extend and Group operations`);\n    }\n\n    // Determine selectivities of smallest entry with all other entries\n    const selectivities = await Promise.all(remainingEntries\n      .map(async entry => (await this.mediatorJoinSelectivity.mediate({\n        entries: [ entries[0], entry ],\n        context: action.context,\n      })).selectivity * this.selectivityModifier));\n\n    // Determine coefficients for remaining entries\n    const cardinalityRemaining = remainingEntries\n      .map((entry, i) => entry.metadata.cardinality.value * selectivities[i])\n      .reduce((sum, element) => sum + element, 0);\n    const receiveInitialCostRemaining = remainingRequestInitialTimes\n      .reduce((sum, element, i) => sum + (element * selectivities[i]), 0);\n    const receiveItemCostRemaining = remainingRequestItemTimes\n      .reduce((sum, element, i) => sum + (element * selectivities[i]), 0);\n\n    return {\n      iterations: metadatas[0].cardinality.value * cardinalityRemaining,\n      persistedItems: 0,\n      blockingItems: 0,\n      requestTime: requestInitialTimes[0] +\n        metadatas[0].cardinality.value * (\n          requestItemTimes[0] +\n          receiveInitialCostRemaining +\n          cardinalityRemaining * receiveItemCostRemaining\n        ),\n    };\n  }\n}\n\nexport interface IActorRdfJoinMultiBindArgs extends IActorRdfJoinArgs {\n  /**\n   * The order in which elements should be bound\n   * @default {depth-first}\n   */\n  bindOrder: BindOrder;\n  /**\n   * Multiplier for selectivity values\n   * @range {double}\n   * @default {0.0001}\n   */\n  selectivityModifier: number;\n  /**\n   * The join entries sort mediator\n   */\n  mediatorJoinEntriesSort: MediatorRdfJoinEntriesSort;\n  /**\n   * The query operation mediator\n   */\n  mediatorQueryOperation: MediatorQueryOperation;\n}\n\nexport type BindOrder = 'depth-first' | 'breadth-first';\n"]}