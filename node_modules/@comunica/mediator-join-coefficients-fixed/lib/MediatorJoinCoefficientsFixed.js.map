{"version":3,"file":"MediatorJoinCoefficientsFixed.js","sourceRoot":"","sources":["MediatorJoinCoefficientsFixed.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ActorRdfJoin, IActionRdfJoin } from '@comunica/bus-rdf-join';\nimport { KeysQueryOperation } from '@comunica/context-entries';\nimport type { IActorReply, IMediatorArgs } from '@comunica/core';\nimport { Actor, Mediator } from '@comunica/core';\nimport type { IMediatorTypeJoinCoefficients } from '@comunica/mediatortype-join-coefficients';\nimport type { IQueryOperationResult } from '@comunica/types';\n\n/**\n * A mediator that mediates over actors implementing the Join Coefficients mediator type and assigns fixed weights\n * to calculate an overall score and pick the actor with the lowest score.\n */\nexport class MediatorJoinCoefficientsFixed\n  extends Mediator<ActorRdfJoin, IActionRdfJoin, IMediatorTypeJoinCoefficients, IQueryOperationResult> {\n  public readonly cpuWeight: number;\n  public readonly memoryWeight: number;\n  public readonly timeWeight: number;\n  public readonly ioWeight: number;\n\n  public constructor(args: IMediatorJoinCoefficientsFixedArgs) {\n    super(args);\n  }\n\n  protected async mediateWith(\n    action: IActionRdfJoin,\n    testResults: IActorReply<ActorRdfJoin, IActionRdfJoin, IMediatorTypeJoinCoefficients, IQueryOperationResult>[],\n  ): Promise<ActorRdfJoin> {\n    // Obtain test results\n    const errors: Error[] = [];\n    const promises = testResults\n      .map(({ reply }) => reply)\n      .map(promise => promise.catch(error => {\n        errors.push(error);\n      }));\n    const coefficients = await Promise.all(promises);\n\n    // Calculate costs\n    let costs: (number | undefined)[] = coefficients\n      // eslint-disable-next-line array-callback-return\n      .map((coeff, i) => {\n        if (coeff) {\n          return coeff.iterations * this.cpuWeight +\n            coeff.persistedItems * this.memoryWeight +\n            coeff.blockingItems * this.timeWeight +\n            coeff.requestTime * this.ioWeight;\n        }\n      });\n    const maxCost = Math.max(...(<number[]> costs.filter(cost => cost !== undefined)));\n\n    // If we have a limit indicator in the context,\n    // increase cost of entries that have a number of iterations that is higher than the limit AND persist items.\n    // In these cases, join operators that produce results early on will be preferred.\n    const limitIndicator: number | undefined = action.context.get(KeysQueryOperation.limitIndicator);\n    if (limitIndicator) {\n      costs = costs.map((cost, i) => {\n        if (cost !== undefined && coefficients[i]!.persistedItems > 0 && coefficients[i]!.iterations > limitIndicator) {\n          return cost + maxCost;\n        }\n        return cost;\n      });\n    }\n\n    // Determine index with lowest cost\n    let minIndex = -1;\n    let minValue = Number.POSITIVE_INFINITY;\n    for (const [ i, cost ] of costs.entries()) {\n      if (cost !== undefined && (minIndex === -1 || cost < minValue)) {\n        minIndex = i;\n        minValue = cost;\n      }\n    }\n\n    // Reject if all actors rejected\n    if (minIndex < 0) {\n      throw new Error(`All actors rejected their test in ${this.name}\\n${\n        errors.map(error => error.message).join('\\n')}`);\n    }\n\n    // Return actor with lowest cost\n    const bestActor = testResults[minIndex].actor;\n\n    // Emit calculations in logger\n    if (bestActor.includeInLogs) {\n      Actor.getContextLogger(action.context)?.debug(`Determined physical join operator '${bestActor.logicalType}-${bestActor.physicalName}'`, {\n        entries: action.entries.length,\n        variables: await Promise.all(action.entries\n          .map(async entry => (await entry.output.metadata()).variables.map(variable => variable.value))),\n        costs: Object.fromEntries(costs.map((coeff, i) => [\n          `${testResults[i].actor.logicalType}-${testResults[i].actor.physicalName}`,\n          coeff,\n        ])),\n        coefficients: Object.fromEntries(coefficients.map((coeff, i) => [\n          `${testResults[i].actor.logicalType}-${testResults[i].actor.physicalName}`,\n          coeff,\n        ])),\n      });\n    }\n\n    return bestActor;\n  }\n}\n\nexport interface IMediatorJoinCoefficientsFixedArgs\n  extends IMediatorArgs<ActorRdfJoin, IActionRdfJoin, IMediatorTypeJoinCoefficients, IQueryOperationResult> {\n  /**\n   * Weight for the CPU cost\n   */\n  cpuWeight: number;\n  /**\n   * Weight for the memory cost\n   */\n  memoryWeight: number;\n  /**\n   * Weight for the execution time cost\n   */\n  timeWeight: number;\n  /**\n   * Weight for the I/O cost\n   */\n  ioWeight: number;\n}\n"]}