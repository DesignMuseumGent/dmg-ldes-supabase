{"version":3,"file":"ActorRdfMetadataExtractHydraControls.js","sourceRoot":"","sources":["ActorRdfMetadataExtractHydraControls.ts"],"names":[],"mappings":";;;AAEA,iFAA6E;AAI7E,6CAAwD;AAExD;;GAEG;AACH,MAAa,oCAAqC,SAAQ,kDAAuB;IAK/E,YAAmB,IAAkC;QACnD,KAAK,CAAC,IAAI,CAAC,CAAC;QAHK,2BAAsB,GAAgC,EAAE,CAAC;IAI5E,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,MAAiC;QACjD,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;OAKG;IACI,QAAQ,CAAC,OAAe,EAAE,eAAyD;QAExF,OAAO,MAAM,CAAC,WAAW,CAAC,oCAAoC,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;YACnF,yEAAyE;YACzE,MAAM,KAAK,GAAG,eAAe,CAAC,IAAI,CAAC,IAAI,eAAe,CAAC,GAAG,IAAI,MAAM,CAAC,CAAC;YACtE,MAAM,WAAW,GAAG,KAAK,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC;YAC5C,OAAO,CAAE,IAAI,EAAE,WAAW,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAE,CAAC;QACjF,CAAC,CAAC,CAAC,CAAC;IACN,CAAC;IAED;;;;OAIG;IACI,sBAAsB,CAAC,QAAgB;QAC5C,MAAM,iBAAiB,GAAgB,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,CAAC;QAC7E,IAAI,iBAAiB,EAAE;YACrB,OAAO,iBAAiB,CAAC;SAC1B;QACD,4CAA4C;QAC5C,OAAO,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,GAAG,IAAA,mBAAgB,EAAC,QAAQ,CAAC,CAAC;IAC5E,CAAC;IAED;;;;OAIG;IACI,cAAc,CAAC,eAAyD;QAC7E,MAAM,cAAc,GAA6B,eAAe,CAAC,MAAM,CAAC;QACxE,MAAM,WAAW,GAAkB,EAAE,CAAC;QACtC,IAAI,cAAc,EAAE;YAClB,KAAK,MAAM,OAAO,IAAI,cAAc,EAAE;gBACpC,KAAK,MAAM,YAAY,IAAI,cAAc,CAAC,OAAO,CAAC,EAAE;oBAClD,MAAM,eAAe,GAAG,CAAC,eAAe,CAAC,QAAQ,IAAI,EAAE,CAAC,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC;oBAE7E,qBAAqB;oBACrB,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE;wBAChC,MAAM,IAAI,KAAK,CAAC,iCAAiC,YAAY,EAAE,CAAC,CAAC;qBAClE;oBACD,MAAM,QAAQ,GAAW,eAAe,CAAC,CAAC,CAAC,CAAC;oBAC5C,MAAM,cAAc,GAAgB,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,CAAC;oBAE1E,8BAA8B;oBAC9B,MAAM,QAAQ,GAA2B,MAAM;yBAC5C,WAAW,CAAC,CAAC,CAAC,eAAe,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC;yBAC/D,GAAG,CAAC,OAAO,CAAC,EAAE;wBACb,MAAM,QAAQ,GAAG,CAAC,CAAC,eAAe,CAAC,QAAQ,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;wBACtE,MAAM,QAAQ,GAAG,CAAC,CAAC,eAAe,CAAC,QAAQ,IAAI,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;wBACtE,IAAI,CAAC,QAAQ,EAAE;4BACb,MAAM,IAAI,KAAK,CAAC,iCAAiC,OAAO,EAAE,CAAC,CAAC;yBAC7D;wBACD,IAAI,CAAC,QAAQ,EAAE;4BACb,MAAM,IAAI,KAAK,CAAC,iCAAiC,OAAO,EAAE,CAAC,CAAC;yBAC7D;wBACD,OAAO,CAAE,QAAQ,EAAE,QAAQ,CAAE,CAAC;oBAChC,CAAC,CAAC,CAAC,CAAC;oBAER,4EAA4E;oBAC5E,MAAM,MAAM,GAAG,CAAC,OAA+B,EAAU,EAAE,CAAC,cAAc;yBACvE,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,CAAE,QAAQ,CAAC,GAAG,CAAC,EAAE,OAAO,CAAC,GAAG,CAAC,CAAE,CAAC,CAAC,CAAC,CAAC;oBAEhG,WAAW,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC;iBAC3D;aACF;SACF;QACD,OAAO,EAAE,MAAM,EAAE,WAAW,EAAE,CAAC;IACjC,CAAC;IAED;;;;;OAKG;IACI,kBAAkB,CAAC,QAAoB;QAC5C,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,QAAQ,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;YAE7B,gGAAgG;YAChG,MAAM,eAAe,GAA6C,EAAE,CAAC;YACrE,QAAQ,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE;gBACzB,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,UAAU,CAAC,oCAAoC,CAAC,KAAK,CAAC,EAAE;oBAC/E,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC,oCAAoC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;oBAC/F,MAAM,iBAAiB,GAAG,eAAe,CAAC,QAAQ,CAAC,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAC;oBACxF,MAAM,OAAO,GAAG,iBAAiB,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC;oBACtG,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;iBACjC;YACH,CAAC,CAAC,CAAC;YAEH,QAAQ,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC,CAAC;QACrD,CAAC,CAAC,CAAC;IACL,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,MAAiC;QAChD,MAAM,QAAQ,GAA+C,EAAE,CAAC;QAChE,MAAM,eAAe,GAAG,MAAM,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QACvE,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,EAAE,eAAe,CAAC,CAAC,CAAC;QACpE,QAAQ,CAAC,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC;QAC5D,OAAO,EAAE,QAAQ,EAAE,CAAC;IACtB,CAAC;;AAxHH,oFAyHC;AAxHwB,0CAAK,GAAW,kCAAkC,CAAC;AACnD,+CAAU,GAAa,CAAE,OAAO,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,CAAE,CAAC","sourcesContent":["import type { IActionRdfMetadataExtract,\n  IActorRdfMetadataExtractOutput, IActorRdfMetadataExtractArgs } from '@comunica/bus-rdf-metadata-extract';\nimport { ActorRdfMetadataExtract } from '@comunica/bus-rdf-metadata-extract';\nimport type { IActorTest } from '@comunica/core';\nimport type * as RDF from '@rdfjs/types';\nimport type { UriTemplate } from 'uritemplate';\nimport { parse as parseUriTemplate } from 'uritemplate';\n\n/**\n * An RDF Metadata Extract Actor that extracts all Hydra controls from the metadata stream.\n */\nexport class ActorRdfMetadataExtractHydraControls extends ActorRdfMetadataExtract {\n  public static readonly HYDRA: string = 'http://www.w3.org/ns/hydra/core#';\n  public static readonly LINK_TYPES: string[] = [ 'first', 'next', 'previous', 'last' ];\n  protected readonly parsedUriTemplateCache: Record<string, UriTemplate> = {};\n\n  public constructor(args: IActorRdfMetadataExtractArgs) {\n    super(args);\n  }\n\n  public async test(action: IActionRdfMetadataExtract): Promise<IActorTest> {\n    return true;\n  }\n\n  /**\n   * Collect all Hydra page links from the given Hydra properties object.\n   * @param pageUrl The page URL in which the Hydra properties are defined.\n   * @param hydraProperties The collected Hydra properties.\n   * @return The Hydra links\n   */\n  public getLinks(pageUrl: string, hydraProperties: Record<string, Record<string, string[]>>):\n  Record<string, any> {\n    return Object.fromEntries(ActorRdfMetadataExtractHydraControls.LINK_TYPES.map(link => {\n      // First check the correct hydra:next, then the deprecated hydra:nextPage\n      const links = hydraProperties[link] || hydraProperties[`${link}Page`];\n      const linkTargets = links && links[pageUrl];\n      return [ link, linkTargets && linkTargets.length > 0 ? linkTargets[0] : null ];\n    }));\n  }\n\n  /**\n   * Parse a URI template, or retrieve it from a cache.\n   * @param {string} template A URI template string.\n   * @return {} A parsed URI template object.\n   */\n  public parseUriTemplateCached(template: string): UriTemplate {\n    const cachedUriTemplate: UriTemplate = this.parsedUriTemplateCache[template];\n    if (cachedUriTemplate) {\n      return cachedUriTemplate;\n    }\n    // eslint-disable-next-line no-return-assign\n    return this.parsedUriTemplateCache[template] = parseUriTemplate(template);\n  }\n\n  /**\n   * Collect all search forms from the given Hydra properties object.\n   * @param hydraProperties The collected Hydra properties.\n   * @return The search forms.\n   */\n  public getSearchForms(hydraProperties: Record<string, Record<string, string[]>>): ISearchForms {\n    const searchFormData: Record<string, string[]> = hydraProperties.search;\n    const searchForms: ISearchForm[] = [];\n    if (searchFormData) {\n      for (const dataset in searchFormData) {\n        for (const searchFormId of searchFormData[dataset]) {\n          const searchTemplates = (hydraProperties.template || {})[searchFormId] || [];\n\n          // Parse the template\n          if (searchTemplates.length !== 1) {\n            throw new Error(`Expected 1 hydra:template for ${searchFormId}`);\n          }\n          const template: string = searchTemplates[0];\n          const searchTemplate: UriTemplate = this.parseUriTemplateCached(template);\n\n          // Parse the template mappings\n          const mappings: Record<string, string> = Object\n            .fromEntries(((hydraProperties.mapping || {})[searchFormId] || [])\n              .map(mapping => {\n                const variable = ((hydraProperties.variable || {})[mapping] || [])[0];\n                const property = ((hydraProperties.property || {})[mapping] || [])[0];\n                if (!variable) {\n                  throw new Error(`Expected a hydra:variable for ${mapping}`);\n                }\n                if (!property) {\n                  throw new Error(`Expected a hydra:property for ${mapping}`);\n                }\n                return [ property, variable ];\n              }));\n\n          // Gets the URL of the Triple Pattern Fragment with the given triple pattern\n          const getUri = (entries: Record<string, string>): string => searchTemplate\n            .expand(Object.fromEntries(Object.keys(entries).map(key => [ mappings[key], entries[key] ])));\n\n          searchForms.push({ dataset, template, mappings, getUri });\n        }\n      }\n    }\n    return { values: searchForms };\n  }\n\n  /**\n   * Collect all hydra properties from a given metadata stream\n   * in a nice convenient nested hash (property / subject / objects).\n   * @param {RDF.Stream} metadata\n   * @return The collected Hydra properties.\n   */\n  public getHydraProperties(metadata: RDF.Stream): Promise<Record<string, Record<string, string[]>>> {\n    return new Promise((resolve, reject) => {\n      metadata.on('error', reject);\n\n      // Collect all hydra properties in a nice convenient nested hash (property / subject / objects).\n      const hydraProperties: Record<string, Record<string, string[]>> = {};\n      metadata.on('data', quad => {\n        if (quad.predicate.value.startsWith(ActorRdfMetadataExtractHydraControls.HYDRA)) {\n          const property = quad.predicate.value.slice(ActorRdfMetadataExtractHydraControls.HYDRA.length);\n          const subjectProperties = hydraProperties[property] || (hydraProperties[property] = {});\n          const objects = subjectProperties[quad.subject.value] || (subjectProperties[quad.subject.value] = []);\n          objects.push(quad.object.value);\n        }\n      });\n\n      metadata.on('end', () => resolve(hydraProperties));\n    });\n  }\n\n  public async run(action: IActionRdfMetadataExtract): Promise<IActorRdfMetadataExtractOutput> {\n    const metadata: IActorRdfMetadataExtractOutput['metadata'] = {};\n    const hydraProperties = await this.getHydraProperties(action.metadata);\n    Object.assign(metadata, this.getLinks(action.url, hydraProperties));\n    metadata.searchForms = this.getSearchForms(hydraProperties);\n    return { metadata };\n  }\n}\n\nexport interface ISearchForm {\n  /**\n   * The dataset in which the search form is defined.\n   */\n  dataset: string;\n  /**\n   * The URI template containing Hydra variables.\n   */\n  template: string;\n  /**\n   * The mappings.\n   * With as keys the Hydra properties,\n   * and as values the Hydra variables\n   */\n  mappings: Record<string, string>;\n\n  /**\n   * Instantiate a uri based on the given Hydra variable values.\n   * @param entries Entries with as keys Hydra properties,\n   *                and as values Hydra variable values.\n   * @return {string} The instantiated URI\n   */\n  getUri: (entries: Record<string, string>) => string;\n}\n\nexport interface ISearchForms {\n  /**\n   * All available search forms.\n   */\n  values: ISearchForm[];\n}\n"]}