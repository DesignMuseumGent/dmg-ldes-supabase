{"version":3,"file":"ActorQueryOperationSlice.js","sourceRoot":"","sources":["ActorQueryOperationSlice.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperationTypedMediated,\n} from '@comunica/bus-query-operation';\nimport { KeysQueryOperation } from '@comunica/context-entries';\nimport type { IActorTest } from '@comunica/core';\nimport type {\n  IQueryOperationResult,\n  IQueryOperationResultBindings,\n  IQueryOperationResultQuads,\n  IQueryOperationResultStream, IMetadata, IActionContext,\n} from '@comunica/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport type { Algebra } from 'sparqlalgebrajs';\n\n/**\n * A comunica Slice Query Operation Actor.\n */\nexport class ActorQueryOperationSlice extends ActorQueryOperationTypedMediated<Algebra.Slice> {\n  public constructor(args: IActorQueryOperationTypedMediatedArgs) {\n    super(args, 'slice');\n  }\n\n  public async testOperation(operation: Algebra.Slice, context: IActionContext): Promise<IActorTest> {\n    return true;\n  }\n\n  public async runOperation(operation: Algebra.Slice, context: IActionContext):\n  Promise<IQueryOperationResult> {\n    // Add limit indicator to the context, which can be used for query planning\n    // eslint-disable-next-line unicorn/explicit-length-check\n    if (operation.length) {\n      context = context.set(KeysQueryOperation.limitIndicator, operation.length);\n    }\n\n    // Resolve the input\n    const output: IQueryOperationResult = await this.mediatorQueryOperation\n      .mediate({ operation: operation.input, context });\n\n    if (output.type === 'bindings') {\n      const bindingsStream = this.sliceStream(output.bindingsStream, operation);\n      return <IQueryOperationResultBindings> {\n        type: 'bindings',\n        bindingsStream,\n        metadata: this.sliceMetadata(output, operation),\n      };\n    }\n\n    if (output.type === 'quads') {\n      const quadStream = this.sliceStream(output.quadStream, operation);\n      return <IQueryOperationResultQuads> {\n        type: 'quads',\n        quadStream,\n        metadata: this.sliceMetadata(output, operation),\n      };\n    }\n\n    throw new Error(`Invalid query output type: Expected 'bindings' or 'quads' but got '${output.type}'`);\n  }\n\n  // Slice the stream based on the pattern values\n  private sliceStream(stream: AsyncIterator<any>, pattern: Algebra.Slice): AsyncIterator<any> {\n    // eslint-disable-next-line unicorn/explicit-length-check\n    const hasLength: boolean = Boolean(pattern.length) || pattern.length === 0;\n    const { start } = pattern;\n    const end = hasLength ? pattern.start + pattern.length! - 1 : Number.POSITIVE_INFINITY;\n    return stream.transform({ offset: start, limit: Math.max(end - start + 1, 0), autoStart: false });\n  }\n\n  // If we find metadata, apply slicing on the total number of items\n  private sliceMetadata(\n    output: IQueryOperationResultStream<any, any>,\n    pattern: Algebra.Slice,\n  ): () => Promise<IMetadata<any>> {\n    // eslint-disable-next-line unicorn/explicit-length-check\n    const hasLength: boolean = Boolean(pattern.length) || pattern.length === 0;\n    return () => (<() => Promise<IMetadata<any>>>output.metadata)()\n      .then(subMetadata => {\n        const cardinality = { ...subMetadata.cardinality };\n        if (Number.isFinite(cardinality.value)) {\n          cardinality.value = Math.max(0, cardinality.value - pattern.start);\n          if (hasLength) {\n            cardinality.value = Math.min(cardinality.value, pattern.length!);\n          }\n        }\n        return { ...subMetadata, cardinality };\n      });\n  }\n}\n"]}