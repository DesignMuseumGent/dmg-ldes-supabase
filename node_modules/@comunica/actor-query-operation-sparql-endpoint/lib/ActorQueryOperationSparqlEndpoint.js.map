{"version":3,"file":"ActorQueryOperationSparqlEndpoint.js","sourceRoot":"","sources":["ActorQueryOperationSparqlEndpoint.ts"],"names":[],"mappings":"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","sourcesContent":["import { BindingsFactory } from '@comunica/bindings-factory';\nimport type { MediatorHttp } from '@comunica/bus-http';\nimport type { IActionQueryOperation } from '@comunica/bus-query-operation';\nimport { ActorQueryOperation } from '@comunica/bus-query-operation';\nimport { getContextSourceFirst, getDataSourceType, getDataSourceValue } from '@comunica/bus-rdf-resolve-quad-pattern';\nimport {\n  getContextDestinationFirst,\n  getDataDestinationType,\n  getDataDestinationValue,\n} from '@comunica/bus-rdf-update-quads';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { IActorArgs, IActorTest } from '@comunica/core';\nimport type { IMediatorTypeHttpRequests } from '@comunica/mediatortype-httprequests';\nimport type { IQueryOperationResult,\n  IQueryOperationResultBindings,\n  IQueryOperationResultBoolean,\n  IQueryOperationResultQuads,\n  IMetadata,\n  IActionContext } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { wrap } from 'asynciterator';\nimport { SparqlEndpointFetcher } from 'fetch-sparql-endpoint';\nimport type { IUpdateTypes } from 'fetch-sparql-endpoint';\nimport { DataFactory } from 'rdf-data-factory';\nimport { Factory, toSparql, Util } from 'sparqlalgebrajs';\nimport { LazyCardinalityIterator } from './LazyCardinalityIterator';\n\nconst BF = new BindingsFactory();\nconst DF = new DataFactory();\n\n/**\n * A comunica SPARQL Endpoint Query Operation Actor.\n */\nexport class ActorQueryOperationSparqlEndpoint extends ActorQueryOperation {\n  protected static readonly FACTORY: Factory = new Factory();\n\n  public readonly mediatorHttp: MediatorHttp;\n\n  public readonly checkUrlSuffixSparql: boolean;\n  public readonly checkUrlSuffixUpdate: boolean;\n\n  public readonly endpointFetcher: SparqlEndpointFetcher;\n\n  protected lastContext: IActionContext;\n\n  public constructor(args: IActorQueryOperationSparqlEndpointArgs) {\n    super(args);\n    this.endpointFetcher = new SparqlEndpointFetcher({\n      method: args.forceHttpGet ? 'GET' : 'POST',\n      fetch: (input: Request | string, init?: RequestInit) => this.mediatorHttp.mediate(\n        { input, init, context: this.lastContext },\n      ),\n      prefixVariableQuestionMark: true,\n    });\n  }\n\n  public async test(action: IActionQueryOperation): Promise<IMediatorTypeHttpRequests> {\n    if (!action.operation) {\n      throw new Error('Missing field \\'operation\\' in a query operation action.');\n    }\n    const source = getContextSourceFirst(action.context);\n    const destination = getContextDestinationFirst(action.context);\n    const sourceType = source ? getDataSourceType(source) : undefined;\n    const destinationType = destination ? getDataDestinationType(destination) : undefined;\n    const sourceValue = source ? getDataSourceValue(source) : undefined;\n    const destinationValue = destination ? getDataDestinationValue(destination) : undefined;\n    if ((source && sourceType === 'sparql' &&\n      (!destination || (destinationType === 'sparql' && destinationValue === sourceValue))) ||\n      (source && !sourceType && (!destination || (!destinationType && destinationValue === sourceValue)) &&\n        typeof sourceValue === 'string' && (\n        (this.checkUrlSuffixSparql && sourceValue.endsWith('/sparql')) ||\n        (this.checkUrlSuffixUpdate && sourceValue.endsWith('/update'))\n      ))) {\n      return { httpRequests: 1 };\n    }\n    throw new Error(`${this.name} requires a single source with a 'sparql' endpoint to be present in the context or URL ending on /sparql or /update.`);\n  }\n\n  public async run(action: IActionQueryOperation): Promise<IQueryOperationResult> {\n    const source = getContextSourceFirst(action.context);\n    if (!source) {\n      throw new Error('Illegal state: undefined sparql endpoint source.');\n    }\n    const endpoint: string = <string> getDataSourceValue(source);\n    this.lastContext = action.context;\n\n    // Determine the full SPARQL query that needs to be sent to the endpoint\n    // Also check the type of the query (SELECT, CONSTRUCT (includes DESCRIBE) or ASK)\n    let query: string;\n    let type: 'SELECT' | 'CONSTRUCT' | 'ASK' | 'UNKNOWN' | IUpdateTypes | undefined;\n    let variables: RDF.Variable[] | undefined;\n    try {\n      // Use the original query string if available\n      query = action.context.get(KeysInitQuery.queryString) ?? toSparql(action.operation);\n      // This will throw an error in case the result is an invalid SPARQL query\n      type = this.endpointFetcher.getQueryType(query);\n\n      // Also check if this is an update query\n      if (type === 'UNKNOWN') {\n        type = this.endpointFetcher.getUpdateTypes(query);\n      }\n    } catch {\n      // Ignore errors\n    }\n    // If the input is an sub-query, wrap this in a SELECT\n    if (!type || type === 'UNKNOWN') {\n      variables = Util.inScopeVariables(action.operation);\n      query = toSparql(ActorQueryOperationSparqlEndpoint.FACTORY.createProject(action.operation, variables));\n      type = 'SELECT';\n    }\n\n    // Execute the query against the endpoint depending on the type\n    switch (type) {\n      case 'SELECT':\n        if (!variables) {\n          variables = Util.inScopeVariables(action.operation);\n        }\n        return this.executeQuery(endpoint, query!, false, variables);\n      case 'CONSTRUCT':\n        return this.executeQuery(endpoint, query!, true);\n      case 'ASK':\n        return <IQueryOperationResultBoolean>{\n          type: 'boolean',\n          execute: () => this.endpointFetcher.fetchAsk(endpoint, query!),\n        };\n      default:\n        return {\n          type: 'void',\n          execute: () => this.endpointFetcher.fetchUpdate(endpoint, query!),\n        };\n    }\n  }\n\n  /**\n   * Execute the given SELECT or CONSTRUCT query against the given endpoint.\n   * @param endpoint A SPARQL endpoint URL.\n   * @param query A SELECT or CONSTRUCT query.\n   * @param quads If the query returns quads, i.e., if it is a CONSTRUCT query.\n   * @param variables Variables for SELECT queries.\n   */\n  public executeQuery(endpoint: string, query: string, quads: boolean, variables?: RDF.Variable[]):\n  IQueryOperationResult {\n    const inputStream: Promise<NodeJS.EventEmitter> = quads ?\n      this.endpointFetcher.fetchTriples(endpoint, query) :\n      this.endpointFetcher.fetchBindings(endpoint, query);\n\n    const stream = wrap<any>(inputStream, { autoStart: false }).map(rawData => quads ?\n      rawData :\n      BF.bindings(Object.entries(rawData)\n        .map(([ key, value ]: [string, RDF.Term]) => [ DF.variable(key.slice(1)), value ])));\n\n    const resultStream = new LazyCardinalityIterator(stream);\n\n    const metadata: () => Promise<IMetadata<any>> = ActorQueryOperationSparqlEndpoint.cachifyMetadata(\n      async() => ({\n        cardinality: { type: 'exact', value: await resultStream.getCardinality() },\n        canContainUndefs: true,\n        variables,\n      }),\n    );\n\n    if (quads) {\n      return <IQueryOperationResultQuads> {\n        type: 'quads',\n        quadStream: resultStream,\n        metadata,\n      };\n    }\n    return <IQueryOperationResultBindings> {\n      type: 'bindings',\n      bindingsStream: <AsyncIterator<any>> resultStream,\n      metadata,\n    };\n  }\n}\n\nexport interface IActorQueryOperationSparqlEndpointArgs\n  extends IActorArgs<IActionQueryOperation, IActorTest, IQueryOperationResult> {\n  /**\n   * The HTTP mediator\n   */\n  mediatorHttp: MediatorHttp;\n  /**\n   * If URLs ending with '/sparql' should also be considered SPARQL endpoints.\n   * @default {true}\n   */\n  checkUrlSuffixSparql: boolean;\n  /**\n   * If URLs ending with '/update' should also be considered SPARQL endpoints.\n   * @default {true}\n   */\n  checkUrlSuffixUpdate: boolean;\n  /**\n   * If queries should be sent via HTTP GET instead of POST.\n   * @default {false}\n   */\n  forceHttpGet: boolean;\n}\n"]}