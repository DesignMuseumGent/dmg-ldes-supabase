{"version":3,"file":"ActorRdfResolveQuadPatternSource.js","sourceRoot":"","sources":["ActorRdfResolveQuadPatternSource.ts"],"names":[],"mappings":";;;AAOA,6EAA0E;AAE1E;;;;;GAKG;AACH,MAAsB,gCAAiC,SAAQ,uDAA0B;IACvF,YAAmB,IAAqC;QACtD,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,MAAoC;QACpD,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,MAAoC;QACnD,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC;QACpE,OAAO,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC;IACtE,CAAC;IAED;;;;;;;OAOG;IACO,KAAK,CAAC,SAAS,CAAC,MAAmB,EAAE,OAAqB,EAAE,OAAuB;QAE3F,qBAAqB;QACrB,MAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;QAC7F,OAAO,EAAE,IAAI,EAAE,CAAC;IAClB,CAAC;CASF;AApCD,4EAoCC","sourcesContent":["import type { IActorTest } from '@comunica/core';\nimport type { IActionContext } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport type { IActionRdfResolveQuadPattern,\n  IActorRdfResolveQuadPatternOutput, IActorRdfResolveQuadPatternArgs } from './ActorRdfResolveQuadPattern';\nimport { ActorRdfResolveQuadPattern } from './ActorRdfResolveQuadPattern';\n\n/**\n * A base implementation for rdf-resolve-quad-pattern events\n * that wraps around an {@link IQuadSource}.\n *\n * @see IQuadSource\n */\nexport abstract class ActorRdfResolveQuadPatternSource extends ActorRdfResolveQuadPattern {\n  public constructor(args: IActorRdfResolveQuadPatternArgs) {\n    super(args);\n  }\n\n  public async test(action: IActionRdfResolveQuadPattern): Promise<IActorTest> {\n    return true;\n  }\n\n  public async run(action: IActionRdfResolveQuadPattern): Promise<IActorRdfResolveQuadPatternOutput> {\n    const source = await this.getSource(action.context, action.pattern);\n    return await this.getOutput(source, action.pattern, action.context);\n  }\n\n  /**\n   * Get the output of the given action on a source.\n   * @param {IQuadSource} source A quad source, possibly lazy.\n   * @param {Algebra.Operation} operation The operation to apply.\n   * @param ActionContext context Optional context data.\n   * @return {Promise<IActorRdfResolveQuadPatternOutput>} A promise that resolves to a hash containing\n   *                                                      a data RDFJS stream.\n   */\n  protected async getOutput(source: IQuadSource, pattern: RDF.BaseQuad, context: IActionContext):\n  Promise<IActorRdfResolveQuadPatternOutput> {\n    // Create data stream\n    const data = source.match(pattern.subject, pattern.predicate, pattern.object, pattern.graph);\n    return { data };\n  }\n\n  /**\n   * Get a source instance for the given context.\n   * @param {ActionContext} context Optional context data.\n   * @param {Algebra.Pattern} operation The operation to apply.\n   * @return {Promise<RDF.Source>} A promise that resolves to a source.\n   */\n  protected abstract getSource(context: IActionContext, operation: Algebra.Pattern): Promise<IQuadSource>;\n}\n\n/**\n * A lazy quad source.\n */\nexport interface IQuadSource {\n  /**\n   * Returns a (possibly lazy) stream that processes all quads matching the pattern.\n   *\n   * The returned stream MUST expose the property 'metadata'.\n   * The implementor is reponsible for handling cases where 'metadata'\n   * is being called without the stream being in flow-mode.\n   *\n   * @param {RDF.Term} subject   The exact subject to match, variable is wildcard.\n   * @param {RDF.Term} predicate The exact predicate to match, variable is wildcard.\n   * @param {RDF.Term} object    The exact object to match, variable is wildcard.\n   * @param {RDF.Term} graph     The exact graph to match, variable is wildcard.\n   * @return {AsyncIterator<RDF.Quad>} The resulting quad stream.\n   */\n  match: (subject: RDF.Term, predicate: RDF.Term, object: RDF.Term, graph: RDF.Term) => AsyncIterator<RDF.Quad>;\n}\n"]}