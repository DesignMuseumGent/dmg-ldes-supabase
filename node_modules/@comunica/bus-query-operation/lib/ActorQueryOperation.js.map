{"version":3,"file":"ActorQueryOperation.js","sourceRoot":"","sources":["ActorQueryOperation.ts"],"names":[],"mappings":"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","sourcesContent":["import { KeysInitQuery, KeysQueryOperation } from '@comunica/context-entries';\nimport type { IActorArgs, IActorTest, IAction, Mediate } from '@comunica/core';\nimport { Actor } from '@comunica/core';\nimport { BlankNodeBindingsScoped } from '@comunica/data-factory';\nimport type { IQueryOperationResult,\n  IQueryOperationResultBindings,\n  IQueryOperationResultBoolean,\n  IQueryOperationResultQuads,\n  IQueryOperationResultVoid,\n  Bindings,\n  IMetadata, IActionContext,\n  FunctionArgumentsCache } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { materializeOperation } from './Bindings';\n\n/**\n * A counter that keeps track blank node generated through BNODE() SPARQL\n * expressions.\n *\n * @type {number}\n */\nlet bnodeCounter = 0;\n\n/**\n * A comunica actor for query-operation events.\n *\n * Actor types:\n * * Input:  IActionQueryOperation:      A SPARQL Algebra operation.\n * * Test:   <none>\n * * Output: IActorQueryOperationOutput: A bindings stream.\n *\n * @see IActionQueryOperation\n * @see IQueryOperationResult\n */\nexport abstract class ActorQueryOperation extends Actor<IActionQueryOperation, IActorTest, IQueryOperationResult> {\n  /**\n   * @param args - @defaultNested {<default_bus> a <cbqo:components/BusQueryOperation.jsonld#BusQueryOperation>} bus\n   */\n  protected constructor(args: IActorQueryOperationArgs) {\n    super(args);\n  }\n\n  /**\n   * Safely cast a query operation output to a bindings output.\n   * This will throw a runtime error if the output is of the incorrect type.\n   * @param {IQueryOperationResult} output A query operation output.\n   * @return {IQueryOperationResultBindings} A bindings query operation output.\n   */\n  public static getSafeBindings(output: IQueryOperationResult): IQueryOperationResultBindings {\n    ActorQueryOperation.validateQueryOutput(output, 'bindings');\n    return <IQueryOperationResultBindings> output;\n  }\n\n  /**\n   * Safely cast a query operation output to a quads output.\n   * This will throw a runtime error if the output is of the incorrect type.\n   * @param {IQueryOperationResult} output A query operation output.\n   * @return {IQueryOperationResultQuads} A quads query operation output.\n   */\n  public static getSafeQuads(output: IQueryOperationResult): IQueryOperationResultQuads {\n    ActorQueryOperation.validateQueryOutput(output, 'quads');\n    return <IQueryOperationResultQuads> output;\n  }\n\n  /**\n   * Safely cast a query operation output to a boolean output.\n   * This will throw a runtime error if the output is of the incorrect type.\n   * @param {IQueryOperationResult} output A query operation output.\n   * @return {IQueryOperationResultBoolean} A boolean query operation output.\n   */\n  public static getSafeBoolean(output: IQueryOperationResult): IQueryOperationResultBoolean {\n    ActorQueryOperation.validateQueryOutput(output, 'boolean');\n    return <IQueryOperationResultBoolean> output;\n  }\n\n  /**\n   * Safely cast a query operation output to a void output.\n   * This will throw a runtime error if the output is of the incorrect type.\n   * @param {IQueryOperationResult} output A query operation output.\n   * @return {IQueryOperationResultVoid} A void query operation output.\n   */\n  public static getSafeVoid(output: IQueryOperationResult): IQueryOperationResultVoid {\n    ActorQueryOperation.validateQueryOutput(output, 'void');\n    return <IQueryOperationResultVoid> output;\n  }\n\n  /**\n   * Convert a metadata callback to a lazy callback where the response value is cached.\n   * @param {() => Promise<IMetadata>} metadata A metadata callback\n   * @return {() => Promise<{[p: string]: any}>} The callback where the response will be cached.\n   */\n  public static cachifyMetadata<M extends IMetadata<T>, T extends RDF.Variable | RDF.QuadTermName>(\n    metadata: () => Promise<M>,\n  ): () => Promise<M> {\n    let lastReturn: Promise<M>;\n    // eslint-disable-next-line no-return-assign,@typescript-eslint/no-misused-promises\n    return () => (lastReturn || (lastReturn = metadata()));\n  }\n\n  /**\n   * Throw an error if the output type does not match the expected type.\n   * @param {IQueryOperationResult} output A query operation output.\n   * @param {string} expectedType The expected output type.\n   */\n  public static validateQueryOutput(output: IQueryOperationResult, expectedType: IQueryOperationResult['type']): void {\n    if (output.type !== expectedType) {\n      throw new Error(`Invalid query output type: Expected '${expectedType}' but got '${output.type}'`);\n    }\n  }\n\n  protected static getBaseExpressionContext(context: IActionContext): IBaseExpressionContext {\n    const now: Date | undefined = context.get(KeysInitQuery.queryTimestamp);\n    const baseIRI: string | undefined = context.get(KeysInitQuery.baseIRI);\n    const functionArgumentsCache: FunctionArgumentsCache = context.get(KeysInitQuery.functionArgumentsCache) || {};\n\n    // Handle two variants of providing extension functions\n    if (context.has(KeysInitQuery.extensionFunctionCreator) && context.has(KeysInitQuery.extensionFunctions)) {\n      throw new Error('Illegal simultaneous usage of extensionFunctionCreator and extensionFunctions in context');\n    }\n    let extensionFunctionCreator: ((functionNamedNode: RDF.NamedNode) =>\n    ((args: RDF.Term[]) => Promise<RDF.Term>) | undefined) | undefined = context\n      .get(KeysInitQuery.extensionFunctionCreator);\n    // Convert dictionary-based variant to callback\n    const extensionFunctions: (Record<string, (args: RDF.Term[]) => Promise<RDF.Term>>) | undefined = context\n      .get(KeysInitQuery.extensionFunctions);\n    if (extensionFunctions) {\n      extensionFunctionCreator = functionNamedNode => extensionFunctions[functionNamedNode.value];\n    }\n\n    return { now, baseIRI, extensionFunctionCreator, functionArgumentsCache };\n  }\n\n  /**\n   * Create an options object that can be used to construct a sparqlee synchronous evaluator.\n   * @param context An action context.\n   * @param mediatorQueryOperation An optional query query operation mediator.\n   *                               If defined, the existence resolver will be defined as `exists`.\n   */\n  public static getExpressionContext(context: IActionContext, mediatorQueryOperation?: MediatorQueryOperation):\n  ISyncExpressionContext {\n    return {\n      ...this.getBaseExpressionContext(context),\n      bnode: (input?: string) => new BlankNodeBindingsScoped(input || `BNODE_${bnodeCounter++}`),\n    };\n  }\n\n  /**\n   * Create an options object that can be used to construct a sparqlee asynchronous evaluator.\n   * @param context An action context.\n   * @param mediatorQueryOperation An optional query query operation mediator.\n   *                               If defined, the existence resolver will be defined as `exists`.\n   */\n  public static getAsyncExpressionContext(context: IActionContext, mediatorQueryOperation?: MediatorQueryOperation):\n  IAsyncExpressionContext {\n    const expressionContext: IAsyncExpressionContext = {\n      ...this.getBaseExpressionContext(context),\n      bnode: (input?: string) => Promise.resolve(new BlankNodeBindingsScoped(input || `BNODE_${bnodeCounter++}`)),\n    };\n    if (mediatorQueryOperation) {\n      expressionContext.exists = ActorQueryOperation.createExistenceResolver(context, mediatorQueryOperation);\n    }\n    return expressionContext;\n  }\n\n  /**\n   * Create an existence resolver for usage within an expression context.\n   * @param context An action context.\n   * @param mediatorQueryOperation A query operation mediator.\n   */\n  public static createExistenceResolver(context: IActionContext, mediatorQueryOperation: MediatorQueryOperation):\n  (expr: Algebra.ExistenceExpression, bindings: Bindings) => Promise<boolean> {\n    return async(expr, bindings) => {\n      const operation = materializeOperation(expr.input, bindings);\n\n      const outputRaw = await mediatorQueryOperation.mediate({ operation, context });\n      const output = ActorQueryOperation.getSafeBindings(outputRaw);\n\n      return new Promise(\n        (resolve, reject) => {\n          output.bindingsStream.on('end', () => {\n            resolve(false);\n          });\n\n          output.bindingsStream.on('error', reject);\n\n          output.bindingsStream.on('data', () => {\n            output.bindingsStream.close();\n            resolve(true);\n          });\n        },\n      )\n        .then((exists: boolean) => expr.not ? !exists : exists);\n    };\n  }\n\n  /**\n   * Throw an error if the context contains the readOnly flag.\n   * @param context An action context.\n   */\n  public static throwOnReadOnly(context: IActionContext): void {\n    if (context.get(KeysQueryOperation.readOnly)) {\n      throw new Error(`Attempted a write operation in read-only mode`);\n    }\n  }\n}\n\nexport interface IActionQueryOperation extends IAction {\n  /**\n   * The query operation to handle.\n   */\n  operation: Algebra.Operation;\n}\n\nexport type IActorQueryOperationArgs = IActorArgs<IActionQueryOperation, IActorTest, IQueryOperationResult>;\n\nexport type MediatorQueryOperation = Mediate<IActionQueryOperation, IQueryOperationResult>;\n\nexport interface IBaseExpressionContext {\n  now?: Date;\n  baseIRI?: string;\n  extensionFunctionCreator?: (functionNamedNode: RDF.NamedNode) =>\n  ((args: RDF.Term[]) => Promise<RDF.Term>) | undefined;\n  functionArgumentsCache?: FunctionArgumentsCache;\n}\n\nexport interface ISyncExpressionContext extends IBaseExpressionContext {\n  bnode: (input?: string | undefined) => RDF.BlankNode;\n}\n\nexport interface IAsyncExpressionContext extends IBaseExpressionContext {\n  bnode: (input?: string | undefined) => Promise<RDF.BlankNode>;\n  exists?: (expr: Algebra.ExistenceExpression, bindings: Bindings) => Promise<boolean>;\n}\n"]}