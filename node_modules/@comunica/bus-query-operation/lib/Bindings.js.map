{"version":3,"file":"Bindings.js","sourceRoot":"","sources":["Bindings.ts"],"names":[],"mappings":"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","sourcesContent":["import { BindingsFactory } from '@comunica/bindings-factory';\nimport type { Bindings } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { termToString } from 'rdf-string';\nimport type { Algebra, Factory } from 'sparqlalgebrajs';\nimport { Util } from 'sparqlalgebrajs';\n\nconst BF = new BindingsFactory();\n\n/**\n * Materialize a term with the given binding.\n *\n * If the given term is a variable,\n * and that variable exist in the given bindings object,\n * the value of that binding is returned.\n * In all other cases, the term itself is returned.\n *\n * @param {RDF.Term} term A term.\n * @param {Bindings} bindings A bindings object.\n * @return {RDF.Term} The materialized term.\n */\nexport function materializeTerm(term: RDF.Term, bindings: Bindings): RDF.Term {\n  if (term.termType === 'Variable') {\n    const value = bindings.get(term);\n    if (value) {\n      return value;\n    }\n  }\n  return term;\n}\n\n/**\n * Materialize the given operation (recursively) with the given bindings.\n * Essentially, all variables in the given operation will be replaced\n * by the terms bound to the variables in the given bindings.\n * @param {Operation} operation SPARQL algebra operation.\n * @param {Bindings} bindings A bindings object.\n * @param options Options for materializations.\n * @return Algebra.Operation A new operation materialized with the given bindings.\n */\nexport function materializeOperation(\n  operation: Algebra.Operation,\n  bindings: Bindings,\n  options: {\n    /**\n     * If target variable bindings (such as on SELECT or BIND) should not be allowed.\n     */\n    strictTargetVariables?: boolean;\n    /**\n     * If filter expressions should be materialized\n     */\n    bindFilter?: boolean;\n  } = {},\n): Algebra.Operation {\n  options = {\n    strictTargetVariables: 'strictTargetVariables' in options ? options.strictTargetVariables : false,\n    bindFilter: 'bindFilter' in options ? options.bindFilter : true,\n  };\n\n  return Util.mapOperation(operation, {\n    path(op: Algebra.Path, factory: Factory) {\n      // Materialize variables in a path expression.\n      // The predicate expression will be recursed.\n      return {\n        recurse: false,\n        result: factory.createPath(\n          materializeTerm(op.subject, bindings),\n          op.predicate,\n          materializeTerm(op.object, bindings),\n          materializeTerm(op.graph, bindings),\n        ),\n      };\n    },\n    pattern(op: Algebra.Pattern, factory: Factory) {\n      // Materialize variables in the quad pattern.\n      return {\n        recurse: false,\n        result: factory.createPattern(\n          materializeTerm(op.subject, bindings),\n          materializeTerm(op.predicate, bindings),\n          materializeTerm(op.object, bindings),\n          materializeTerm(op.graph, bindings),\n        ),\n      };\n    },\n    extend(op: Algebra.Extend) {\n      // Materialize an extend operation.\n      // If strictTargetVariables is true, we throw if the extension target variable is attempted to be bound.\n      // Otherwise, we remove the extend operation.\n      if (bindings.has(op.variable)) {\n        if (options.strictTargetVariables) {\n          throw new Error(`Tried to bind variable ${termToString(op.variable)} in a BIND operator.`);\n        } else {\n          return {\n            recurse: true,\n            result: materializeOperation(op.input, bindings, options),\n          };\n        }\n      }\n      return {\n        recurse: true,\n        result: op,\n      };\n    },\n    group(op: Algebra.Group, factory: Factory) {\n      // Materialize a group operation.\n      // If strictTargetVariables is true, we throw if the group target variable is attempted to be bound.\n      // Otherwise, we just filter out the bound variables.\n      if (options.strictTargetVariables) {\n        for (const variable of op.variables) {\n          if (bindings.has(variable)) {\n            throw new Error(`Tried to bind variable ${termToString(variable)} in a GROUP BY operator.`);\n          }\n        }\n        return {\n          recurse: true,\n          result: op,\n        };\n      }\n      const variables = op.variables.filter(variable => !bindings.has(variable));\n      return {\n        recurse: true,\n        result: factory.createGroup(\n          op.input,\n          variables,\n          op.aggregates,\n        ),\n      };\n    },\n    project(op: Algebra.Project, factory: Factory) {\n      // Materialize a project operation.\n      // If strictTargetVariables is true, we throw if the project target variable is attempted to be bound.\n      // Otherwise, we just filter out the bound variables.\n      if (options.strictTargetVariables) {\n        for (const variable of op.variables) {\n          if (bindings.has(variable)) {\n            throw new Error(`Tried to bind variable ${termToString(variable)} in a SELECT operator.`);\n          }\n        }\n        return {\n          recurse: true,\n          result: op,\n        };\n      }\n\n      const variables = op.variables.filter(variable => !bindings.has(variable));\n\n      // Only include projected variables in the sub-bindings that will be passed down recursively.\n      // If we don't do this, we may be binding variables that may have the same label, but are not considered equal.\n      const subBindings = BF.bindings(<[RDF.Variable, RDF.Term][]> op.variables.map(variable => {\n        const binding = bindings.get(variable);\n        if (binding) {\n          return [ variable, binding ];\n        }\n        // eslint-disable-next-line no-useless-return\n        return;\n      }).filter(entry => Boolean(entry)));\n\n      return {\n        recurse: false,\n        result: factory.createProject(\n          materializeOperation(\n            op.input,\n            subBindings,\n            options,\n          ),\n          variables,\n        ),\n      };\n    },\n    values(op: Algebra.Values, factory: Factory) {\n      // Materialize a values operation.\n      // If strictTargetVariables is true, we throw if the values target variable is attempted to be bound.\n      // Otherwise, we just filter out the bound variables and their bindings.\n      if (options.strictTargetVariables) {\n        for (const variable of op.variables) {\n          if (bindings.has(variable)) {\n            throw new Error(`Tried to bind variable ${termToString(variable)} in a VALUES operator.`);\n          }\n        }\n      } else {\n        const variables = op.variables.filter(variable => !bindings.has(variable));\n        const valueBindings: Record<string, RDF.Literal | RDF.NamedNode>[] = <any> op.bindings.map(binding => {\n          const newBinding = { ...binding };\n          let valid = true;\n          bindings.forEach((value: RDF.NamedNode, key: RDF.Variable) => {\n            const keyString = termToString(key);\n            if (keyString in newBinding) {\n              if (!value.equals(newBinding[keyString])) {\n                // If the value of the binding is not equal, remove this binding completely from the VALUES clause\n                valid = false;\n              }\n              delete newBinding[keyString];\n            }\n          });\n          return valid ? newBinding : undefined;\n        }).filter(Boolean);\n        return {\n          recurse: true,\n          result: factory.createValues(\n            variables,\n            valueBindings,\n          ),\n        };\n      }\n      return {\n        recurse: false,\n        result: op,\n      };\n    },\n    expression(op: Algebra.Expression, factory: Factory) {\n      if (!options.bindFilter) {\n        return {\n          recurse: false,\n          result: op,\n        };\n      }\n\n      if (op.expressionType === 'term') {\n        // Materialize a term expression\n        return {\n          recurse: false,\n          result: factory.createTermExpression(materializeTerm(op.term, bindings)),\n        };\n      }\n      if (op.expressionType === 'aggregate' &&\n        'variable' in op &&\n        bindings.has(<RDF.Variable> op.variable)) {\n        // Materialize a bound aggregate operation.\n        // If strictTargetVariables is true, we throw if the expression target variable is attempted to be bound.\n        // Otherwise, we ignore this operation.\n        if (options.strictTargetVariables) {\n          throw new Error(`Tried to bind ${termToString(op.variable)} in a ${op.aggregator} aggregate.`);\n        } else {\n          return {\n            recurse: true,\n            result: op,\n          };\n        }\n      }\n      return {\n        recurse: true,\n        result: op,\n      };\n    },\n  });\n}\n"]}