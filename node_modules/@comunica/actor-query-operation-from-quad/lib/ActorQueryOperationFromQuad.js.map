{"version":3,"file":"ActorQueryOperationFromQuad.js","sourceRoot":"","sources":["ActorQueryOperationFromQuad.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport { ActorQueryOperationTypedMediated } from '@comunica/bus-query-operation';\nimport type { IActorTest } from '@comunica/core';\nimport type { IActionContext, IQueryOperationResult } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { Algebra, Factory } from 'sparqlalgebrajs';\n\n/**\n * A comunica From Query Operation Actor.\n */\nexport class ActorQueryOperationFromQuad extends ActorQueryOperationTypedMediated<Algebra.From> {\n  private static readonly FACTORY: Factory = new Factory();\n  private static readonly ALGEBRA_TYPES: string[] = Object.keys(Algebra.types).map(key => (<any> Algebra.types)[key]);\n\n  public constructor(args: IActorQueryOperationTypedMediatedArgs) {\n    super(args, 'from');\n  }\n\n  /**\n   * Create a deep copy of the given operation.\n   * @param {Operation} operation An operation.\n   * @param {(subOperation: Operation) => Operation} recursiveCb A callback for recursive operation calls.\n   * @return {Operation} The copied operation.\n   */\n  public static copyOperation(operation: Algebra.Operation,\n    recursiveCb: (subOperation: Algebra.Operation) => Algebra.Operation): Algebra.Operation {\n    const copiedOperation: Algebra.Operation = <any> {};\n    for (const key of Object.keys(operation)) {\n      if (Array.isArray(operation[key]) && key !== 'template') {\n        // We exclude the 'template' entry, as we don't want to modify the template value of construct operations\n        if (key === 'variables') {\n          copiedOperation[key] = operation[key];\n        } else {\n          copiedOperation[key] = operation[key].map(recursiveCb);\n        }\n      } else if (ActorQueryOperationFromQuad.ALGEBRA_TYPES.includes(operation[key].type)) {\n        copiedOperation[key] = recursiveCb(operation[key]);\n      } else {\n        copiedOperation[key] = operation[key];\n      }\n    }\n    return copiedOperation;\n  }\n\n  /**\n   * Recursively transform the given operation to use the given graphs as default graph\n   * This will (possibly) create a new operation and not modify the given operation.\n   * @param {Operation} operation An operation.\n   * @param {RDF.Term[]} defaultGraphs Graph terms.\n   * @return {Operation} A new operation.\n   */\n  public static applyOperationDefaultGraph(operation: Algebra.Operation, defaultGraphs: RDF.Term[]): Algebra.Operation {\n    // If the operation is a BGP or Path, change the graph.\n    if ((operation.type === 'bgp' && operation.patterns.length > 0) ||\n      operation.type === 'path' ||\n      operation.type === 'pattern') {\n      if (operation.type === 'bgp') {\n        return ActorQueryOperationFromQuad.joinOperations(operation.patterns.map((pattern: Algebra.Pattern) => {\n          if (pattern.graph.termType !== 'DefaultGraph') {\n            return ActorQueryOperationFromQuad.FACTORY.createBgp([ pattern ]);\n          }\n          const bgps = defaultGraphs.map((graph: RDF.Term) =>\n            ActorQueryOperationFromQuad.FACTORY.createBgp([ ActorQueryOperationFromQuad.FACTORY\n              .createPattern(pattern.subject, pattern.predicate, pattern.object, graph) ]));\n          return ActorQueryOperationFromQuad.unionOperations(bgps);\n        }));\n      }\n      if (operation.graph.termType !== 'DefaultGraph') {\n        return operation;\n      }\n      const paths = defaultGraphs.map(\n        (graph: RDF.Term) => {\n          if (operation.type === 'path') {\n            return ActorQueryOperationFromQuad.FACTORY\n              .createPath(operation.subject, operation.predicate, operation.object, graph);\n          }\n          return ActorQueryOperationFromQuad.FACTORY\n            .createPattern(operation.subject, operation.predicate, operation.object, graph);\n        },\n      );\n      return ActorQueryOperationFromQuad.unionOperations(paths);\n    }\n\n    return ActorQueryOperationFromQuad.copyOperation(operation,\n      (subOperation: Algebra.Operation) => this.applyOperationDefaultGraph(subOperation, defaultGraphs));\n  }\n\n  /**\n   * Recursively transform the given operation to use the given graphs as named graph\n   * This will (possibly) create a new operation and not modify the given operation.\n   * @param {Operation} operation An operation.\n   * @param {RDF.Term[]} namedGraphs Graph terms.\n   * @param {RDF.Term[]} defaultGraphs Default graph terms.\n   * @return {Operation} A new operation.\n   */\n  public static applyOperationNamedGraph(operation: Algebra.Operation, namedGraphs: RDF.NamedNode[],\n    defaultGraphs: RDF.Term[]): Algebra.Operation {\n    // If the operation is a BGP or Path, change the graph.\n    if ((operation.type === 'bgp' && operation.patterns.length > 0) ||\n      operation.type === 'path' ||\n      operation.type === 'pattern') {\n      const patternGraph: RDF.Term = operation.type === 'bgp' ? operation.patterns[0].graph : operation.graph;\n      if (patternGraph.termType === 'DefaultGraph') {\n        // SPARQL spec (8.2) describes that when FROM NAMED's are used without a FROM, the default graph must be empty.\n        // The FROMs are transformed before this step to a named node, so this will not apply to this case anymore.\n        return { type: Algebra.types.BGP, patterns: []};\n      }\n      if (patternGraph.termType === 'Variable') {\n        if (namedGraphs.length === 1) {\n          const graph: RDF.NamedNode = namedGraphs[0];\n          // If the pattern graph is a variable, replace the graph and bind the variable using VALUES\n          const bindings: Record<string, RDF.Literal | RDF.NamedNode> = {};\n          bindings[`?${patternGraph.value}`] = graph;\n          const values: Algebra.Values = ActorQueryOperationFromQuad.FACTORY\n            .createValues([ patternGraph ], [ bindings ]);\n\n          let pattern: Algebra.Operation;\n          if (operation.type === 'bgp') {\n            pattern = ActorQueryOperationFromQuad.FACTORY\n              .createBgp(operation.patterns.map((pat: Algebra.Pattern) => ActorQueryOperationFromQuad.FACTORY\n                .createPattern(pat.subject, pat.predicate, pat.object, graph)));\n          } else if (operation.type === 'path') {\n            pattern = ActorQueryOperationFromQuad.FACTORY\n              .createPath(operation.subject, operation.predicate, operation.object, graph);\n          } else {\n            pattern = ActorQueryOperationFromQuad.FACTORY\n              .createPattern(operation.subject, operation.predicate, operation.object, graph);\n          }\n\n          return ActorQueryOperationFromQuad.FACTORY.createJoin([ values, pattern ]);\n        }\n        // If the pattern graph is a variable, take the union of the pattern applied to each available named graph\n        return ActorQueryOperationFromQuad.unionOperations(namedGraphs.map(\n          (graph: RDF.NamedNode) => ActorQueryOperationFromQuad.applyOperationNamedGraph(\n            operation, [ graph ], defaultGraphs,\n          ),\n        ));\n      }\n      // The pattern's graph is defined (including the default graphs)\n      const isNamedGraphAvailable: boolean = [ ...namedGraphs, ...defaultGraphs ].some(\n        (namedGraph: RDF.Term) => namedGraph.equals(patternGraph),\n      );\n      if (isNamedGraphAvailable) {\n        // Return the pattern as-is if the pattern's graph was selected in a FROM NAMED\n        return operation;\n      }\n      // No-op if the pattern's graph was not selected in a FROM NAMED.\n      return { type: Algebra.types.BGP, patterns: []};\n    }\n\n    return ActorQueryOperationFromQuad.copyOperation(operation,\n      (subOperation: Algebra.Operation) => this.applyOperationNamedGraph(subOperation, namedGraphs, defaultGraphs));\n  }\n\n  /**\n   * Transform the given array of operations into a join operation.\n   * @param {Operation[]} operations An array of operations, must contain at least one operation.\n   * @return {Join} A join operation.\n   */\n  public static joinOperations(operations: Algebra.Operation[]): Algebra.Operation {\n    if (operations.length === 1) {\n      return operations[0];\n    }\n    if (operations.length > 1) {\n      return ActorQueryOperationFromQuad.FACTORY.createJoin(operations);\n    }\n    throw new Error('A join can only be applied on at least one operation');\n  }\n\n  /**\n   * Transform the given array of operations into a union operation.\n   * @param {Operation[]} operations An array of operations, must contain at least one operation.\n   * @return {Union} A union operation.\n   */\n  public static unionOperations(operations: Algebra.Operation[]): Algebra.Operation {\n    if (operations.length === 1) {\n      return operations[0];\n    }\n    if (operations.length > 1) {\n      return ActorQueryOperationFromQuad.FACTORY.createUnion(operations);\n    }\n    throw new Error('A union can only be applied on at least one operation');\n  }\n\n  /**\n   * Transform an operation based on the default and named graphs in the pattern.\n   *\n   * FROM sets the default graph.\n   * If multiple are available, take the union of the operation for all of them at quad-pattern level.\n   *\n   * FROM NAMED indicates which named graphs are available.\n   * This will rewrite the query so that only triples from the given named graphs can be selected.\n   *\n   * @param {From} pattern A from operation.\n   * @return {Operation} The transformed operation.\n   */\n  public static createOperation(pattern: Algebra.From): Algebra.Operation {\n    let operation: Algebra.Operation = pattern.input;\n    if (pattern.default.length > 0) {\n      operation = ActorQueryOperationFromQuad.applyOperationDefaultGraph(operation, pattern.default);\n    }\n    if (pattern.named.length > 0 || pattern.default.length > 0) {\n      operation = ActorQueryOperationFromQuad.applyOperationNamedGraph(operation, pattern.named, pattern.default);\n    }\n    return operation;\n  }\n\n  public async testOperation(operation: Algebra.From, context: IActionContext): Promise<IActorTest> {\n    return true;\n  }\n\n  public async runOperation(\n    operationOriginal: Algebra.From,\n    context: IActionContext,\n  ): Promise<IQueryOperationResult> {\n    const operation: Algebra.Operation = ActorQueryOperationFromQuad.createOperation(operationOriginal);\n    return this.mediatorQueryOperation.mediate({ operation, context });\n  }\n}\n"]}