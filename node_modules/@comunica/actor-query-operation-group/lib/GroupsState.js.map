{"version":3,"file":"GroupsState.js","sourceRoot":"","sources":["GroupsState.ts"],"names":[],"mappings":"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","sourcesContent":["import { BindingsFactory } from '@comunica/bindings-factory';\nimport type { HashFunction } from '@comunica/bus-hash-bindings';\nimport type { Bindings } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { AsyncAggregateEvaluator } from 'sparqlee';\nimport type { AsyncEvaluatorConfig } from 'sparqlee';\n\nconst DF = new DataFactory();\nconst BF = new BindingsFactory();\n\n/**\n * A simple type alias for strings that should be hashes of Bindings\n */\nexport type BindingsHash = string;\n\n/**\n * A state container for a single group\n *\n * @property {Bindings} bindings - The binding entries on which we group\n */\nexport interface IGroup {\n  bindings: Bindings;\n  aggregators: Record<string, AsyncAggregateEvaluator>;\n}\n\n/**\n * A state manager for the groups constructed by consuming the bindings-stream.\n */\nexport class GroupsState {\n  private readonly groups: Map<BindingsHash, IGroup>;\n  // We need to the promises of a group so we can await the initialisation/ creation of them.\n  //  Without this we could have duplicate work/ override precious work.\n  private readonly groupsInitializer: Map<BindingsHash, Promise<IGroup>>;\n  private readonly groupVariables: Set<string>;\n  private readonly distinctHashes: null | Map<BindingsHash, Set<BindingsHash>>;\n  private waitCounter: number;\n  // Function that resolves the promise given by collectResults\n  private waitResolver: (bindings: Bindings[]) => void;\n  private resultHasBeenCalled: boolean;\n\n  public constructor(\n    private readonly hashFunction: HashFunction,\n    private readonly pattern: Algebra.Group,\n    private readonly sparqleeConfig: AsyncEvaluatorConfig,\n  ) {\n    this.groups = new Map();\n    this.groupsInitializer = new Map();\n    this.groupVariables = new Set(this.pattern.variables.map(x => x.value));\n    this.distinctHashes = pattern.aggregates.some(({ distinct }) => distinct) ?\n      new Map() :\n      null;\n    this.waitCounter = 1;\n    this.resultHasBeenCalled = false;\n  }\n\n  /**\n   * - Consumes a stream binding\n   * - Find the corresponding group and create one if need be\n   * - Feeds the binding to the group's aggregators\n   *\n   * @param {Bindings} bindings - The Bindings to consume\n   */\n  public consumeBindings(bindings: Bindings): Promise<void> {\n    const check = this.resultCheck<void>();\n    if (check) {\n      return check;\n    }\n    // We increment the counter and decrement him when put action is performed.\n    this.waitCounter++;\n\n    // Select the bindings on which we group\n    const grouper = bindings\n      .filter((_, variable) => this.groupVariables.has(variable.value));\n    const groupHash = this.hashBindings(grouper);\n\n    // First member of group -> create new group\n    let groupInitializer: Promise<IGroup> | undefined = this.groupsInitializer.get(groupHash);\n\n    let res: Promise<any>;\n    if (!groupInitializer) {\n      // Initialize state for all aggregators for new group\n      groupInitializer = (async() => {\n        const aggregators: Record<string, AsyncAggregateEvaluator> = {};\n        await Promise.all(this.pattern.aggregates.map(async aggregate => {\n          const key = aggregate.variable.value;\n          aggregators[key] = new AsyncAggregateEvaluator(aggregate, this.sparqleeConfig);\n          await aggregators[key].put(bindings);\n        }));\n\n        if (this.distinctHashes) {\n          const bindingsHash = this.hashBindings(bindings);\n          this.distinctHashes.set(groupHash, new Set([ bindingsHash ]));\n        }\n        const group = { aggregators, bindings: grouper };\n        this.groups.set(groupHash, group);\n        this.subtractWaitCounterAndCollect();\n        return group;\n      })();\n      this.groupsInitializer.set(groupHash, groupInitializer);\n      res = groupInitializer;\n    } else {\n      const groupInitializerDefined = groupInitializer;\n      res = (async() => {\n        const group = await groupInitializerDefined;\n        await Promise.all(this.pattern.aggregates.map(async aggregate => {\n          // If distinct, check first whether we have inserted these values already\n          if (aggregate.distinct) {\n            const hash = this.hashBindings(bindings);\n            if (this.distinctHashes!.get(groupHash)!.has(hash)) {\n              return;\n            }\n            this.distinctHashes!.get(groupHash)!.add(hash);\n          }\n\n          const variable = aggregate.variable.value;\n          await group.aggregators[variable].put(bindings);\n        }));\n      })().then(() => {\n        this.subtractWaitCounterAndCollect();\n      });\n    }\n    return res;\n  }\n\n  private subtractWaitCounterAndCollect(): void {\n    if (--this.waitCounter === 0) {\n      this.handleResultCollection();\n    }\n  }\n\n  private handleResultCollection(): void {\n    // Collect groups\n    let rows: Bindings[] = [ ...this.groups ].map(([ _, group ]) => {\n      const { bindings: groupBindings, aggregators } = group;\n\n      // Collect aggregator bindings\n      // If the aggregate errorred, the result will be undefined\n      let returnBindings = groupBindings;\n      for (const variable in aggregators) {\n        const value = aggregators[variable].result();\n        if (value) {\n          // Filter undefined\n          returnBindings = returnBindings.set(DF.variable(variable), value);\n        }\n      }\n\n      // Merge grouping bindings and aggregator bindings\n      return returnBindings;\n    });\n\n    // Case: No Input\n    // Some aggregators still define an output on the empty input\n    // Result is a single Bindings\n    if (rows.length === 0 && this.groupVariables.size === 0) {\n      const single: [RDF.Variable, RDF.Term][] = [];\n      for (const aggregate of this.pattern.aggregates) {\n        const key = aggregate.variable;\n        const value = AsyncAggregateEvaluator.emptyValue(aggregate);\n        if (value !== undefined) {\n          single.push([ key, value ]);\n        }\n      }\n      rows = [ BF.bindings(single) ];\n    }\n    this.waitResolver(rows);\n  }\n\n  private resultCheck<T>(): Promise<T> | undefined {\n    if (this.resultHasBeenCalled) {\n      return Promise.reject(new Error('Calling any function after calling collectResult is invalid.'));\n    }\n  }\n\n  /**\n   * Collect the result of the final state. This returns a Bindings per group,\n   * and a (possibly empty) Bindings in case no Bindings have been consumed yet.\n   * You can only call this method once, after calling this method,\n   * calling any function on this will result in an error being thrown.\n   */\n  public collectResults(): Promise<Bindings[]> {\n    const check = this.resultCheck<Bindings[]>();\n    if (check) {\n      return check;\n    }\n    this.resultHasBeenCalled = true;\n    const res = new Promise<Bindings[]>(resolve => {\n      this.waitResolver = resolve;\n    });\n    this.subtractWaitCounterAndCollect();\n    return res;\n  }\n\n  /**\n   * @param {Bindings} bindings - Bindings to hash\n   */\n  private hashBindings(bindings: Bindings): BindingsHash {\n    return this.hashFunction(bindings);\n  }\n}\n"]}