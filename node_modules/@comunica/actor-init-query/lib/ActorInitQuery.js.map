{"version":3,"file":"ActorInitQuery.js","sourceRoot":"","sources":["ActorInitQuery.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable import/no-nodejs-modules */\nimport { readFileSync } from 'fs';\nimport type { IActionInit, IActorOutputInit } from '@comunica/bus-init';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { ICliArgsHandler, IQueryContextCommon } from '@comunica/types';\nimport type { Readable } from 'readable-stream';\nimport yargs from 'yargs';\nimport type { IActorInitQueryBaseArgs } from './ActorInitQueryBase';\nimport { ActorInitQueryBase } from './ActorInitQueryBase';\nimport { CliArgsHandlerBase } from './cli/CliArgsHandlerBase';\nimport { CliArgsHandlerQuery } from './cli/CliArgsHandlerQuery';\nimport { QueryEngineBase } from './QueryEngineBase';\n\nconst streamifyString = require('streamify-string');\n\n/**\n * A comunica Query Init Actor.\n */\nexport class ActorInitQuery<QueryContext extends IQueryContextCommon = IQueryContextCommon>\n  extends ActorInitQueryBase<QueryContext> {\n  public constructor(args: IActorInitQueryBaseArgs<QueryContext>) {\n    super(args);\n  }\n\n  public async run(action: IActionInit): Promise<IActorOutputInit> {\n    // Wrap this actor in a query engine so we can conveniently execute queries\n    const queryEngine = new QueryEngineBase<QueryContext>(this);\n\n    const cliArgsHandlers: ICliArgsHandler[] = [\n      new CliArgsHandlerBase(action.context),\n      new CliArgsHandlerQuery(\n        this.defaultQueryInputFormat,\n        this.queryString,\n        this.context,\n      ),\n      // eslint-disable-next-line @typescript-eslint/non-nullable-type-assertion-style\n      ...(<ICliArgsHandler[]> action.context?.get(KeysInitQuery.cliArgsHandlers)) || [],\n    ];\n\n    // Populate yargs arguments object\n    let argumentsBuilder = yargs({});\n    for (const cliArgsHandler of cliArgsHandlers) {\n      argumentsBuilder = cliArgsHandler.populateYargs(argumentsBuilder);\n    }\n\n    // Extract raw argument values from parsed yargs object, so that we can handle each of them hereafter\n    let args: Record<string, any>;\n    try {\n      args = await argumentsBuilder.parse(action.argv);\n    } catch (error: unknown) {\n      return {\n        stderr: require('streamify-string')(`${await argumentsBuilder.getHelp()}\\n\\n${(<Error> error).message}\\n`),\n      };\n    }\n\n    // Print supported MIME types\n    if (args.listformats) {\n      const mediaTypes: Record<string, number> = await queryEngine.getResultMediaTypes();\n      return { stdout: require('streamify-string')(`${Object.keys(mediaTypes).join('\\n')}\\n`) };\n    }\n\n    // Define query\n    // We need to do this before the cliArgsHandlers, as we may modify the sources array\n    let query: string | undefined;\n    if (args.query) {\n      query = <string> args.query;\n    } else if (args.file) {\n      query = readFileSync(args.file, { encoding: 'utf8' });\n    } else if (args.sources.length > 0) {\n      query = args.sources[args.sources.length - 1];\n      args.sources.pop();\n    }\n\n    // Invoke args handlers to process any remaining args\n    const context: Record<string, any> = {};\n    try {\n      for (const cliArgsHandler of cliArgsHandlers) {\n        await cliArgsHandler.handleArgs(args, context);\n      }\n    } catch (error: unknown) {\n      return { stderr: require('streamify-string')((<Error> error).message) };\n    }\n\n    // Evaluate query\n    const queryResult = await queryEngine.queryOrExplain(query!, <any> context);\n\n    // Output query explanations in a different way\n    if ('explain' in queryResult) {\n      return {\n        stdout: streamifyString(JSON.stringify(queryResult.data, null, '  ')),\n      };\n    }\n\n    // Serialize output according to media type\n    const stdout: Readable = <Readable> (await queryEngine.resultToString(\n      queryResult,\n      args.outputType,\n      queryResult.context,\n    )).data;\n\n    return { stdout };\n  }\n}\n/* eslint-enable import/no-nodejs-modules */\n"]}