{"version":3,"file":"QueryEngineBase.js","sourceRoot":"","sources":["QueryEngineBase.ts"],"names":[],"mappings":"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","sourcesContent":["import { materializeOperation } from '@comunica/bus-query-operation';\nimport type { IActionSparqlSerialize, IActorQueryResultSerializeOutput } from '@comunica/bus-query-result-serialize';\nimport { KeysCore, KeysInitQuery, KeysRdfResolveQuadPattern } from '@comunica/context-entries';\nimport { ActionContext } from '@comunica/core';\nimport type {\n  IActionContext, IPhysicalQueryPlanLogger,\n  IQueryOperationResult,\n  IQueryEngine, IQueryExplained,\n  QueryFormatType,\n  QueryType, QueryExplainMode, BindingsStream,\n  QueryAlgebraContext, QueryStringContext, IQueryBindingsEnhanced,\n  IQueryQuadsEnhanced, QueryEnhanced, IQueryContextCommon, FunctionArgumentsCache,\n} from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport type { ActorInitQueryBase } from './ActorInitQueryBase';\nimport { MemoryPhysicalQueryPlanLogger } from './MemoryPhysicalQueryPlanLogger';\n\n/**\n * Base implementation of a Comunica query engine.\n */\nexport class QueryEngineBase<QueryContext extends IQueryContextCommon = IQueryContextCommon>\nimplements IQueryEngine<QueryContext> {\n  private readonly actorInitQuery: ActorInitQueryBase;\n  private readonly defaultFunctionArgumentsCache: FunctionArgumentsCache;\n\n  public constructor(actorInitQuery: ActorInitQueryBase<QueryContext>) {\n    this.actorInitQuery = actorInitQuery;\n    this.defaultFunctionArgumentsCache = {};\n  }\n\n  public async queryBindings<QueryFormatTypeInner extends QueryFormatType>(\n    query: QueryFormatTypeInner,\n    context?: QueryContext & QueryFormatTypeInner extends string ? QueryStringContext : QueryAlgebraContext,\n  ): Promise<BindingsStream> {\n    return this.queryOfType<QueryFormatTypeInner, IQueryBindingsEnhanced>(query, context, 'bindings');\n  }\n\n  public async queryQuads<QueryFormatTypeInner extends QueryFormatType>(\n    query: QueryFormatTypeInner,\n    context?: QueryContext & QueryFormatTypeInner extends string ? QueryStringContext : QueryAlgebraContext,\n  ): Promise<AsyncIterator<RDF.Quad> & RDF.ResultStream<RDF.Quad>> {\n    return this.queryOfType<QueryFormatTypeInner, IQueryQuadsEnhanced>(query, context, 'quads');\n  }\n\n  public async queryBoolean<QueryFormatTypeInner extends QueryFormatType>(\n    query: QueryFormatTypeInner,\n    context?: QueryContext & QueryFormatTypeInner extends string ? QueryStringContext : QueryAlgebraContext,\n  ): Promise<boolean> {\n    return this.queryOfType<QueryFormatTypeInner, RDF.QueryBoolean>(query, context, 'boolean');\n  }\n\n  public async queryVoid<QueryFormatTypeInner extends QueryFormatType>(\n    query: QueryFormatTypeInner,\n    context?: QueryContext & QueryFormatTypeInner extends string ? QueryStringContext : QueryAlgebraContext,\n  ): Promise<void> {\n    return this.queryOfType<QueryFormatTypeInner, RDF.QueryVoid>(query, context, 'void');\n  }\n\n  protected async queryOfType<QueryFormatTypeInner extends QueryFormatType, QueryTypeOut extends QueryEnhanced>(\n    query: QueryFormatTypeInner,\n    context: undefined | (QueryContext & QueryFormatTypeInner extends string ?\n      QueryStringContext : QueryAlgebraContext),\n    expectedType: QueryTypeOut['resultType'],\n  ): Promise<ReturnType<QueryTypeOut['execute']>> {\n    const result = await this.query<QueryFormatTypeInner>(query, context);\n    if (result.resultType === expectedType) {\n      return result.execute();\n    }\n    throw new Error(`Query result type '${expectedType}' was expected, while '${result.resultType}' was found.`);\n  }\n\n  /**\n   * Evaluate the given query\n   * @param query A query string or algebra.\n   * @param context An optional query context.\n   * @return {Promise<QueryType>} A promise that resolves to the query output.\n   */\n  public async query<QueryFormatTypeInner extends QueryFormatType>(\n    query: QueryFormatTypeInner,\n    context?: QueryContext & QueryFormatTypeInner extends string ? QueryStringContext : QueryAlgebraContext,\n  ): Promise<QueryType> {\n    const output = await this.queryOrExplain(query, context);\n    if ('explain' in output) {\n      throw new Error(`Tried to explain a query when in query-only mode`);\n    }\n    return output;\n  }\n\n  /**\n   * Explain the given query\n   * @param {string | Algebra.Operation} query A query string or algebra.\n   * @param context An optional query context.\n   * @param explainMode The explain mode.\n   * @return {Promise<QueryType | IQueryExplained>} A promise that resolves to\n   *                                                               the query output or explanation.\n   */\n  public async explain<QueryFormatTypeInner extends QueryFormatType>(\n    query: QueryFormatTypeInner,\n    context: QueryContext & QueryFormatTypeInner extends string ? QueryStringContext : QueryAlgebraContext,\n    explainMode: QueryExplainMode,\n  ): Promise<IQueryExplained> {\n    context.explain = explainMode;\n    const output = await this.queryOrExplain(query, context);\n    return <IQueryExplained> output;\n  }\n\n  /**\n   * Evaluate or explain the given query\n   * @param {string | Algebra.Operation} query A query string or algebra.\n   * @param context An optional query context.\n   * @return {Promise<QueryType | IQueryExplained>} A promise that resolves to\n   *                                                               the query output or explanation.\n   */\n  public async queryOrExplain<QueryFormatTypeInner extends QueryFormatType>(\n    query: QueryFormatTypeInner,\n    context?: QueryContext & QueryFormatTypeInner extends string ? QueryStringContext : QueryAlgebraContext,\n  ): Promise<QueryType | IQueryExplained> {\n    context = context || <any>{};\n\n    // Expand shortcuts\n    for (const key in context) {\n      if (this.actorInitQuery.contextKeyShortcuts[key]) {\n        context[this.actorInitQuery.contextKeyShortcuts[key]] = context[key];\n        delete context[key];\n      }\n    }\n\n    // Prepare context\n    let actionContext: IActionContext = new ActionContext(context);\n    let queryFormat: RDF.QueryFormat = { language: 'sparql', version: '1.1' };\n    if (actionContext.has(KeysInitQuery.queryFormat)) {\n      queryFormat = actionContext.get(KeysInitQuery.queryFormat)!;\n      actionContext = actionContext.delete(KeysInitQuery.queryFormat);\n      if (queryFormat.language === 'graphql') {\n        actionContext = actionContext.setDefault(KeysInitQuery.graphqlSingularizeVariables, {});\n      }\n    }\n    const baseIRI: string | undefined = actionContext.get(KeysInitQuery.baseIRI);\n\n    actionContext = actionContext\n      .setDefault(KeysInitQuery.queryTimestamp, new Date())\n      .setDefault(KeysRdfResolveQuadPattern.sourceIds, new Map())\n      // Set the default logger if none is provided\n      .setDefault(KeysCore.log, this.actorInitQuery.logger)\n      .setDefault(KeysInitQuery.functionArgumentsCache, this.defaultFunctionArgumentsCache);\n\n    // Pre-processing the context\n    actionContext = (await this.actorInitQuery.mediatorContextPreprocess.mediate({ context: actionContext })).context;\n\n    // Determine explain mode\n    const explainMode: QueryExplainMode = actionContext.get(KeysInitQuery.explain)!;\n\n    // Parse query\n    let operation: Algebra.Operation;\n    if (typeof query === 'string') {\n      // Save the original query string in the context\n      actionContext = actionContext.set(KeysInitQuery.queryString, query);\n\n      const queryParseOutput = await this.actorInitQuery.mediatorQueryParse\n        .mediate({ context: actionContext, query, queryFormat, baseIRI });\n      operation = queryParseOutput.operation;\n      // Update the baseIRI in the context if the query modified it.\n      if (queryParseOutput.baseIRI) {\n        actionContext = actionContext.set(KeysInitQuery.baseIRI, queryParseOutput.baseIRI);\n      }\n    } else {\n      operation = query;\n    }\n\n    // Print parsed query\n    if (explainMode === 'parsed') {\n      return {\n        explain: true,\n        type: explainMode,\n        data: operation,\n      };\n    }\n\n    // Apply initial bindings in context\n    if (actionContext.has(KeysInitQuery.initialBindings)) {\n      operation = materializeOperation(operation, actionContext.get(KeysInitQuery.initialBindings)!);\n\n      // Delete the query string from the context, since our initial query might have changed\n      actionContext = actionContext.delete(KeysInitQuery.queryString);\n    }\n\n    // Optimize the query operation\n    const mediatorResult = await this.actorInitQuery.mediatorOptimizeQueryOperation\n      .mediate({ context: actionContext, operation });\n    operation = mediatorResult.operation;\n    actionContext = mediatorResult.context || actionContext;\n\n    // Print logical query plan\n    if (explainMode === 'logical') {\n      return {\n        explain: true,\n        type: explainMode,\n        data: operation,\n      };\n    }\n\n    // Save original query in context\n    actionContext = actionContext.set(KeysInitQuery.query, operation);\n\n    // If we need a physical query plan, store a physical query plan logger in the context, and collect it after exec\n    let physicalQueryPlanLogger: IPhysicalQueryPlanLogger | undefined;\n    if (explainMode === 'physical') {\n      physicalQueryPlanLogger = new MemoryPhysicalQueryPlanLogger();\n      actionContext = actionContext.set(KeysInitQuery.physicalQueryPlanLogger, physicalQueryPlanLogger);\n    }\n\n    // Execute query\n    const output = await this.actorInitQuery.mediatorQueryOperation.mediate({\n      context: actionContext,\n      operation,\n    });\n    output.context = actionContext;\n\n    const finalOutput = QueryEngineBase.internalToFinalResult(output);\n\n    // Output physical query plan after query exec if needed\n    if (physicalQueryPlanLogger) {\n      // Make sure the whole result is produced\n      switch (finalOutput.resultType) {\n        case 'bindings':\n          await (await finalOutput.execute()).toArray();\n          break;\n        case 'quads':\n          await (await finalOutput.execute()).toArray();\n          break;\n        case 'boolean':\n          await finalOutput.execute();\n          break;\n        case 'void':\n          await finalOutput.execute();\n          break;\n      }\n\n      return {\n        explain: true,\n        type: explainMode,\n        data: physicalQueryPlanLogger.toJson(),\n      };\n    }\n\n    return finalOutput;\n  }\n\n  /**\n   * @param context An optional context.\n   * @return {Promise<{[p: string]: number}>} All available SPARQL (weighted) result media types.\n   */\n  public async getResultMediaTypes(context?: any): Promise<Record<string, number>> {\n    context = ActionContext.ensureActionContext(context);\n    return (await this.actorInitQuery.mediatorQueryResultSerializeMediaTypeCombiner\n      .mediate({ context, mediaTypes: true })).mediaTypes;\n  }\n\n  /**\n   * @param context An optional context.\n   * @return {Promise<{[p: string]: number}>} All available SPARQL result media type formats.\n   */\n  public async getResultMediaTypeFormats(context?: any): Promise<Record<string, string>> {\n    context = ActionContext.ensureActionContext(context);\n    return (await this.actorInitQuery.mediatorQueryResultSerializeMediaTypeFormatCombiner\n      .mediate({ context, mediaTypeFormats: true })).mediaTypeFormats;\n  }\n\n  /**\n   * Convert a query result to a string stream based on a certain media type.\n   * @param {IQueryOperationResult} queryResult A query result.\n   * @param {string} mediaType A media type.\n   * @param {ActionContext} context An optional context.\n   * @return {Promise<IActorQueryResultSerializeOutput>} A text stream.\n   */\n  public async resultToString(queryResult: RDF.Query<any>, mediaType?: string, context?: any):\n  Promise<IActorQueryResultSerializeOutput> {\n    context = ActionContext.ensureActionContext(context);\n    if (!mediaType) {\n      switch (queryResult.resultType) {\n        case 'bindings':\n          mediaType = 'application/json';\n          break;\n        case 'quads':\n          mediaType = 'application/trig';\n          break;\n        default:\n          mediaType = 'simple';\n          break;\n      }\n    }\n    const handle: IActionSparqlSerialize = { ...await QueryEngineBase.finalToInternalResult(queryResult), context };\n    return (await this.actorInitQuery.mediatorQueryResultSerialize\n      .mediate({ context, handle, handleMediaType: mediaType })).handle;\n  }\n\n  /**\n   * Invalidate all internal caches related to the given page URL.\n   * If no page URL is given, then all pages will be invalidated.\n   * @param {string} url The page URL to invalidate.\n   * @param context An optional ActionContext to pass to the actors.\n   * @return {Promise<any>} A promise resolving when the caches have been invalidated.\n   */\n  public invalidateHttpCache(url?: string, context?: any): Promise<any> {\n    context = ActionContext.ensureActionContext(context);\n    return this.actorInitQuery.mediatorHttpInvalidate.mediate({ url, context });\n  }\n\n  /**\n   * Convert an internal query result to a final one.\n   * @param internalResult An intermediary query result.\n   */\n  public static internalToFinalResult(internalResult: IQueryOperationResult): QueryType {\n    switch (internalResult.type) {\n      case 'bindings':\n        return {\n          resultType: 'bindings',\n          execute: async() => internalResult.bindingsStream,\n          metadata: async() => <any> await internalResult.metadata(),\n          context: internalResult.context,\n        };\n      case 'quads':\n        return {\n          resultType: 'quads',\n          execute: async() => internalResult.quadStream,\n          metadata: async() => <any> await internalResult.metadata(),\n          context: internalResult.context,\n        };\n      case 'boolean':\n        return {\n          resultType: 'boolean',\n          execute: async() => internalResult.execute(),\n          context: internalResult.context,\n        };\n      case 'void':\n        return {\n          resultType: 'void',\n          execute: async() => internalResult.execute(),\n          context: internalResult.context,\n        };\n    }\n  }\n\n  /**\n   * Convert a final query result to an internal one.\n   * @param finalResult A final query result.\n   */\n  public static async finalToInternalResult(finalResult: RDF.Query<any>): Promise<IQueryOperationResult> {\n    switch (finalResult.resultType) {\n      case 'bindings':\n        return {\n          type: 'bindings',\n          bindingsStream: <BindingsStream> await finalResult.execute(),\n          metadata: async() => <any> await finalResult.metadata(),\n        };\n      case 'quads':\n        return {\n          type: 'quads',\n          quadStream: <AsyncIterator<RDF.Quad>> await finalResult.execute(),\n          metadata: async() => <any> await finalResult.metadata(),\n        };\n      case 'boolean':\n        return {\n          type: 'boolean',\n          execute: () => finalResult.execute(),\n        };\n      case 'void':\n        return {\n          type: 'void',\n          execute: () => finalResult.execute(),\n        };\n    }\n  }\n}\n"]}