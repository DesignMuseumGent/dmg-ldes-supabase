{"version":3,"file":"HttpServiceSparqlEndpoint.js","sourceRoot":"","sources":["HttpServiceSparqlEndpoint.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable import/no-nodejs-modules */\nimport * as cluster from 'cluster';\nimport type { EventEmitter } from 'events';\nimport * as http from 'http';\nimport type { IncomingMessage, ServerResponse } from 'http';\nimport * as querystring from 'querystring';\nimport type { Writable } from 'stream';\nimport * as url from 'url';\nimport { KeysQueryOperation } from '@comunica/context-entries';\nimport { ActionContext } from '@comunica/core';\nimport type { ICliArgsHandler, QueryQuads, QueryType } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { ArrayIterator } from 'asynciterator';\nimport yargs from 'yargs';\n// eslint-disable-next-line import/no-useless-path-segments\nimport { QueryEngineBase, QueryEngineFactoryBase } from '..';\n// eslint-disable-next-line import/no-useless-path-segments\nimport type { IDynamicQueryEngineOptions } from '..';\nimport { CliArgsHandlerBase } from './cli/CliArgsHandlerBase';\nimport { CliArgsHandlerHttp } from './cli/CliArgsHandlerHttp';\n\nconst quad = require('rdf-quad');\n\n/**\n * An HTTP service that exposes a Comunica engine as a SPARQL endpoint.\n */\nexport class HttpServiceSparqlEndpoint {\n  public static readonly MIME_PLAIN = 'text/plain';\n  public static readonly MIME_JSON = 'application/json';\n\n  public readonly engine: Promise<QueryEngineBase>;\n\n  public readonly context: any;\n  public readonly timeout: number;\n  public readonly port: number;\n  public readonly workers: number;\n\n  public readonly invalidateCacheBeforeQuery: boolean;\n  public readonly freshWorkerPerQuery: boolean;\n  public readonly contextOverride: boolean;\n\n  public lastQueryId = 0;\n\n  public constructor(args: IHttpServiceSparqlEndpointArgs) {\n    this.context = args.context || {};\n    this.timeout = args.timeout ?? 60_000;\n    this.port = args.port ?? 3_000;\n    this.workers = args.workers ?? 1;\n    this.invalidateCacheBeforeQuery = Boolean(args.invalidateCacheBeforeQuery);\n    this.freshWorkerPerQuery = Boolean(args.freshWorkerPerQuery);\n    this.contextOverride = Boolean(args.contextOverride);\n\n    this.engine = new QueryEngineFactoryBase(\n      args.moduleRootPath,\n      args.defaultConfigPath,\n      actorInitQuery => new QueryEngineBase(actorInitQuery),\n    ).create(args);\n  }\n\n  /**\n   * Starts the server\n   * @param {string[]} argv The commandline arguments that the script was called with\n   * @param {module:stream.internal.Writable} stdout The output stream to log to.\n   * @param {module:stream.internal.Writable} stderr The error stream to log errors to.\n   * @param {string} moduleRootPath The path to the invoking module.\n   * @param {NodeJS.ProcessEnv} env The process env to get constants from.\n   * @param {string} defaultConfigPath The path to get the config from if none is defined in the environment.\n   * @param {(code: number) => void} exit The callback to invoke to stop the script.\n   * @param {ICliArgsHandler[]} cliArgsHandlers Enables manipulation of the CLI arguments and their processing.\n   * @return {Promise<void>} A promise that resolves when the server has been started.\n   */\n  public static async runArgsInProcess<Q>(\n    argv: string[],\n    stdout: Writable,\n    stderr: Writable,\n    moduleRootPath: string,\n    env: NodeJS.ProcessEnv,\n    defaultConfigPath: string,\n    exit: (code: number) => void,\n    cliArgsHandlers: ICliArgsHandler[] = [],\n  ): Promise<void> {\n    const options = await HttpServiceSparqlEndpoint\n      .generateConstructorArguments(argv, moduleRootPath, env, defaultConfigPath, stderr, exit, cliArgsHandlers);\n\n    return new Promise<void>(resolve => {\n      new HttpServiceSparqlEndpoint(options || {}).run(stdout, stderr)\n        .then(resolve)\n        .catch(error => {\n          stderr.write(error);\n          exit(1);\n          resolve();\n        });\n    });\n  }\n\n  /**\n   * Takes parsed commandline arguments and turns them into an object used in the HttpServiceSparqlEndpoint constructor\n   * @param {args: minimist.ParsedArgs} args The commandline arguments that the script was called with\n   * @param {string} moduleRootPath The path to the invoking module.\n   * @param {NodeJS.ProcessEnv} env The process env to get constants from.\n   * @param {string} defaultConfigPath The path to get the config from if none is defined in the environment.\n   * @param {ICliArgsHandler[]} cliArgsHandlers Enables manipulation of the CLI arguments and their processing.\n   */\n  public static async generateConstructorArguments(argv: string[], moduleRootPath: string,\n    env: NodeJS.ProcessEnv, defaultConfigPath: string, stderr: Writable,\n    exit: (code: number) => void, cliArgsHandlers: ICliArgsHandler[]): Promise<IHttpServiceSparqlEndpointArgs> {\n    // Populate yargs arguments object\n    cliArgsHandlers = [\n      new CliArgsHandlerBase(),\n      new CliArgsHandlerHttp(),\n      ...cliArgsHandlers,\n    ];\n    let argumentsBuilder = yargs({});\n    for (const cliArgsHandler of cliArgsHandlers) {\n      argumentsBuilder = cliArgsHandler.populateYargs(argumentsBuilder);\n    }\n\n    // Extract raw argument values from parsed yargs object, so that we can handle each of them hereafter\n    let args: Record<string, any>;\n    try {\n      args = await argumentsBuilder.parse(argv);\n    } catch (error: unknown) {\n      stderr.write(`${await argumentsBuilder.getHelp()}\\n\\n${(<Error> error).message}\\n`);\n      return exit(1)!;\n    }\n\n    // Invoke args handlers to process any remaining args\n    const context: Record<string, any> = {};\n    try {\n      for (const cliArgsHandler of cliArgsHandlers) {\n        await cliArgsHandler.handleArgs(args, context);\n      }\n    } catch (error: unknown) {\n      stderr.write(`${(<Error>error).message}/n`);\n      exit(1);\n    }\n\n    const invalidateCacheBeforeQuery: boolean = args.invalidateCache;\n    const freshWorkerPerQuery: boolean = args.freshWorker;\n    const contextOverride: boolean = args.contextOverride;\n    const port = args.port;\n    const timeout = args.timeout * 1_000;\n    const workers = args.workers;\n    context[KeysQueryOperation.readOnly.name] = !args.u;\n\n    const configPath = env.COMUNICA_CONFIG ? env.COMUNICA_CONFIG : defaultConfigPath;\n\n    return {\n      defaultConfigPath,\n      configPath,\n      context,\n      invalidateCacheBeforeQuery,\n      freshWorkerPerQuery,\n      contextOverride,\n      moduleRootPath,\n      mainModulePath: moduleRootPath,\n      port,\n      timeout,\n      workers,\n    };\n  }\n\n  /**\n   * Start the HTTP service.\n   * @param {module:stream.internal.Writable} stdout The output stream to log to.\n   * @param {module:stream.internal.Writable} stderr The error stream to log errors to.\n   */\n  public run(stdout: Writable, stderr: Writable): Promise<void> {\n    if (cluster.isMaster) {\n      return this.runMaster(stdout, stderr);\n    }\n    return this.runWorker(stdout, stderr);\n  }\n\n  /**\n   * Start the HTTP service as master.\n   * @param {module:stream.internal.Writable} stdout The output stream to log to.\n   * @param {module:stream.internal.Writable} stderr The error stream to log errors to.\n   */\n  public async runMaster(stdout: Writable, stderr: Writable): Promise<void> {\n    stderr.write(`Server running on http://localhost:${this.port}/sparql\\n`);\n\n    // Create workers\n    for (let i = 0; i < this.workers; i++) {\n      cluster.fork();\n    }\n\n    // Attach listeners to each new worker\n    cluster.on('listening', worker => {\n      // Respawn crashed workers\n      worker.once('exit', (code, signal) => {\n        if (!worker.exitedAfterDisconnect) {\n          if (code === 9 || signal === 'SIGKILL') {\n            stderr.write(`Worker ${worker.process.pid} forcefully killed with ${code || signal}. Killing main process as well.\\n`);\n            cluster.disconnect();\n          } else {\n            stderr.write(`Worker ${worker.process.pid} died with ${code || signal}. Starting new worker.\\n`);\n            cluster.fork();\n          }\n        }\n      });\n\n      // Handle worker timeouts\n      const workerTimeouts: Record<number, NodeJS.Timeout> = {};\n      worker.on('message', ({ type, queryId }) => {\n        if (type === 'start') {\n          stderr.write(`Worker ${worker.process.pid} got assigned a new query (${queryId}).\\n`);\n          workerTimeouts[queryId] = setTimeout(() => {\n            try {\n              if (worker.isConnected()) {\n                stderr.write(`Worker ${worker.process.pid} timed out for query ${queryId}.\\n`);\n                worker.send('shutdown');\n              }\n            } catch (error: unknown) {\n              stderr.write(`Unable to timeout worker ${worker.process.pid}: ${(<Error> error).message}.\\n`);\n            }\n            delete workerTimeouts[queryId];\n          }, this.timeout);\n        } else if (type === 'end' && workerTimeouts[queryId]) {\n          stderr.write(`Worker ${worker.process.pid} has completed query ${queryId}.\\n`);\n          clearTimeout(workerTimeouts[queryId]);\n          delete workerTimeouts[queryId];\n        }\n      });\n    });\n\n    // Disconnect from cluster on SIGINT, so that the process can cleanly terminate\n    process.once('SIGINT', () => {\n      cluster.disconnect();\n    });\n  }\n\n  /**\n   * Start the HTTP service as worker.\n   * @param {module:stream.internal.Writable} stdout The output stream to log to.\n   * @param {module:stream.internal.Writable} stderr The error stream to log errors to.\n   */\n  public async runWorker(stdout: Writable, stderr: Writable): Promise<void> {\n    const engine: QueryEngineBase = await this.engine;\n\n    // Determine the allowed media types for requests\n    const mediaTypes: Record<string, number> = await engine.getResultMediaTypes();\n    const variants: { type: string; quality: number }[] = [];\n    for (const type of Object.keys(mediaTypes)) {\n      variants.push({ type, quality: mediaTypes[type] });\n    }\n\n    // Start the server\n    const server = http.createServer(this.handleRequest.bind(this, engine, variants, stdout, stderr));\n    server.listen(this.port);\n    stderr.write(`Server worker (${process.pid}) running on http://localhost:${this.port}/sparql\\n`);\n\n    // Keep track of all open connections\n    const openConnections: Set<ServerResponse> = new Set();\n    server.on('request', (request: IncomingMessage, response: ServerResponse) => {\n      openConnections.add(response);\n      response.on('close', () => {\n        openConnections.delete(response);\n      });\n    });\n\n    // Subscribe to shutdown messages\n    process.on('message', async(message: string): Promise<void> => {\n      if (message === 'shutdown') {\n        stderr.write(`Shutting down worker ${process.pid} with ${openConnections.size} open connections.\\n`);\n\n        // Stop new connections from being accepted\n        server.close();\n\n        // Close all open connections\n        for (const connection of openConnections) {\n          await new Promise<void>(resolve => connection.end('!TIMEDOUT!', resolve));\n        }\n\n        // Kill the worker once the connections have been closed\n        process.exit(15);\n      }\n    });\n\n    // Catch global errors, and cleanly close open connections\n    process.on('uncaughtException', async error => {\n      stderr.write(`Terminating worker ${process.pid} with ${openConnections.size} open connections due to uncaught exception.\\n`);\n      stderr.write(error.stack);\n\n      // Stop new connections from being accepted\n      server.close();\n\n      // Close all open connections\n      for (const connection of openConnections) {\n        await new Promise<void>(resolve => connection.end('!ERROR!', resolve));\n      }\n\n      // Kill the worker once the connections have been closed\n      process.exit(15);\n    });\n  }\n\n  /**\n   * Handles an HTTP request.\n   * @param {QueryEngineBase} engine A SPARQL engine.\n   * @param {{type: string; quality: number}[]} variants Allowed variants.\n   * @param {module:stream.internal.Writable} stdout Output stream.\n   * @param {module:stream.internal.Writable} stderr Error output stream.\n   * @param {module:http.IncomingMessage} request Request object.\n   * @param {module:http.ServerResponse} response Response object.\n   */\n  public async handleRequest(\n    engine: QueryEngineBase,\n    variants: { type: string; quality: number }[],\n    stdout: Writable,\n    stderr: Writable,\n    request: http.IncomingMessage,\n    response: http.ServerResponse,\n  ): Promise<void> {\n    const negotiated = require('negotiate').choose(variants, request)\n      .sort((first: any, second: any) => second.qts - first.qts);\n    const variant: any = request.headers.accept ? negotiated[0] : null;\n    // Require qts strictly larger than 2, as 1 and 2 respectively allow * and */* matching.\n    // For qts 0, 1, and 2, we fallback to our built-in media type defaults, for which we pass null.\n    const mediaType: string = variant && variant.qts > 2 ? variant.type : null;\n\n    // Verify the path\n    const requestUrl = url.parse(request.url ?? '', true);\n    if (requestUrl.pathname === '/' || request.url === '/') {\n      stdout.write('[301] Permanently moved. Redirected to /sparql.');\n      response.writeHead(301,\n        { 'content-type': HttpServiceSparqlEndpoint.MIME_JSON,\n          'Access-Control-Allow-Origin': '*',\n          Location: `http://localhost:${this.port}/sparql${requestUrl.search || ''}` });\n      response.end(JSON.stringify({ message: 'Queries are accepted on /sparql. Redirected.' }));\n      return;\n    }\n    if (requestUrl.pathname !== '/sparql') {\n      stdout.write('[404] Resource not found. Queries are accepted on /sparql.\\n');\n      response.writeHead(404,\n        { 'content-type': HttpServiceSparqlEndpoint.MIME_JSON,\n          'Access-Control-Allow-Origin': '*' });\n      response.end(JSON.stringify({ message: 'Resource not found. Queries are accepted on /sparql.' }));\n      return;\n    }\n\n    if (this.invalidateCacheBeforeQuery) {\n      // Invalidate cache\n      await engine.invalidateHttpCache();\n    }\n\n    // Parse the query, depending on the HTTP method\n    let queryBody: IQueryBody | undefined;\n    switch (request.method) {\n      case 'POST':\n        queryBody = await this.parseBody(request);\n        await this.writeQueryResult(\n          engine,\n          stdout,\n          stderr,\n          request,\n          response,\n          queryBody,\n          mediaType,\n          false,\n          false,\n          this.lastQueryId++,\n        );\n        break;\n      case 'HEAD':\n      case 'GET':\n        // eslint-disable-next-line no-case-declarations\n        const queryValue = <string> requestUrl.query.query;\n        queryBody = queryValue ? { type: 'query', value: queryValue, context: undefined } : undefined;\n        // eslint-disable-next-line no-case-declarations\n        const headOnly = request.method === 'HEAD';\n        await this.writeQueryResult(\n          engine,\n          stdout,\n          stderr,\n          request,\n          response,\n          queryBody,\n          mediaType,\n          headOnly,\n          true,\n          this.lastQueryId++,\n        );\n        break;\n      default:\n        stdout.write(`[405] ${request.method} to ${request.url}\\n`);\n        response.writeHead(405,\n          { 'content-type': HttpServiceSparqlEndpoint.MIME_JSON, 'Access-Control-Allow-Origin': '*' });\n        response.end(JSON.stringify({ message: 'Incorrect HTTP method' }));\n    }\n  }\n\n  /**\n   * Writes the result of the given SPARQL query.\n   * @param {QueryEngineBase} engine A SPARQL engine.\n   * @param {module:stream.internal.Writable} stdout Output stream.\n   * @param {module:stream.internal.Writable} stderr Error output stream.\n   * @param {module:http.IncomingMessage} request Request object.\n   * @param {module:http.ServerResponse} response Response object.\n   * @param {IQueryBody | undefined} queryBody The query body.\n   * @param {string} mediaType The requested response media type.\n   * @param {boolean} headOnly If only the header should be written.\n   * @param {boolean} readOnly If only data can be read, but not updated. (i.e., if we're in a GET request)\n   * @param queryId The unique id of this query.\n   */\n  public async writeQueryResult(\n    engine: QueryEngineBase,\n    stdout: Writable,\n    stderr: Writable,\n    request: http.IncomingMessage,\n    response: http.ServerResponse,\n    queryBody: IQueryBody | undefined,\n    mediaType: string,\n    headOnly: boolean,\n    readOnly: boolean,\n    queryId: number,\n  ): Promise<void> {\n    if (!queryBody || !queryBody.value) {\n      return this.writeServiceDescription(engine, stdout, stderr, request, response, mediaType, headOnly);\n    }\n\n    // Log the start of the query execution\n    stdout.write(`[200] ${request.method} to ${request.url}\\n`);\n    stdout.write(`      Requested media type: ${mediaType}\\n`);\n    stdout.write(`      Received ${queryBody.type} query: ${queryBody.value}\\n`);\n\n    // Send message to master process to indicate the start of an execution\n    process.send!({ type: 'start', queryId });\n\n    // Determine context\n    let context = {\n      ...this.context,\n      ...this.contextOverride ? queryBody.context : undefined,\n    };\n    if (readOnly) {\n      context = { ...context, [KeysQueryOperation.readOnly.name]: readOnly };\n    }\n\n    let result: QueryType;\n    try {\n      result = await engine.query(queryBody.value, context);\n\n      // For update queries, also await the result\n      if (result.resultType === 'void') {\n        await result.execute();\n      }\n    } catch (error: unknown) {\n      stdout.write('[400] Bad request\\n');\n      response.writeHead(400,\n        { 'content-type': HttpServiceSparqlEndpoint.MIME_PLAIN, 'Access-Control-Allow-Origin': '*' });\n      response.end((<Error> error).message);\n      return;\n    }\n\n    // Default to SPARQL JSON for bindings and boolean\n    if (!mediaType) {\n      switch (result.resultType) {\n        case 'quads':\n          mediaType = 'application/trig';\n          break;\n        case 'void':\n          mediaType = 'simple';\n          break;\n        default:\n          mediaType = 'application/sparql-results+json';\n          break;\n      }\n    }\n\n    // Write header of response\n    response.writeHead(200, { 'content-type': mediaType, 'Access-Control-Allow-Origin': '*' });\n    stdout.write(`      Resolved to result media type: ${mediaType}\\n`);\n\n    // Stop further processing for HEAD requests\n    if (headOnly) {\n      response.end();\n      return;\n    }\n\n    let eventEmitter: EventEmitter | undefined;\n    try {\n      const { data } = await engine.resultToString(result, mediaType);\n      data.on('error', (error: Error) => {\n        stdout.write(`[500] Server error in results: ${error.message} \\n`);\n        if (!response.writableEnded) {\n          response.end('An internal server error occurred.\\n');\n        }\n      });\n      data.pipe(response);\n      eventEmitter = data;\n    } catch {\n      stdout.write('[400] Bad request, invalid media type\\n');\n      response.writeHead(400,\n        { 'content-type': HttpServiceSparqlEndpoint.MIME_PLAIN, 'Access-Control-Allow-Origin': '*' });\n      response.end('The response for the given query could not be serialized for the requested media type\\n');\n    }\n\n    // Send message to master process to indicate the end of an execution\n    response.on('close', () => {\n      process.send!({ type: 'end', queryId });\n    });\n\n    this.stopResponse(response, queryId, eventEmitter);\n  }\n\n  public async writeServiceDescription(\n    engine: QueryEngineBase,\n    stdout: Writable,\n    stderr: Writable,\n    request: http.IncomingMessage,\n    response: http.ServerResponse,\n    mediaType: string,\n    headOnly: boolean,\n  ): Promise<void> {\n    stdout.write(`[200] ${request.method} to ${request.url}\\n`);\n    stdout.write(`      Requested media type: ${mediaType}\\n`);\n    stdout.write('      Received query for service description.\\n');\n    response.writeHead(200, { 'content-type': mediaType, 'Access-Control-Allow-Origin': '*' });\n\n    if (headOnly) {\n      response.end();\n      return;\n    }\n\n    // eslint-disable-next-line id-length\n    const s = request.url;\n    const sd = 'http://www.w3.org/ns/sparql-service-description#';\n    const quads: RDF.Quad[] = [\n      // Basic metadata\n      quad(s, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type', `${sd}Service`),\n      quad(s, `${sd}endpoint`, '/sparql'),\n      quad(s, `${sd}url`, '/sparql'),\n\n      // Features\n      quad(s, `${sd}feature`, `${sd}BasicFederatedQuery`),\n      quad(s, `${sd}supportedLanguage`, `${sd}SPARQL10Query`),\n      quad(s, `${sd}supportedLanguage`, `${sd}SPARQL11Query`),\n    ];\n\n    let eventEmitter: EventEmitter;\n    try {\n      // Append result formats\n      const formats = await engine.getResultMediaTypeFormats(new ActionContext(this.context));\n      for (const format in formats) {\n        quads.push(quad(s, `${sd}resultFormat`, formats[format]));\n      }\n\n      // Flush results\n      const { data } = await engine.resultToString(<QueryQuads> {\n        resultType: 'quads',\n        execute: async() => new ArrayIterator(quads),\n        metadata: <any> undefined,\n      }, mediaType);\n      data.on('error', (error: Error) => {\n        stdout.write(`[500] Server error in results: ${error.message} \\n`);\n        response.end('An internal server error occurred.\\n');\n      });\n      data.pipe(response);\n      eventEmitter = data;\n    } catch {\n      stdout.write('[400] Bad request, invalid media type\\n');\n      response.writeHead(400,\n        { 'content-type': HttpServiceSparqlEndpoint.MIME_PLAIN, 'Access-Control-Allow-Origin': '*' });\n      response.end('The response for the given query could not be serialized for the requested media type\\n');\n      return;\n    }\n    this.stopResponse(response, 0, eventEmitter);\n  }\n\n  /**\n   * Stop after timeout or if the connection is terminated\n   * @param {module:http.ServerResponse} response Response object.\n   * @param queryId The unique query id.\n   * @param {NodeJS.ReadableStream} eventEmitter Query result stream.\n   */\n  public stopResponse(response: http.ServerResponse, queryId: number, eventEmitter?: EventEmitter): void {\n    response.on('close', killClient);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this\n    const self = this;\n    function killClient(): void {\n      if (eventEmitter) {\n        // Remove all listeners so we are sure no more write calls are made\n        eventEmitter.removeAllListeners();\n        eventEmitter.on('error', () => {\n          // Void any errors that may still occur\n        });\n        eventEmitter.emit('end');\n      }\n      try {\n        response.end();\n      } catch {\n        // Do nothing\n      }\n\n      // Kill the worker if we want fresh workers per query\n      if (self.freshWorkerPerQuery) {\n        process.stderr.write(`Killing fresh worker ${process.pid} after query ${queryId}.\\n`);\n        // eslint-disable-next-line unicorn/no-process-exit\n        process.exit(15);\n      }\n    }\n  }\n\n  /**\n   * Parses the body of a SPARQL POST request\n   * @param {module:http.IncomingMessage} request Request object.\n   * @return {Promise<IQueryBody>} A promise resolving to a query body object.\n   */\n  public parseBody(request: http.IncomingMessage): Promise<IQueryBody> {\n    return new Promise((resolve, reject) => {\n      let body = '';\n      request.setEncoding('utf8');\n      request.on('error', reject);\n      request.on('data', chunk => {\n        body += chunk;\n      });\n      request.on('end', () => {\n        const contentType: string | undefined = request.headers['content-type'];\n        if (contentType) {\n          if (contentType.includes('application/sparql-query')) {\n            return resolve({ type: 'query', value: body, context: undefined });\n          }\n          if (contentType.includes('application/sparql-update')) {\n            return resolve({ type: 'void', value: body, context: undefined });\n          }\n          if (contentType.includes('application/x-www-form-urlencoded')) {\n            const bodyStructure = querystring.parse(body);\n            let context: Record<string, any> | undefined;\n            if (bodyStructure.context) {\n              try {\n                context = JSON.parse(<string>bodyStructure.context);\n              } catch (error: unknown) {\n                reject(new Error(`Invalid POST body with context received ('${bodyStructure.context}'): ${(<Error> error).message}`));\n              }\n            }\n            if (bodyStructure.query) {\n              return resolve({ type: 'query', value: <string> bodyStructure.query, context });\n            }\n            if (bodyStructure.update) {\n              return resolve({ type: 'void', value: <string> bodyStructure.update, context });\n            }\n          }\n        }\n        reject(new Error(`Invalid POST body received, query type could not be determined`));\n      });\n    });\n  }\n}\n\nexport interface IQueryBody {\n  type: 'query' | 'void';\n  value: string;\n  context: Record<string, any> | undefined;\n}\n\nexport interface IHttpServiceSparqlEndpointArgs extends IDynamicQueryEngineOptions {\n  context?: any;\n  timeout?: number;\n  port?: number;\n  workers?: number;\n  invalidateCacheBeforeQuery?: boolean;\n  freshWorkerPerQuery?: boolean;\n  contextOverride?: boolean;\n  moduleRootPath: string;\n  defaultConfigPath: string;\n}\n/* eslint-enable import/no-nodejs-modules */\n"]}