{"version":3,"file":"ActorRdfJoin.js","sourceRoot":"","sources":["ActorRdfJoin.ts"],"names":[],"mappings":"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","sourcesContent":["import { ActorQueryOperation } from '@comunica/bus-query-operation';\nimport type {\n  MediatorRdfJoinSelectivity,\n} from '@comunica/bus-rdf-join-selectivity';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { IAction, IActorArgs, Mediate } from '@comunica/core';\nimport { Actor } from '@comunica/core';\nimport type { IMediatorTypeJoinCoefficients } from '@comunica/mediatortype-join-coefficients';\nimport type {\n  IQueryOperationResultBindings, MetadataBindings,\n  IPhysicalQueryPlanLogger, Bindings, IActionContext, IJoinEntry, IJoinEntryWithMetadata,\n} from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport { termToString } from 'rdf-string';\n\nconst DF = new DataFactory();\n\n/**\n * A comunica actor for joining 2 binding streams.\n *\n * Actor types:\n * * Input:  IActionRdfJoin:                The streams that need to be joined.\n * * Test:   IMediatorTypeJoinCoefficients: Join coefficients.\n * * Output: IActorRdfJoinOutput:           The resulting joined stream.\n *\n * @see IActionRdfJoin\n * @see IActorQueryOperationOutput\n */\nexport abstract class ActorRdfJoin\n  extends Actor<IActionRdfJoin, IMediatorTypeJoinCoefficients, IQueryOperationResultBindings> {\n  public readonly mediatorJoinSelectivity: MediatorRdfJoinSelectivity;\n\n  /**\n   * If this actor will be logged in the debugger and physical query plan logger\n   */\n  public includeInLogs = true;\n  public readonly logicalType: LogicalJoinType;\n  public readonly physicalName: string;\n  /**\n   * Can be used by subclasses to indicate the max or min number of streams that can be joined.\n   * 0 for infinity.\n   * By default, this indicates the max number, but can be inverted by setting limitEntriesMin to true.\n   */\n  protected readonly limitEntries: number;\n  /**\n   * If true, the limitEntries field is a lower limit,\n   * otherwise, it is an upper limit.\n   */\n  protected readonly limitEntriesMin: boolean;\n  /**\n   * If this actor can handle undefs in the bindings.\n   */\n  protected readonly canHandleUndefs: boolean;\n\n  /**\n   * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus\n   * @param options - Actor-specific join options.\n   */\n  public constructor(args: IActorRdfJoinArgs, options: IActorRdfJoinInternalOptions) {\n    super(args);\n    this.logicalType = options.logicalType;\n    this.physicalName = options.physicalName;\n    this.limitEntries = options.limitEntries ?? Number.POSITIVE_INFINITY;\n    this.limitEntriesMin = options.limitEntriesMin ?? false;\n    this.canHandleUndefs = options.canHandleUndefs ?? false;\n  }\n\n  /**\n   * Creates a hash of the given bindings by concatenating the results of the given variables.\n   * This function will not sort the variables and expects them to be in the same order for every call.\n   * @param {Bindings} bindings\n   * @param {string[]} variables\n   * @returns {string}\n   */\n  public static hash(bindings: Bindings, variables: RDF.Variable[]): string {\n    return variables\n      .filter(variable => bindings.has(variable))\n      .map(variable => termToString(bindings.get(variable)))\n      .join('');\n  }\n\n  /**\n   * Returns an array containing all the variable names that occur in all bindings streams.\n   * @param {MetadataBindings[]} metadatas An array of optional metadata objects for the entries.\n   * @returns {string[]}\n   */\n  public static overlappingVariables(metadatas: MetadataBindings[]): RDF.Variable[] {\n    const variables = metadatas.map(metadata => metadata.variables);\n    let baseArray = variables[0];\n    for (const array of variables.slice(1)) {\n      baseArray = baseArray.filter(el => array.some(value => value.value === el.value));\n    }\n    return baseArray;\n  }\n\n  /**\n   * Returns the variables that will occur in the joined bindings.\n   * @param {MetadataBindings[]} metadatas An array of metadata objects for the entries.\n   * @returns {string[]}\n   */\n  public static joinVariables(metadatas: MetadataBindings[]): RDF.Variable[] {\n    return [ ...new Set(metadatas.flatMap(metadata => metadata.variables.map(variable => variable.value))) ]\n      .map(variable => DF.variable(variable));\n  }\n\n  /**\n   * Returns the result of joining bindings, or `null` if no join is possible.\n   * @param {Bindings[]} bindings\n   * @returns {Bindings}\n   */\n  public static joinBindings(...bindings: Bindings[]): Bindings | null {\n    if (bindings.length === 0) {\n      return null;\n    }\n    if (bindings.length === 1) {\n      return bindings[0];\n    }\n\n    let acc: Bindings = bindings[0];\n    for (const binding of bindings.slice(1)) {\n      const merged = acc.merge(binding);\n      if (!merged) {\n        return null;\n      }\n      acc = merged;\n    }\n    return acc;\n  }\n\n  /**\n   * Get the estimated number of items from the given metadata.\n   * @param {Record<string, any>} metadata A metadata object.\n   * @return {number} The estimated number of items, or `Infinity` if cardinality is falsy.\n   */\n  public static getCardinality(metadata: MetadataBindings): RDF.QueryResultCardinality {\n    return metadata.cardinality;\n  }\n\n  /**\n   * Obtain the metadata from all given join entries.\n   * @param entries Join entries.\n   */\n  public static async getMetadatas(entries: IJoinEntry[]): Promise<MetadataBindings[]> {\n    return await Promise.all(entries.map(entry => entry.output.metadata()));\n  }\n\n  /**\n   * Obtain the join entries witt metadata from all given join entries.\n   * @param entries Join entries.\n   */\n  public static async getEntriesWithMetadatas(entries: IJoinEntry[]): Promise<IJoinEntryWithMetadata[]> {\n    const metadatas = await ActorRdfJoin.getMetadatas(entries);\n    return entries.map((entry, i) => ({ ...entry, metadata: metadatas[i] }));\n  }\n\n  /**\n   * Calculate the time to initiate a request for the given metadata entries.\n   * @param metadatas An array of checked metadata.\n   */\n  public static getRequestInitialTimes(metadatas: MetadataBindings[]): number[] {\n    return metadatas.map(metadata => metadata.pageSize ? 0 : metadata.requestTime || 0);\n  }\n\n  /**\n   * Calculate the time to receive a single item for the given metadata entries.\n   * @param metadatas An array of checked metadata.\n   */\n  public static getRequestItemTimes(metadatas: MetadataBindings[]): number[] {\n    return metadatas\n      .map(metadata => !metadata.pageSize ? 0 : (metadata.requestTime || 0) / metadata.pageSize);\n  }\n\n  /**\n   * Helper function to create a new metadata object for the join result.\n   * For required metadata entries that are not provided, sane defaults are calculated.\n   * @param entries Join entries.\n   * @param metadatas Metadata of the join entries.\n   * @param context The action context.\n   * @param partialMetadata Partial metadata entries.\n   */\n  public async constructResultMetadata(\n    entries: IJoinEntry[],\n    metadatas: MetadataBindings[],\n    context: IActionContext,\n    partialMetadata: Partial<MetadataBindings> = {},\n  ): Promise<MetadataBindings> {\n    let cardinalityJoined: RDF.QueryResultCardinality;\n    if (partialMetadata.cardinality) {\n      cardinalityJoined = partialMetadata.cardinality;\n    } else {\n      cardinalityJoined = metadatas\n        .reduce((acc: RDF.QueryResultCardinality, metadata) => {\n          const cardinalityThis = ActorRdfJoin.getCardinality(metadata);\n          return {\n            type: cardinalityThis.type === 'estimate' ? 'estimate' : acc.type,\n            value: acc.value * cardinalityThis.value,\n          };\n        }, { type: 'exact', value: 1 });\n      cardinalityJoined.value *= (await this.mediatorJoinSelectivity.mediate({ entries, context })).selectivity;\n    }\n\n    return {\n      ...partialMetadata,\n      cardinality: {\n        type: cardinalityJoined.type,\n        value: cardinalityJoined.value,\n      },\n      canContainUndefs: partialMetadata.canContainUndefs ?? metadatas.some(metadata => metadata.canContainUndefs),\n      variables: ActorRdfJoin.joinVariables(metadatas),\n    };\n  }\n\n  /**\n   * Default test function for join actors.\n   * Checks whether all iterators have metadata.\n   * If yes: call the abstract getIterations method, if not: return Infinity.\n   * @param {IActionRdfJoin} action The input action containing the relevant iterators\n   * @returns {Promise<IMediatorTypeJoinCoefficients>} The join coefficients.\n   */\n  public async test(action: IActionRdfJoin): Promise<IMediatorTypeJoinCoefficients> {\n    // Validate logical join type\n    if (action.type !== this.logicalType) {\n      throw new Error(`${this.name} can only handle logical joins of type '${this.logicalType}', while '${action.type}' was given.`);\n    }\n\n    // Don't allow joining of one or zero streams\n    if (action.entries.length <= 1) {\n      throw new Error(`${this.name} requires at least two join entries.`);\n    }\n\n    // Check if this actor can handle the given number of streams\n    if (this.limitEntriesMin ? action.entries.length < this.limitEntries : action.entries.length > this.limitEntries) {\n      throw new Error(`${this.name} requires ${this.limitEntries\n      } join entries at ${this.limitEntriesMin ? 'least' : 'most'\n      }. The input contained ${action.entries.length}.`);\n    }\n\n    // Check if all streams are bindings streams\n    for (const entry of action.entries) {\n      if (entry.output.type !== 'bindings') {\n        throw new Error(`Invalid type of a join entry: Expected 'bindings' but got '${entry.output.type}'`);\n      }\n    }\n\n    const metadatas = await ActorRdfJoin.getMetadatas(action.entries);\n\n    // Check if this actor can handle undefs\n    if (!this.canHandleUndefs) {\n      for (const metadata of metadatas) {\n        if (metadata.canContainUndefs) {\n          throw new Error(`Actor ${this.name} can not join streams containing undefs`);\n        }\n      }\n    }\n\n    return await this.getJoinCoefficients(action, metadatas);\n  }\n\n  /**\n   * Returns default input for 0 or 1 entries. Calls the getOutput function otherwise\n   * @param {IActionRdfJoin} action\n   * @returns {Promise<IActorQueryOperationOutput>}\n   */\n  public async run(action: IActionRdfJoin): Promise<IQueryOperationResultBindings> {\n    // Prepare logging to physical plan\n    // This must be called before getOutput, because we need to override the plan node in the context\n    let parentPhysicalQueryPlanNode;\n    if (action.context.has(KeysInitQuery.physicalQueryPlanLogger)) {\n      parentPhysicalQueryPlanNode = action.context.get(KeysInitQuery.physicalQueryPlanNode);\n      action.context = action.context.set(KeysInitQuery.physicalQueryPlanNode, action);\n    }\n\n    // Log to physical plan\n    const physicalQueryPlanLogger: IPhysicalQueryPlanLogger | undefined = action.context.get(KeysInitQuery\n      .physicalQueryPlanLogger);\n    let planMetadata: any;\n    if (this.includeInLogs && physicalQueryPlanLogger) {\n      planMetadata = {};\n      physicalQueryPlanLogger.logOperation(\n        `join-${this.logicalType}`,\n        this.physicalName,\n        action,\n        parentPhysicalQueryPlanNode,\n        this.name,\n        planMetadata,\n      );\n    }\n\n    // Get action output\n    const { result, physicalPlanMetadata } = await this.getOutput(action);\n    const metadatas = await ActorRdfJoin.getMetadatas(action.entries);\n\n    // Fill in the physical plan metadata after determining action output\n    if (planMetadata) {\n      Object.assign(planMetadata, physicalPlanMetadata);\n      planMetadata.cardinalities = metadatas.map(ActorRdfJoin.getCardinality);\n      planMetadata.joinCoefficients = await this.getJoinCoefficients(action, metadatas);\n    }\n\n    // Cache metadata\n    result.metadata = ActorQueryOperation.cachifyMetadata(result.metadata);\n\n    return result;\n  }\n\n  /**\n   * Returns the resulting output for joining the given entries.\n   * This is called after removing the trivial cases in run.\n   * @param {IActionRdfJoin} action\n   * @returns {Promise<IActorRdfJoinOutputInner>}\n   */\n  protected abstract getOutput(action: IActionRdfJoin): Promise<IActorRdfJoinOutputInner>;\n\n  /**\n   * Calculate the join coefficients.\n   * @param {IActionRdfJoin} action Join action\n   * @param metadatas Array of resolved metadata objects.\n   * @returns {IMediatorTypeJoinCoefficients} The join coefficient estimates.\n   */\n  protected abstract getJoinCoefficients(\n    action: IActionRdfJoin,\n    metadatas: MetadataBindings[],\n  ): Promise<IMediatorTypeJoinCoefficients>;\n}\n\nexport interface IActorRdfJoinArgs\n  extends IActorArgs<IActionRdfJoin, IMediatorTypeJoinCoefficients, IQueryOperationResultBindings> {\n  mediatorJoinSelectivity: MediatorRdfJoinSelectivity;\n}\n\nexport interface IActorRdfJoinInternalOptions {\n  /**\n   * The logical join type this actor can handle.\n   */\n  logicalType: LogicalJoinType;\n  /**\n   * The physical name of join operation this actor implements.\n   * This is used for debug and query plan logs.\n   */\n  physicalName: string;\n  /**\n   * Can be used by subclasses to indicate the max or min number of streams that can be joined.\n   * 0 for infinity.\n   * By default, this indicates the max number, but can be inverted by setting limitEntriesMin to true.\n   */\n  limitEntries?: number;\n  /**\n   * If true, the limitEntries field is a lower limit,\n   * otherwise, it is an upper limit.\n   * Defaults to false.\n   */\n  limitEntriesMin?: boolean;\n  /**\n   * If this actor can handle undefs in the bindings.\n   * Defaults to false.\n   */\n  canHandleUndefs?: boolean;\n}\n\n/**\n * Represents a logical join type.\n */\nexport type LogicalJoinType = 'inner' | 'optional' | 'minus';\n\nexport interface IActionRdfJoin extends IAction {\n  /**\n   * The logical join type.\n   */\n  type: LogicalJoinType;\n  /**\n   * The array of streams to join.\n   */\n  entries: IJoinEntry[];\n}\n\nexport interface IActorRdfJoinOutputInner {\n  /**\n   * The join result.\n   */\n  result: IQueryOperationResultBindings;\n  /**\n   * Optional metadata that will be included as metadata within the physical query plan output.\n   */\n  physicalPlanMetadata?: any;\n}\n\nexport type MediatorRdfJoin = Mediate<IActionRdfJoin, IQueryOperationResultBindings, IMediatorTypeJoinCoefficients>;\n"]}