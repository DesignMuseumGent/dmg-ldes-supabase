{"version":3,"file":"SortIterator.js","sourceRoot":"","sources":["SortIterator.ts"],"names":[],"mappings":";;;AACA,iDAAkD;AAElD,mGAAmG;AACnG,MAAa,YAAgB,SAAQ,iCAAuB;IAK1D,YAAmB,MAAwB,EAAE,IAAmC,EAAE,OAAa;QAC7F,KAAK,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QAEvB,qFAAqF;QACrF,MAAM,MAAM,GAAW,OAAO,IAAI,OAAO,CAAC,MAAM,CAAC;QACjD,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,iBAAiB,CAAC;QAC9F,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;IACnB,CAAC;IAED,wDAAwD;IACjD,KAAK,CAAC,KAAa,EAAE,IAAgB;QAC1C,IAAI,IAAI,CAAC;QACT,IAAI,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC;QAC7B,6DAA6D;QAC7D,OAAO,MAAM,KAAK,IAAI,CAAC,YAAY,EAAE;YACnC,IAAI,GAAG,IAAI,CAAC,MAAO,CAAC,IAAI,EAAE,CAAC;YAC3B,IAAI,IAAI,KAAK,IAAI,EAAE;gBACjB,MAAM;aACP;YACD,uDAAuD;YACvD,IAAI,IAAI,GAAG,CAAC,CAAC;YACb,IAAI,KAAK,GAAG,MAAM,GAAG,CAAC,CAAC;YACvB,IAAI,GAAG,CAAC;YACR,IAAI,KAAK,CAAC;YACV,OAAO,IAAI,IAAI,KAAK,EAAE;gBACpB,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;gBACrC,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC1C,IAAI,KAAK,GAAG,CAAC,EAAE;oBACb,IAAI,GAAG,GAAG,GAAG,CAAC,CAAC;iBAChB;qBAAM,IAAI,KAAK,GAAG,CAAC,EAAE;oBACpB,KAAK,GAAG,GAAG,GAAG,CAAC,CAAC;iBACjB;qBAAM;oBACL,IAAI,GAAG,GAAG,CAAC;oBACX,KAAK,GAAG,CAAC,CAAC,CAAC;iBACZ;aACF;YACD,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;YAClC,MAAM,EAAE,CAAC;SACV;QACD,uCAAuC;QACvC,IAAI,MAAM,KAAK,IAAI,CAAC,YAAY,EAAE;YAChC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,EAAG,CAAC,CAAC;SAChC;QACD,IAAI,EAAE,CAAC;IACT,CAAC;IAED,oDAAoD;IAC7C,MAAM,CAAC,IAAgB;QAC5B,IAAI,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC;QAC7B,OAAO,MAAM,EAAE,EAAE;YACf,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,EAAG,CAAC,CAAC;SAChC;QACD,IAAI,EAAE,CAAC;IACT,CAAC;CACF;AA5DD,oCA4DC","sourcesContent":["import type { AsyncIterator } from 'asynciterator';\nimport { TransformIterator } from 'asynciterator';\n\n// Based on https://github.com/LinkedDataFragments/Client.js/blob/master/lib/sparql/SortIterator.js\nexport class SortIterator<T> extends TransformIterator<T, T> {\n  private readonly windowLength: number;\n  private readonly sort: (left: T, right: T) => number;\n  private readonly sorted: T[];\n\n  public constructor(source: AsyncIterator<T>, sort: (left: T, right: T) => number, options?: any) {\n    super(source, options);\n\n    // The `window` parameter indicates the length of the sliding window to apply sorting\n    const window: number = options && options.window;\n    this.windowLength = Number.isFinite(window) && window > 0 ? window : Number.POSITIVE_INFINITY;\n    this.sort = sort;\n    this.sorted = [];\n  }\n\n  // Reads the smallest item in the current sorting window\n  public _read(count: number, done: () => void): void {\n    let item;\n    let { length } = this.sorted;\n    // Try to read items until we reach the desired window length\n    while (length !== this.windowLength) {\n      item = this.source!.read();\n      if (item === null) {\n        break;\n      }\n      // Insert the item in the sorted window (smallest last)\n      let left = 0;\n      let right = length - 1;\n      let mid;\n      let order;\n      while (left <= right) {\n        mid = Math.trunc((left + right) / 2);\n        order = this.sort(item, this.sorted[mid]);\n        if (order < 0) {\n          left = mid + 1;\n        } else if (order > 0) {\n          right = mid - 1;\n        } else {\n          left = mid;\n          right = -1;\n        }\n      }\n      this.sorted.splice(left, 0, item);\n      length++;\n    }\n    // Push the smallest item in the window\n    if (length === this.windowLength) {\n      this._push(this.sorted.pop()!);\n    }\n    done();\n  }\n\n  // Flushes remaining data after the source has ended\n  public _flush(done: () => void): void {\n    let { length } = this.sorted;\n    while (length--) {\n      this._push(this.sorted.pop()!);\n    }\n    done();\n  }\n}\n"]}