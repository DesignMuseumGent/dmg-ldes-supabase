{"version":3,"file":"ActorQueryOperationOrderBySparqlee.js","sourceRoot":"","sources":["ActorQueryOperationOrderBySparqlee.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperation, ActorQueryOperationTypedMediated,\n} from '@comunica/bus-query-operation';\nimport type { IActorTest } from '@comunica/core';\nimport type { Bindings, IActionContext, IQueryOperationResult } from '@comunica/types';\nimport type { Term } from '@rdfjs/types';\nimport { Algebra } from 'sparqlalgebrajs';\nimport { AsyncEvaluator, isExpressionError, orderTypes } from 'sparqlee';\nimport { SortIterator } from './SortIterator';\n\n/**\n * A comunica OrderBy Sparqlee Query Operation Actor.\n */\nexport class ActorQueryOperationOrderBySparqlee extends ActorQueryOperationTypedMediated<Algebra.OrderBy> {\n  private readonly window: number;\n\n  public constructor(args: IActorQueryOperationOrderBySparqleeArgs) {\n    super(args, 'orderby');\n    this.window = args.window ?? Number.POSITIVE_INFINITY;\n  }\n\n  public async testOperation(operation: Algebra.OrderBy, context: IActionContext): Promise<IActorTest> {\n    // Will throw error for unsupported operators\n    for (let expr of operation.expressions) {\n      expr = this.extractSortExpression(expr);\n      const _ = new AsyncEvaluator(expr, ActorQueryOperation.getAsyncExpressionContext(context));\n    }\n    return true;\n  }\n\n  public async runOperation(operation: Algebra.OrderBy, context: IActionContext):\n  Promise<IQueryOperationResult> {\n    const outputRaw = await this.mediatorQueryOperation.mediate({ operation: operation.input, context });\n    const output = ActorQueryOperation.getSafeBindings(outputRaw);\n\n    const options = { window: this.window };\n    const sparqleeConfig = { ...ActorQueryOperation.getAsyncExpressionContext(context) };\n    let { bindingsStream } = output;\n\n    // Sorting backwards since the first one is the most important therefore should be ordered last.\n    for (let i = operation.expressions.length - 1; i >= 0; i--) {\n      let expr = operation.expressions[i];\n      const isAscending = this.isAscending(expr);\n      expr = this.extractSortExpression(expr);\n      // Transform the stream by annotating it with the expr result\n      const evaluator = new AsyncEvaluator(expr, sparqleeConfig);\n      interface IAnnotatedBinding {\n        bindings: Bindings; result: Term | undefined;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-loop-func\n      const transform = async(bindings: Bindings, next: any, push: (result: IAnnotatedBinding) => void):\n      Promise<void> => {\n        try {\n          const result = await evaluator.evaluate(bindings);\n          push({ bindings, result });\n        } catch (error: unknown) {\n          // We ignore all Expression errors.\n          // Other errors (likely programming mistakes) are still propagated.\n          // I can't recall where this is defined in the spec.\n          if (!isExpressionError(<Error> error)) {\n            bindingsStream.emit('error', error);\n          }\n          push({ bindings, result: undefined });\n        }\n        next();\n      };\n      const transformedStream = bindingsStream.transform<IAnnotatedBinding>({ transform });\n\n      // Sort the annoted stream\n      const sortedStream = new SortIterator(transformedStream,\n        (left, right) => orderTypes(left.result, right.result, isAscending),\n        options);\n\n      // Remove the annotation\n      bindingsStream = sortedStream.map(({ bindings, result }) => bindings);\n    }\n\n    return {\n      type: 'bindings',\n      bindingsStream,\n      metadata: output.metadata,\n    };\n  }\n\n  // Remove descending operator if necessary\n  private extractSortExpression(expr: Algebra.Expression): Algebra.Expression {\n    const { expressionType, operator } = expr;\n    if (expressionType !== Algebra.expressionTypes.OPERATOR) {\n      return expr;\n    }\n    return operator === 'desc' ?\n      expr.args[0] :\n      expr;\n  }\n\n  private isAscending(expr: Algebra.Expression): boolean {\n    const { expressionType, operator } = expr;\n    if (expressionType !== Algebra.expressionTypes.OPERATOR) {\n      return true;\n    }\n    return operator !== 'desc';\n  }\n}\n\n/**\n * The window parameter determines how many of the elements to consider when sorting.\n */\nexport interface IActorQueryOperationOrderBySparqleeArgs extends IActorQueryOperationTypedMediatedArgs {\n  /**\n   * The size of the window for the sort iterator.\n   * @range {integer}\n   */\n  window?: number;\n}\n"]}