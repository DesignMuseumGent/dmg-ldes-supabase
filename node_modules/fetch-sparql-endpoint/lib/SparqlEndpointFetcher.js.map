{"version":3,"file":"SparqlEndpointFetcher.js","sourceRoot":"","sources":["SparqlEndpointFetcher.ts"],"names":[],"mappings":"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","sourcesContent":["import \"cross-fetch/polyfill\";\nimport AbortController from 'abort-controller';\nimport * as RDF from \"@rdfjs/types\";\nimport {InsertDeleteOperation, ManagementOperation, Parser as SparqlParser} from \"sparqljs\";\nimport {ISettings, SparqlJsonParser} from \"sparqljson-parse\";\nimport {SparqlXmlParser} from \"sparqlxml-parse\";\nimport {Readable} from \"stream\";\nimport * as stringifyStream from 'stream-to-string';\nimport { ReadableWebToNodeStream } from 'readable-web-to-node-stream';\n\n// tslint:disable:no-var-requires\nconst n3 = require('n3');\nconst isStream = require('is-stream');\n\n/**\n * A SparqlEndpointFetcher can send queries to SPARQL endpoints,\n * and retrieve and parse the results.\n */\nexport class SparqlEndpointFetcher {\n\n  public static CONTENTTYPE_SPARQL_JSON: string = 'application/sparql-results+json';\n  public static CONTENTTYPE_SPARQL_XML: string = 'application/sparql-results+xml';\n  public static CONTENTTYPE_SPARQL: string =\n    `${SparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON};q=1.0,${SparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML};q=0.7`;\n  public static CONTENTTYPE_TURTLE: string = 'text/turtle';\n\n  public readonly method: 'POST' | 'GET';\n  public readonly additionalUrlParams: URLSearchParams;\n  public readonly fetchCb?: (input?: Request | string, init?: RequestInit) => Promise<Response>;\n  public readonly sparqlParsers: {[contentType: string]: ISparqlResultsParser};\n  public readonly sparqlJsonParser: SparqlJsonParser;\n  public readonly sparqlXmlParser: SparqlXmlParser;\n  public readonly timeout: number;\n\n  constructor(args?: ISparqlEndpointFetcherArgs) {\n    args = args || {};\n    this.method = args.method || 'POST';\n    this.additionalUrlParams = args.additionalUrlParams || new URLSearchParams();\n    this.fetchCb = args.fetch;\n    this.sparqlJsonParser = new SparqlJsonParser(args);\n    this.sparqlXmlParser = new SparqlXmlParser(args);\n    this.sparqlParsers = {\n      [SparqlEndpointFetcher.CONTENTTYPE_SPARQL_JSON]: {\n        parseBooleanStream: (sparqlResponseStream) =>\n          this.sparqlJsonParser.parseJsonBooleanStream(sparqlResponseStream),\n        parseResultsStream: (sparqlResponseStream) =>\n          this.sparqlJsonParser.parseJsonResultsStream(sparqlResponseStream),\n      },\n      [SparqlEndpointFetcher.CONTENTTYPE_SPARQL_XML]: {\n        parseBooleanStream: (sparqlResponseStream) =>\n          this.sparqlXmlParser.parseXmlBooleanStream(sparqlResponseStream),\n        parseResultsStream: (sparqlResponseStream) =>\n          this.sparqlXmlParser.parseXmlResultsStream(sparqlResponseStream),\n      },\n    };\n    this.timeout = args.timeout;\n  }\n\n  /**\n   * Get the query type of the given query.\n   *\n   * This will parse the query and thrown an exception on syntax errors.\n   *\n   * @param {string} query A query.\n   * @return {\"SELECT\" | \"ASK\" | \"CONSTRUCT\" | \"UNKNOWN\"} The query type.\n   */\n  public getQueryType(query: string): \"SELECT\" | \"ASK\" | \"CONSTRUCT\" | \"UNKNOWN\" {\n    const parsedQuery = new SparqlParser().parse(query);\n    return parsedQuery.type === 'query'\n      ? (parsedQuery.queryType === 'DESCRIBE' ? 'CONSTRUCT' : parsedQuery.queryType) : \"UNKNOWN\";\n  }\n\n  /**\n   * Get the query type of the given update query.\n   *\n   * This will parse the update query and thrown an exception on syntax errors.\n   *\n   * @param {string} query An update query.\n   * @return {'UNKNOWN' | UpdateTypes} The included update operations.\n   */\n  public getUpdateTypes(query: string): 'UNKNOWN' | IUpdateTypes {\n    const parsedQuery = new SparqlParser().parse(query);\n\n    if (parsedQuery.type === 'update') {\n      const operations: IUpdateTypes = {};\n\n      for (const update of parsedQuery.updates) {\n        if ('type' in update) {\n          operations[update.type] = true;\n        } else {\n          operations[update.updateType] = true;\n        }\n      }\n\n      return operations;\n\n    } else {\n      return \"UNKNOWN\"\n    };\n  };\n\n  /**\n   * Send a SELECT query to the given endpoint URL and return the resulting bindings stream.\n   * @see IBindings\n   * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query    A SPARQL query string.\n   * @return {Promise<NodeJS.ReadableStream>} A stream of {@link IBindings}.\n   */\n  public async fetchBindings(endpoint: string, query: string): Promise<NodeJS.ReadableStream> {\n    const [contentType, responseStream]: [string, NodeJS.ReadableStream] = await this\n      .fetchRawStream(endpoint, query, SparqlEndpointFetcher.CONTENTTYPE_SPARQL);\n    const parser: ISparqlResultsParser = this.sparqlParsers[contentType];\n    if (!parser) {\n      throw new Error('Unknown SPARQL results content type: ' + contentType);\n    }\n    return parser.parseResultsStream(responseStream);\n  }\n\n  /**\n   * Send an ASK query to the given endpoint URL and return a promise resolving to the boolean answer.\n   * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query    A SPARQL query string.\n   * @return {Promise<boolean>} A boolean resolving to the answer.\n   */\n  public async fetchAsk(endpoint: string, query: string): Promise<boolean> {\n    const [contentType, responseStream]: [string, NodeJS.ReadableStream] = await this\n      .fetchRawStream(endpoint, query, SparqlEndpointFetcher.CONTENTTYPE_SPARQL);\n    const parser: ISparqlResultsParser = this.sparqlParsers[contentType];\n    if (!parser) {\n      throw new Error('Unknown SPARQL results content type: ' + contentType);\n    }\n    return parser.parseBooleanStream(responseStream);\n  }\n\n  /**\n   * Send a CONSTRUCT/DESCRIBE query to the given endpoint URL and return the resulting triple stream.\n   * @param {string} endpoint A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query    A SPARQL query string.\n   * @return {Promise<Stream>} A stream of triples.\n   */\n  public async fetchTriples(endpoint: string, query: string): Promise<Readable & RDF.Stream> {\n    const rawStream = (await this.fetchRawStream(endpoint, query, SparqlEndpointFetcher.CONTENTTYPE_TURTLE))[1];\n    return rawStream.pipe(new n3.StreamParser({ format: SparqlEndpointFetcher.CONTENTTYPE_TURTLE }));\n  }\n\n  /**\n   * Send an update query to the given endpoint URL using POST.\n   *\n   * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query        A SPARQL query string.\n   */\n  public async fetchUpdate(endpoint: string, query: string): Promise<void> {\n    const abortController = new AbortController();\n    const init: RequestInit = {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/sparql-update',\n      },\n      body: query,\n      signal: abortController.signal as NonNullable<RequestInit[\"signal\"]>,\n    }\n\n    await this.handleFetchCall(endpoint, init, { ignoreBody: true });\n    abortController.abort();\n  }\n\n  /**\n   * Send a query to the given endpoint URL and return the resulting stream.\n   *\n   * This will only accept responses with the application/sparql-results+json content type.\n   *\n   * @param {string} endpoint     A SPARQL endpoint URL. (without the `?query=` suffix).\n   * @param {string} query        A SPARQL query string.\n   * @param {string} acceptHeader The HTTP accept to use.\n   * @return {Promise<[string, NodeJS.ReadableStream]>} The content type and SPARQL endpoint response stream.\n   */\n  public async fetchRawStream(endpoint: string, query: string, acceptHeader: string)\n    : Promise<[string, NodeJS.ReadableStream]> {\n    let url: string = this.method === 'POST' ? endpoint : endpoint + '?query=' + encodeURIComponent(query);\n\n    // Initiate request\n    const headers: Headers = new Headers();\n    let body: URLSearchParams | undefined;\n    headers.append('Accept', acceptHeader);\n    if (this.method === 'POST') {\n      headers.append('Content-Type', 'application/x-www-form-urlencoded');\n      body = new URLSearchParams();\n      body.set('query', query);\n      this.additionalUrlParams.forEach((value: string, key: string) => {\n        body.set(key, value);\n      })\n      headers.append('Content-Length', body.toString().length.toString());\n    } else if (this.additionalUrlParams.toString() !== '') {\n      url += `&${this.additionalUrlParams.toString()}`;\n    }\n\n    return this.handleFetchCall(url, { headers, method: this.method, body });\n  }\n\n  /**\n   * Helper function to generalize internal fetch calls.\n   *\n   * @param {string}      url     The URL to call.\n   * @param {RequestInit} init    Options to pass along to the fetch call.\n   * @param {any}         options Other specific fetch options.\n   * @return {Promise<[string, NodeJS.ReadableStream]>} The content type and SPARQL endpoint response stream.\n   */\n  private async handleFetchCall(\n    url: string,\n    init: RequestInit,\n    options: { ignoreBody?: boolean } = {},\n  ): Promise<[string, NodeJS.ReadableStream]> {\n    let timeoutId;\n    if (this.timeout) {\n      const controller = new AbortController();\n      init.signal = <AbortSignal>controller.signal;\n      timeoutId = setTimeout(() => controller.abort(), this.timeout);\n    }\n    const httpResponse: Response = await (this.fetchCb || fetch)(url, init);\n    clearTimeout(timeoutId);\n\n    let responseStream: NodeJS.ReadableStream | undefined;\n    // Handle response body\n    if (!options.ignoreBody) {\n      // Wrap WhatWG readable stream into a Node.js readable stream\n      // If the body already is a Node.js stream (in the case of node-fetch), don't do explicit conversion.\n      responseStream = isStream(httpResponse.body)\n        ? <NodeJS.ReadableStream> <any> httpResponse.body : <NodeJS.ReadableStream> <any> new ReadableWebToNodeStream(httpResponse.body);\n    }\n\n    // Determine the content type and emit it to the stream\n    let contentType = httpResponse.headers.get('Content-Type') || '';\n    if (contentType.indexOf(';') > 0) {\n      contentType = contentType.substr(0, contentType.indexOf(';'));\n    }\n\n    // Emit an error if the server returned an invalid response\n    if (!httpResponse.ok) {\n      const simpleUrl = /^[^?]*/u.exec(url)![0];\n      let bodyString = 'empty response';\n      if (responseStream) {\n        bodyString = await stringifyStream(responseStream);\n      }\n      throw new Error(`Invalid SPARQL endpoint response from ${simpleUrl} (HTTP status ${httpResponse.status}):\\n${bodyString}`);\n    }\n\n    return [ contentType, <any> responseStream ];\n  }\n}\n\nexport interface ISparqlEndpointFetcherArgs extends ISettings {\n  /**\n   * A custom HTTP method for issuing (non-update) queries, defaults to POST.\n   * Update queries are always issued via POST.\n   */\n  method?: 'POST' | 'GET';\n  additionalUrlParams?: URLSearchParams;\n  timeout?: number;\n  /**\n   * A custom fetch function.\n   */\n  fetch?: (input?: Request | string, init?: RequestInit) => Promise<Response>;\n}\n\nexport interface IBindings {\n  [key: string]: RDF.Term;\n}\n\nexport interface ISparqlResultsParser {\n  parseResultsStream(sparqlResponseStream: NodeJS.ReadableStream): NodeJS.ReadableStream;\n  parseBooleanStream(sparqlResponseStream: NodeJS.ReadableStream): Promise<boolean>;\n}\n\nexport type IUpdateTypes = {\n  [K in ManagementOperation['type'] | InsertDeleteOperation['updateType']]?: boolean;\n};\n"]}