{"version":3,"file":"RdfObjectLoader.js","sourceRoot":"","sources":["RdfObjectLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { JsonLdContextNormalized, JsonLdContext } from 'jsonld-context-parser';\nimport { ContextParser } from 'jsonld-context-parser';\nimport { DataFactory } from 'rdf-data-factory';\nimport { stringToTerm, termToString } from 'rdf-string';\nimport { RdfListMaterializer } from './RdfListMaterializer';\nimport { Resource } from './Resource';\n\n/**\n * Take a stream or array of RDF quads and loads them as linked resources.\n */\nexport class RdfObjectLoader {\n  private readonly dataFactory: RDF.DataFactory;\n  public readonly normalizeLists: boolean;\n  public readonly context: Promise<void>;\n  public readonly resources: Record<string, Resource> = {};\n  public contextResolved!: JsonLdContextNormalized;\n  private contextError: Error | undefined;\n\n  public constructor(args?: IRdfClassLoaderArgs) {\n    this.dataFactory = args?.dataFactory || new DataFactory();\n    this.normalizeLists = !args || !('normalizeLists' in args) || Boolean(args.normalizeLists);\n\n    this.context = new ContextParser().parse(args && args.context || {})\n      .then(contextResolved => {\n        this.contextResolved = contextResolved;\n      }).catch(error => {\n        // Save our error so that we can optionally throw it in .import\n        this.contextError = error;\n      });\n  }\n\n  /**\n   * Get the resource object for the given term.\n   * If it does not exist, one will be created.\n   * @param {Term} term An RDF term.\n   * @return {Resource} A resource.\n   */\n  public getOrMakeResource(term: RDF.Term): Resource {\n    const termString: string = termToString(term);\n    let resource: Resource = this.resources[termString];\n    if (!resource) {\n      resource = new Resource({ term, context: this.contextResolved });\n      this.resources[termString] = resource;\n    }\n    return resource;\n  }\n\n  /**\n   * Create a resource for the given hash,\n   * where all fields in the given hash are considered to be compacted properties that will be appended.\n   *\n   * Special field cases:\n   * * '@id' represents the IRI identifier.\n   * * 'list' is considered an RDF list.\n   *\n   * Values can be nested hashes, for which other Resources will be created.\n   * String values will be converted into term sources following the semantics of rdf-string.js.\n   * Values can also be Resources.\n   *\n   * @param hash A hash containing compacted properties.\n   */\n  public createCompactedResource(hash: any): Resource {\n    // Create resource for string value\n    if (typeof hash !== 'object') {\n      if (typeof hash === 'string') {\n        hash = this.contextResolved.expandTerm(hash);\n        if (!hash) {\n          return this.getOrMakeResource(this.dataFactory.blankNode());\n        }\n      } else {\n        hash = `\"${hash}\"`;\n      }\n      return this.getOrMakeResource(stringToTerm(hash, this.dataFactory));\n    }\n\n    // Return resource as-is\n    if (hash instanceof Resource) {\n      return hash;\n    }\n\n    // Wrap terms in resources\n    if ('termType' in hash && 'equals' in hash) {\n      return this.getOrMakeResource(hash);\n    }\n\n    // Create resource for named node term by @id value, or blank node\n    let term: RDF.Term;\n    if (hash['@id']) {\n      const expandedId = this.contextResolved.expandTerm(hash['@id']);\n      if (expandedId) {\n        term = this.dataFactory.namedNode(expandedId);\n      } else {\n        term = this.dataFactory.blankNode();\n      }\n    } else {\n      term = this.dataFactory.blankNode();\n    }\n    const resource: Resource = this.getOrMakeResource(term);\n\n    // Iterate over all entries in the hash\n    for (const [ key, value ] of Object.entries(hash)) {\n      // Skip keys starting with '@'\n      if (key === '@type') {\n        for (const subValue of Array.isArray(value) ? value : [ value ]) {\n          let typeResource: Resource;\n          if (typeof subValue === 'string') {\n            const expandedId = this.contextResolved.expandTerm(subValue, true);\n            let termType: RDF.Term;\n            if (expandedId) {\n              termType = this.dataFactory.namedNode(expandedId);\n            } else {\n              termType = this.dataFactory.blankNode();\n            }\n            typeResource = this.getOrMakeResource(termType);\n          } else {\n            typeResource = this.createCompactedResource(subValue);\n          }\n          resource.properties['http://www.w3.org/1999/02/22-rdf-syntax-ns#type'].push(typeResource);\n        }\n      } else if (!key.startsWith('@')) {\n        if (key === 'list') {\n          // Handle RDF list entries\n          resource.list = [];\n          for (const subValue of Array.isArray(value) ? value : [ value ]) {\n            resource.list.push(this.createCompactedResource(subValue));\n          }\n        } else {\n          // Handle compacted properties\n          for (const subValue of Array.isArray(value) ? value : [ value ]) {\n            if (subValue !== undefined) {\n              resource.properties[key].push(this.createCompactedResource(subValue));\n            }\n          }\n        }\n      }\n    }\n    return resource;\n  }\n\n  /**\n   * Create resources for the given hash or array by delegating array entries to {@link createCompactedResource}.\n   * @param hashOrArray A hash or array of hashes containing compacted properties.\n   */\n  public createCompactedResources(hashOrArray: any): Resource[] {\n    if (Array.isArray(hashOrArray)) {\n      return hashOrArray.map(hash => this.createCompactedResource(hash));\n    }\n    return [ this.createCompactedResource(hashOrArray) ];\n  }\n\n  /**\n   * Import the given stream of RDF quads.\n   * Resources will be created and linked for all passed terms.\n   * @param {Stream} stream A stream of RDF quads.\n   * @return {Promise<void>} A promise that resolves when the stream has ended.\n   * @template Q The type of quad, defaults to RDF.Quad.\n   */\n  public async import<Q extends RDF.BaseQuad = RDF.Quad>(stream: RDF.Stream<Q>): Promise<void> {\n    await this.context;\n    const listMaterializer = new RdfListMaterializer();\n    let listMaterializerPromise;\n    if (this.normalizeLists) {\n      listMaterializerPromise = listMaterializer.import(stream);\n    }\n\n    // Wait until stream has been handled completely\n    const streamPromise = new Promise<void>((resolve, reject) => {\n      stream.on('data', (quad: Q) => {\n        const subject: Resource = this.getOrMakeResource(quad.subject);\n        const predicate: Resource = this.getOrMakeResource(quad.predicate);\n        const object: Resource = this.getOrMakeResource(quad.object);\n        // Handle empty RDF lists\n        if (this.normalizeLists && object.term.equals(RdfListMaterializer.RDF_NIL)) {\n          object.list = [];\n        }\n        subject.addProperty(predicate, object);\n      });\n      stream.on('error', reject);\n      stream.on('end', () => {\n        if (this.normalizeLists) {\n          for (const listRoot of listMaterializer.getRoots()) {\n            const listTerms = listMaterializer.getList(listRoot);\n            this.resources[termToString(listRoot)].list = listTerms!.map(term => this.resources[termToString(term)]);\n          }\n        }\n        resolve();\n      });\n    });\n\n    // Catches errors from stream and list materialization\n    await Promise.all([ streamPromise, listMaterializerPromise ]);\n    if (this.contextError) {\n      throw this.contextError;\n    }\n  }\n\n  /**\n   * Import the given array of RDF quads.\n   * Resources will be created and linked for all passed terms.\n   * @param {Q[]} quads An array of RDF quads.\n   * @return {Promise<void>} A promise that resolves when the array has been fully imported.\n   * @template Q The type of quad, defaults to RDF.Quad.\n   */\n  public importArray<Q extends RDF.BaseQuad = RDF.Quad>(quads: Q[]): Promise<void> {\n    return this.import(require('streamify-array')(quads));\n  }\n}\n\nexport interface IRdfClassLoaderArgs {\n  /**\n   * If RDF lists should be loaded into the Resource.list field.\n   * Defaults to true.\n   */\n  normalizeLists?: boolean;\n  /**\n   * The JSON-LD context to use for expanding and compacting.\n   */\n  context?: JsonLdContext;\n  /**\n   * The factory to create RDF terms and quads with.\n   */\n  dataFactory?: RDF.DataFactory;\n}\n"]}