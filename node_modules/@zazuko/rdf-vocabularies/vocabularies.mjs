import rdf from 'rdf-ext';
import prefixes from "./prefixes.mjs";
import ParserN3 from '@rdfjs/parser-n3';
import { loadDatasetStream } from "./loadDataset/index.mjs";
export async function vocabularies(options = {}) {
  const {
    only = null,
    factory = rdf,
    stream = false
  } = options;
  let selectedPrefixes = [];

  if (!!only && Array.isArray(only)) {
    only.forEach(prefix => {
      if (prefix in prefixes) {
        selectedPrefixes.push(prefix);
      } else {
        console.warn(`unknown prefix '${prefix}'`);
      }
    });
  }

  if (!selectedPrefixes.length) {
    selectedPrefixes = Object.keys(prefixes);
  }

  const promises = selectedPrefixes.map(prefix => loadFile(prefix, {
    customSelection: !!only,
    factory
  }));
  const datasets = await Promise.all(promises);

  if (stream !== false) {
    let combinedDataset = factory.dataset();
    datasets.forEach(dataset => {
      if (dataset && dataset.size) {
        combinedDataset = combinedDataset.merge(dataset);
      }
    });
    return combinedDataset.toStream();
  }

  const result = {};
  datasets.forEach((dataset, i) => {
    if (dataset && dataset.size) {
      result[selectedPrefixes[i]] = dataset;
    }
  });
  return result;
}
export async function loadFile(prefix, {
  customSelection,
  factory
}) {
  const parserN3 = new ParserN3();
  const readStream = await loadDatasetStream(prefix);
  const quadStream = parserN3.import(readStream);
  return factory.dataset().import(quadStream).catch(() => {
    if (customSelection) {
      console.warn(`unavailable prefix '${prefix}'`);
    }
  });
}