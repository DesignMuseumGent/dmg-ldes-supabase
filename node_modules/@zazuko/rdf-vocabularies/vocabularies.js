"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const rdf_ext_1 = __importDefault(require("rdf-ext"));
const prefixes_1 = __importDefault(require("./prefixes"));
const parser_n3_1 = __importDefault(require("@rdfjs/parser-n3"));
const loadDataset_1 = require("./loadDataset");
async function vocabularies(options = {}) {
    const { only = null, factory = rdf_ext_1.default, stream = false } = options;
    let selectedPrefixes = [];
    if (!!only && Array.isArray(only)) {
        only.forEach((prefix) => {
            if (prefix in prefixes_1.default) {
                selectedPrefixes.push(prefix);
            }
            else {
                console.warn(`unknown prefix '${prefix}'`);
            }
        });
    }
    if (!selectedPrefixes.length) {
        selectedPrefixes = Object.keys(prefixes_1.default);
    }
    const promises = selectedPrefixes.map((prefix) => loadFile(prefix, { customSelection: !!only, factory }));
    const datasets = await Promise.all(promises);
    if (stream !== false) {
        let combinedDataset = factory.dataset();
        datasets.forEach((dataset) => {
            if (dataset && dataset.size) {
                combinedDataset = combinedDataset.merge(dataset);
            }
        });
        return combinedDataset.toStream();
    }
    const result = {};
    datasets.forEach((dataset, i) => {
        if (dataset && dataset.size) {
            result[selectedPrefixes[i]] = dataset;
        }
    });
    return result;
}
exports.vocabularies = vocabularies;
async function loadFile(prefix, { customSelection, factory }) {
    const parserN3 = new parser_n3_1.default();
    const readStream = await loadDataset_1.loadDatasetStream(prefix);
    const quadStream = parserN3.import(readStream);
    return factory.dataset().import(quadStream).catch(() => {
        if (customSelection) {
            console.warn(`unavailable prefix '${prefix}'`);
        }
    });
}
exports.loadFile = loadFile;
