"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const rdf_ext_1 = __importDefault(require("rdf-ext"));
const vocabularies_1 = require("./vocabularies");
const expand_1 = require("./expand");
// memoizing the prefixes already used in 'expand'
exports.loadedPrefixes = {};
async function expandWithCheck(prefixed, types) {
    const parts = expand_1.getParts(prefixed);
    if (!parts) {
        return '';
    }
    const { prefix, term, baseIRI } = parts;
    if (!(prefix in exports.loadedPrefixes)) {
        // if not previously loaded, load and memoize for later use
        const datasets = await vocabularies_1.vocabularies({ only: [prefix], factory: rdf_ext_1.default });
        exports.loadedPrefixes[prefix] = datasets[prefix];
    }
    const dataset = exports.loadedPrefixes[prefix];
    const iri = `${baseIRI}${term}`;
    const typesNamedNodes = types.map(type => typeof type === 'string' ? rdf_ext_1.default.namedNode(type) : type);
    const typeTerm = rdf_ext_1.default.namedNode(expand_1.expand('rdf:type'));
    const graph = rdf_ext_1.default.namedNode(baseIRI);
    for (const typeNamedNode of typesNamedNodes) {
        const found = dataset.match(rdf_ext_1.default.namedNode(iri), typeTerm, typeNamedNode, graph);
        if (found.size) {
            return found.toArray()[0].subject.value;
        }
    }
    return '';
}
exports.expandWithCheck = expandWithCheck;
