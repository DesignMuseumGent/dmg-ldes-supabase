import { Actor, IActorTest, Mediator } from "@comunica/core";
import { IActionRdfMetadataExtract, IActorRdfMetadataExtractOutput, ActorRdfMetadataExtract } from '@comunica/bus-rdf-metadata-extract';
import { MediatorRdfSerializeHandle } from '@comunica/bus-rdf-serialize';
import * as RDF from 'rdf-js';
import { Readable } from 'readable-stream';
import { JsonLdDocument } from "jsonld";
import { Bookkeeper } from './Bookkeeper';
import { IActionRdfFrame, IActorRdfFrameOutput } from "@treecg/bus-rdf-frame";
import { AsyncIterator } from "asynciterator";
import RateLimiter from "./RateLimiter";
import { Logger } from "@treecg/types";
import { MediatorRdfParseHandle } from "@comunica/bus-rdf-parse";
export interface IEventStreamArgs {
    pollingInterval?: number;
    representation?: string;
    requestHeaders?: {
        [key: string]: number | string | string[];
    };
    mimeType?: string;
    jsonLdContext?: JsonLdDocument;
    fromTime?: Date;
    emitMemberOnce?: boolean;
    disablePolling?: boolean;
    disableSynchronization?: boolean;
    disableFraming?: boolean;
    dereferenceMembers?: boolean;
    requestsPerMinute?: number;
    loggingLevel?: string;
    processedURIsCount?: number;
}
export interface IEventStreamMediators {
    mediatorRdfMetadataExtract: Mediator<ActorRdfMetadataExtract, IActionRdfMetadataExtract, IActorTest, IActorRdfMetadataExtractOutput>;
    mediatorRdfParseHandle: MediatorRdfParseHandle;
    mediatorRdfFrame: Mediator<Actor<IActionRdfFrame, IActorTest, IActorRdfFrameOutput>, IActionRdfFrame, IActorTest, IActorRdfFrameOutput>;
    mediatorRdfSerializeHandle: MediatorRdfSerializeHandle;
}
interface IMember {
    uri: string;
    quads: RDF.Stream<RDF.Quad> & AsyncIterator<RDF.Quad>;
}
export declare class EventStream extends Readable {
    protected readonly mediators: IEventStreamMediators;
    protected readonly pollingInterval?: number;
    protected readonly representation?: string;
    protected readonly requestHeaders?: {
        [key: string]: number | string | string[];
    };
    protected readonly mimeType?: string;
    protected readonly jsonLdContext?: JsonLdDocument;
    protected readonly emitMemberOnce?: boolean;
    protected readonly fromTime?: Date;
    protected readonly disableSynchronization?: boolean;
    protected readonly disableFraming?: boolean;
    protected readonly dereferenceMembers?: boolean;
    protected readonly accessUrl: string;
    protected readonly logger: Logger;
    protected readonly processedURIsCount?: number;
    protected processedURIs: any;
    protected readonly bookkeeper: Bookkeeper;
    protected readonly rateLimiter: RateLimiter;
    private downloading;
    private syncingmode;
    constructor(url: string, mediators: IEventStreamMediators, args: IEventStreamArgs, state: State | null);
    ignorePages(urls: string[]): void;
    private fetchNextPage;
    private paused;
    _read(): Promise<void>;
    pause(): this;
    resume(): this;
    exportState(): State;
    isBuffering(): boolean;
    importState(state: State): void;
    protected retrieve(pageUrl: string): Promise<void>;
    protected getMembers(quads: RDF.Quad[], memberUris: string[]): Generator<IMember>;
    protected extractMember(memberUri: string, subjectIndex: Record<string, RDF.Quad[]>, done: Set<string>): IMember;
    protected processMembers(members: Generator<IMember>): Promise<void>;
    protected getPage(pageUrl: string): Promise<PageMetadata>;
    protected sleep(ms: number): Promise<unknown>;
    protected stringToQuadStream(data: string, baseIRI: string, mediaType: string): Promise<RDF.Stream>;
    protected stringToQuadArray(data: string, baseIRI: string, mediaType: string): Promise<RDF.Quad[]>;
    protected quadArrayToQuadStream(data: RDF.Quad[]): Promise<RDF.Stream>;
    protected getMemberUris(treeMetadata: any): string[];
    protected extractEventTime(quads: RDF.Quad[]): Date | undefined;
}
declare class PageMetadata {
    "request": object;
    "response": object;
    "headers": any;
    "url": any;
    "data": string;
    "statusCode": number;
    "fromCache": boolean;
}
export interface State {
    bookkeeper: Object;
    memberBuffer: string;
    processedURIs: string;
}
export {};
