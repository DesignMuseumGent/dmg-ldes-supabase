"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const asynciterator_1 = require("asynciterator");
const rdf_dereference_1 = require("rdf-dereference");
const f = require("@dexagod/rdf-retrieval");
class MemberIterator extends asynciterator_1.AsyncIterator {
    constructor(beginUrl, rateLimiter) {
        super();
        this.fetchedPages = new Set();
        this.fetchedPages.add(beginUrl);
        this.pageQueue = [];
        this.waiting = false;
        this.rateLimiter = rateLimiter;
        this.fetchPage(beginUrl);
    }
    read() {
        if (this.closed) {
            return null;
        }
        if (this.waiting) {
            // waiting for the next page to be fetched
            this.readable = false;
            return null;
        }
        if (this.currentIndex >= this.currentPage.length) {
            // End of this page
            const pageUrl = this.pageQueue.pop();
            if (pageUrl) {
                // Fetch more data
                this.fetchPage(pageUrl);
            }
            else {
                this.close();
            }
            return null;
        }
        const item = this.currentPage[this.currentIndex];
        this.currentIndex += 1;
        return item;
    }
    async fetchPage(url) {
        if (!this.waiting) {
            // start fetching a page
            this.readable = false;
            this.waiting = true;
            this.currentPage = [];
            this.currentPage = await this.fetchPageRetry(url);
            this.followLinks(this.currentPage); // Extract more links to follow
            this.waiting = false;
            this.currentIndex = 0;
            this.readable = true;
        }
    }
    async fetchPageRetry(url, attempts = 3) {
        await this.rateLimiter.planRequest(url);
        try {
            const { data } = await rdf_dereference_1.default.dereference(url);
            return await f.quadStreamToQuadArray(data);
        }
        catch (error) {
            if (attempts > 0) {
                return this.fetchPageRetry(url, attempts - 1);
            }
            else {
                this.emit('error', `Cannot fetch ${url}`, error);
                this.close();
                return [];
            }
        }
    }
    /**
     * Decide which links to follow to complete the member
     * Currently follows hydra:next links
     * But should check the returned quads to a given shape definition
     * @param quads all new quads
     */
    followLinks(quads) {
        for (const quad of quads) {
            if (quad.predicate.value === "http://www.w3.org/ns/hydra/core#next") {
                const url = quad.object.value;
                if (!this.fetchedPages.has(url)) {
                    this.fetchedPages.add(url);
                    this.pageQueue.push(url);
                }
            }
        }
        return null;
    }
}
exports.default = MemberIterator;
//# sourceMappingURL=MemberIterator.js.map