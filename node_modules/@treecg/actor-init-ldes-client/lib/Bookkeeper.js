"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bookkeeper = void 0;
const PriorityQueue = require('js-priority-queue');
const LRU = require("lru-cache");
class Bookkeeper {
    constructor() {
        this.queue = new PriorityQueue({ comparator: compareFragments });
        this.queued = new LRU({
            max: 500,
            maxAge: 1000 * 60 * 60 * 24
        }); // to know whether a fragment URL is already added to the priority queue
        this.blacklist = new Set();
    }
    fragmentAlreadyAdded(url) {
        return this.queued.has(url);
    }
    fragmentIsBlacklisted(url) {
        return this.blacklist.has(url);
    }
    blacklistFragment(url) {
        this.blacklist.add(url);
    }
    addFragment(url, ttl) {
        if (!this.fragmentAlreadyAdded(url) && !this.fragmentIsBlacklisted(url)) {
            let fragmentInfo = {
                "url": url,
                "refetchTime": new Date(new Date().getTime() + ttl) // now
            };
            this.queue.queue(fragmentInfo);
            this.queued.set(url, true);
        }
    }
    nextFragmentExists() {
        return this.queued.length > 0;
    }
    getNextFragmentToFetch() {
        let next = this.queue.dequeue();
        this.queued.del(next.url);
        return next;
    }
    serialize() {
        return {
            "queue": JSON.stringify(this.serializePriorityQueue()),
            "queued": JSON.stringify(this.queued.dump()),
            "blacklist": JSON.stringify([...this.blacklist])
        };
    }
    deserialize(data) {
        this.deserializePriorityQueue(JSON.parse(data.queue));
        this.queued.load(JSON.parse(data.queued));
        this.blacklist = new Set(JSON.parse(data.blacklist));
    }
    serializePriorityQueue() {
        let serialized = [];
        while (this.queue.length > 0) {
            serialized.push(this.queue.dequeue());
        }
        return serialized;
    }
    deserializePriorityQueue(serialized) {
        this.queue.clear();
        serialized.forEach((element) => {
            this.queue.queue({
                "url": element.url,
                "refetchTime": new Date(element.refetchTime)
            });
        });
    }
    inSyncingMode() {
        return this.queue.peek().refetchTime.getTime() > new Date().getTime();
    }
}
exports.Bookkeeper = Bookkeeper;
function compareFragments(a, b) {
    return a.refetchTime.getTime() - b.refetchTime.getTime();
}
;
//# sourceMappingURL=Bookkeeper.js.map