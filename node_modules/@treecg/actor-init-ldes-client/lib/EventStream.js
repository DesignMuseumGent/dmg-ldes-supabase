"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventStream = void 0;
const core_1 = require("@comunica/core");
const moment = require("moment");
const readable_stream_1 = require("readable-stream");
const FETCH_PAUSE = 2000; // in milliseconds; pause before fetching the next fragment
const followRedirects = require('follow-redirects');
followRedirects.maxRedirects = 10;
const { http, https } = followRedirects;
const CacheableRequest = require('cacheable-request');
const cacheableRequestHttp = new CacheableRequest(http.request);
const cacheableRequestHttps = new CacheableRequest(https.request);
const CachePolicy = require('http-cache-semantics');
const stringifyStream = require('stream-to-string');
const streamifyString = require('streamify-string');
const Bookkeeper_1 = require("./Bookkeeper");
const f = require("@dexagod/rdf-retrieval");
const asynciterator_1 = require("asynciterator");
const urlLib = require("url");
const util_1 = require("util");
const RateLimiter_1 = require("./RateLimiter");
const MemberIterator_1 = require("./MemberIterator");
const RdfString = require("rdf-string");
const rdf_data_factory_1 = require("rdf-data-factory");
const types_1 = require("@treecg/types");
const LRU = require("lru-cache");
class EventStream extends readable_stream_1.Readable {
    constructor(url, mediators, args, state) {
        super({ objectMode: true, highWaterMark: 1000 });
        this.paused = false;
        this.mediators = mediators;
        this.accessUrl = url;
        this.fromTime = args.fromTime;
        this.disableSynchronization = args.disableSynchronization;
        this.disableFraming = args.disableFraming;
        this.pollingInterval = args.pollingInterval;
        this.representation = args.representation;
        this.requestHeaders = args.requestHeaders;
        this.mimeType = args.mimeType;
        this.jsonLdContext = args.jsonLdContext;
        this.dereferenceMembers = args.dereferenceMembers;
        this.emitMemberOnce = args.emitMemberOnce;
        this.processedURIsCount = args.processedURIsCount;
        this.logger = new types_1.Logger(this, args.loggingLevel);
        if (args.requestsPerMinute) {
            this.rateLimiter = new RateLimiter_1.default(60000. / args.requestsPerMinute);
        }
        else {
            this.rateLimiter = new RateLimiter_1.default(0);
        }
        this.processedURIs = new LRU({
            max: this.processedURIsCount
        });
        this.bookkeeper = new Bookkeeper_1.Bookkeeper();
        if (state != null) {
            this.importState(state);
        }
        else {
            this.bookkeeper.addFragment(this.accessUrl, 0);
        }
        this.downloading = false;
        this.syncingmode = false;
    }
    ignorePages(urls) {
        for (const url of urls) {
            this.bookkeeper.blacklistFragment(url);
        }
    }
    async fetchNextPage() {
        this.downloading = true;
        let next = this.bookkeeper.getNextFragmentToFetch();
        let now = new Date();
        // Do not refetch too soon
        while (next.refetchTime.getTime() > now.getTime()) {
            await this.sleep(FETCH_PAUSE);
            this.logger.info(`Waiting ${(next.refetchTime.getTime() - now.getTime()) / 1000}s before refetching: ${next.url}`);
            now = new Date();
        }
        return await this.retrieve(next.url).then(() => {
            this.downloading = false;
            this.emit('page processed', next.url);
            this._read();
        });
    }
    async _read() {
        try {
            if (!this.downloading && this.paused) {
                super.pause();
            }
            else if (!this.downloading && !this.isPaused() && this.bookkeeper.nextFragmentExists()) {
                if (!this.disableSynchronization && this.bookkeeper.inSyncingMode() && !this.syncingmode) {
                    this.syncingmode = true;
                    this.emit('now only syncing');
                }
                else {
                    await this.fetchNextPage();
                }
            }
            else if (!this.downloading) {
                //end of the stream
                this.logger.info("done");
                this.push(null);
            }
        }
        catch (e) {
            console.error(e);
        }
    }
    pause() {
        this.paused = true;
        return this;
    }
    resume() {
        this.paused = false;
        super.resume();
        return this;
    }
    exportState() {
        if (!this.isPaused() && !this.readableEnded) {
            throw new Error('Cannot export state while stream is not paused or ended');
        }
        let memberBuffer = [];
        while (this.readableLength > 0) {
            let member = this.read();
            if (this.representation === 'Quads') {
                if (member !== null) {
                    let quads = [];
                    for (const quad of member.quads) {
                        quads.push(RdfString.quadToStringQuad(quad));
                    }
                    memberBuffer.push({ id: member.id, quads: quads });
                }
            }
            else {
                memberBuffer.push(member);
            }
        }
        return {
            bookkeeper: this.bookkeeper.serialize(),
            memberBuffer: JSON.stringify(memberBuffer),
            processedURIs: JSON.stringify(this.processedURIs.dump()),
        };
    }
    isBuffering() {
        return this.downloading;
    }
    importState(state) {
        this.bookkeeper.deserialize(state.bookkeeper);
        if (state.memberBuffer != undefined && JSON.parse(state.memberBuffer) != null) {
            if (this.representation === 'Quads') {
                let internalBuffer = JSON.parse(state.memberBuffer);
                for (const member of internalBuffer) {
                    let quads = [];
                    for (const quad of member.quads) {
                        quads.push(RdfString.stringQuadToQuad(quad));
                    }
                    let _member = { id: member.id, quads: quads };
                    super.unshift(_member);
                }
            }
            else {
                for (const member of JSON.parse(state.memberBuffer)) {
                    super.unshift(member);
                }
            }
        }
        this.processedURIs = new LRU({
            max: this.processedURIsCount
        });
        this.processedURIs.load(JSON.parse(state.processedURIs));
    }
    // protected logErrorMessage(error: any) {
    //     process.stderr.write(`[${new Date().toISOString()}]  ERROR: ${inspect(error)}\n`);
    // }
    async retrieve(pageUrl) {
        this.logger.info(`GET ${pageUrl}`);
        const startTime = new Date();
        await this.rateLimiter.planRequest(pageUrl);
        try {
            const page = await this.getPage(pageUrl);
            const message = `${page.statusCode} ${page.url} (${new Date().getTime() - startTime.getTime()}) ms`;
            this.logger.info(message);
            // Remember that the fragment has been retrieved
            this.processedURIs.set(pageUrl, {});
            this.processedURIs.set(page.url, {}); // can be a redirected response <> pageUrl
            this.logger.debug(page.url + " added to processedURIs");
            this.logger.debug("Size of processedURIs: " + this.processedURIs.length);
            // Retrieve media type
            // TODO: Fetch mediaType by using response and comunica actor
            const mediaType = page.headers['content-type'].indexOf(';') > 0 ? page.headers['content-type'].substr(0, page.headers['content-type'].indexOf(';')) : page.headers['content-type'];
            if (!this.disableSynchronization && this.pollingInterval) {
                // Based on the HTTP Caching headers, poll this fragment for synchronization
                const policy = new CachePolicy(page.request, page.response, { shared: false }); // If options.shared is false, then the response is evaluated from a perspective of a single-user cache (i.e. private is cacheable and s-maxage is ignored)
                const ttl = Math.max(this.pollingInterval, policy.storable() ? policy.timeToLive() : 0); // pollingInterval is fallback
                this.bookkeeper.addFragment(page.url, ttl);
            }
            const quadsArrayOfPage = await this.stringToQuadArray(page.data.toString(), page.url, mediaType);
            // Parse into RDF Stream to retrieve TREE metadata
            const context = new core_1.ActionContext({});
            const treeMetadata = await this.mediators.mediatorRdfMetadataExtract.mediate({
                context: context,
                requestTime: 0,
                metadata: await this.quadArrayToQuadStream(quadsArrayOfPage),
                url: page.url
            });
            this.emit("metadata", Object.assign(Object.assign({}, treeMetadata.metadata), { url: page.url }));
            // When there are no tree:relations found, search for a tree:view to continue
            // In this case, we expect that the URL parameter provided contains a tree collection's URI
            if (!treeMetadata.metadata.treeMetadata.relations.size) {
                // Page URL should be a collection URI
                // Check the URL with and without www
                const pageUrlWithoutWWW = pageUrl.replace('://www.', '://');
                if (treeMetadata.metadata.treeMetadata.collections.get(pageUrl) && treeMetadata.metadata.treeMetadata.collections.get(pageUrl)["view"]) {
                    const view = treeMetadata.metadata.treeMetadata.collections.get(pageUrl)["view"][0]["@id"]; // take first view encountered
                    this.bookkeeper.addFragment(view, 0);
                }
                else if (treeMetadata.metadata.treeMetadata.collections.get(pageUrlWithoutWWW) && treeMetadata.metadata.treeMetadata.collections.get(pageUrlWithoutWWW)["view"]) {
                    const view = treeMetadata.metadata.treeMetadata.collections.get(pageUrlWithoutWWW)["view"][0]["@id"]; // take first view encountered
                    this.bookkeeper.addFragment(view, 0);
                }
            }
            // Retrieve TREE relations towards other nodes
            for (const [_, relation] of treeMetadata.metadata.treeMetadata.relations) {
                // Prune when the value of the relation is a datetime and less than what we need
                // To be enhanced when more TREE filtering capabilities are available
                if (this.fromTime && relation["@type"][0] === "https://w3id.org/tree#LessThanRelation"
                    && moment(relation.value[0]["@value"]).isValid()
                    && new Date(relation.value[0]["@value"]).getTime() <= this.fromTime.getTime()) {
                    // Prune - do nothing
                }
                else {
                    // Add node to book keeper with ttl 0 (as soon as possible)
                    for (const node of relation.node) {
                        // do not add when synchronization is disabled and node has already been processed
                        if (!this.disableSynchronization || (this.disableSynchronization && !this.processedURIs.has(node['@id']))) {
                            this.bookkeeper.addFragment(node['@id'], 0);
                        }
                    }
                }
            }
            const memberUris = this.getMemberUris(treeMetadata);
            const members = this.getMembers(quadsArrayOfPage, memberUris);
            await this.processMembers(members);
        }
        catch (e) {
            this.logger.error(`Failed to retrieve ${pageUrl}
${(0, util_1.inspect)(e)}`);
        }
    }
    *getMembers(quads, memberUris) {
        const subjectIndex = {};
        for (const quad of quads) {
            const subject = quad.subject.value;
            if (!subjectIndex[subject]) {
                subjectIndex[subject] = [quad];
            }
            else {
                subjectIndex[subject].push(quad);
            }
        }
        const result = {};
        for (const memberUri of memberUris) {
            if (this.fromTime) {
                // Check the event time; skip if needed
                const eventTime = this.extractEventTime(subjectIndex[memberUri]);
                if (!eventTime || eventTime < this.fromTime) {
                    continue;
                }
            }
            if (this.emitMemberOnce && this.processedURIs.has(memberUri)) {
                // This event has already been emitted
                continue;
            }
            this.processedURIs.set(memberUri, {});
            if (!this.dereferenceMembers) {
                const done = new Set(memberUris);
                yield this.extractMember(memberUri, subjectIndex, done);
            }
            else {
                const quads = new MemberIterator_1.default(memberUri, this.rateLimiter);
                quads.on('error', (msg, e) => {
                    this.logger.error(msg + '\n' + (0, util_1.inspect)(e));
                });
                yield {
                    uri: memberUri,
                    quads: quads,
                };
            }
        }
        return result;
    }
    extractMember(memberUri, subjectIndex, done) {
        const queue = [memberUri];
        const result = [];
        while (queue.length > 0) {
            const subject = queue.pop();
            if (!subject) {
                // Type coercion, should never happen
                break;
            }
            if (!subjectIndex[subject]) {
                // Nothing is known about this resource
                continue;
            }
            for (const quad of subjectIndex[subject]) {
                result.push(quad);
                if (quad.object.termType === 'NamedNode' || quad.object.termType === 'BlankNode') {
                    if (!done.has(quad.object.value)) {
                        done.add(quad.object.value);
                        queue.push(quad.object.value);
                    }
                }
            }
        }
        return {
            uri: memberUri,
            quads: new asynciterator_1.ArrayIterator(result),
        };
    }
    async processMembers(members) {
        let factory = new rdf_data_factory_1.DataFactory();
        for (const member of members) {
            const id = member.uri;
            const quadStream = member.quads;
            try {
                const context = new core_1.ActionContext({});
                //If representation is set, let’s return the data without serialization, but in the requested representation (Object or Quads)
                if (this.representation) {
                    //Can be "Object" or "Quads"
                    if (this.representation === 'Object') {
                        if (!this.disableFraming) {
                            let framedResult = (await this.mediators.mediatorRdfFrame.mediate({
                                context: context,
                                data: quadStream,
                                frames: [{ "@id": id }],
                                jsonLdContext: this.jsonLdContext
                            })).data;
                            let firstEntry = framedResult.entries().next();
                            this.push({ "id": firstEntry.value[0]["@id"], object: firstEntry.value[1] });
                        }
                        else {
                            let result = JSON.parse(await stringifyStream((await this.mediators.mediatorRdfSerializeHandle.mediate({
                                context: context,
                                handle: { quadStream: quadStream, context: context },
                                handleMediaType: "application/ld+json"
                            })).handle.data));
                            this.push({ "id": result[0]["@id"], object: result });
                        }
                    }
                    else {
                        //Build an array from the quads iterator
                        await new Promise((resolve, reject) => {
                            let quadArray = [];
                            quadStream.forEach((item) => {
                                quadArray.push(item);
                            });
                            quadStream.on('end', () => {
                                let _member = {
                                    id: factory.namedNode(member.uri),
                                    quads: quadArray
                                };
                                this.push(_member);
                                resolve();
                            });
                        });
                    }
                }
                else {
                    let outputString;
                    if (this.mimeType != "application/ld+json" || this.disableFraming) {
                        outputString = await stringifyStream((await this.mediators.mediatorRdfSerializeHandle.mediate({
                            context: context,
                            handle: { quadStream: quadStream, context: context },
                            handleMediaType: this.mimeType
                        })).handle.data);
                    }
                    else {
                        // Create framed JSON-LD output
                        const frame = {
                            "@id": id
                        };
                        const framedObjects = (await this.mediators.mediatorRdfFrame.mediate({
                            context: context,
                            data: quadStream,
                            frames: [frame],
                            jsonLdContext: this.jsonLdContext
                        })).data;
                        outputString = JSON.stringify(framedObjects.get(frame));
                    }
                    this.push(`${outputString}\n`);
                }
            }
            catch (error) {
                this.logger.error(`Failed to process member ${id}
${(0, util_1.inspect)(error)}`);
            }
        }
    }
    getPage(pageUrl) {
        return new Promise((resolve, reject) => {
            const protocol = new URL(pageUrl).protocol;
            let r = protocol === 'https:' ? cacheableRequestHttps : cacheableRequestHttp;
            const options = Object.assign(Object.assign({}, urlLib.parse(pageUrl)), { headers: Object.assign({ Accept: 'application/ld+json' }, this.requestHeaders) });
            const cacheReq = r(options, (res) => {
                let data = '';
                // A chunk of data has been recieved.
                res.on('data', (chunk) => {
                    data += chunk;
                });
                // The whole response has been received. Print out the result.
                res.on('end', () => {
                    if (!res['req']) {
                        res['req'] = {};
                    }
                    // This is necessary for cachePolicy
                    res['req']['headers'] = res['headers'];
                    resolve({
                        "request": res.req,
                        "response": res,
                        "headers": res.headers,
                        "url": res.responseUrl ? res.responseUrl : pageUrl,
                        "data": data,
                        "statusCode": res.statusCode,
                        "fromCache": res.fromCache
                    });
                });
            });
            cacheReq.on('request', (request) => request.end());
            cacheReq.on('error', (e) => reject(e));
        });
    }
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    async stringToQuadStream(data, baseIRI, mediaType) {
        const context = new core_1.ActionContext({});
        return (await this.mediators.mediatorRdfParseHandle.mediate({
            context: context,
            handle: {
                data: streamifyString(data),
                metadata: { baseIRI: baseIRI },
                context: context
            }, handleMediaType: mediaType
        })).handle.data;
    }
    async stringToQuadArray(data, baseIRI, mediaType) {
        const context = new core_1.ActionContext({});
        return new Promise(async (resolve, reject) => {
            let quadArray = [];
            const stream = (await this.mediators.mediatorRdfParseHandle.mediate({
                context: context,
                handle: {
                    context: context,
                    data: streamifyString(data),
                    metadata: { baseIRI: baseIRI }
                }, handleMediaType: mediaType
            })).handle.data;
            stream.on('data', (quad) => {
                quadArray.push(quad);
            });
            stream.on('end', () => {
                resolve(quadArray);
            });
        });
    }
    async quadArrayToQuadStream(data) {
        return new Promise(async (resolve, reject) => {
            resolve(f.quadArrayToQuadStream(data.slice()));
        });
    }
    // Returns array of memberURI (string) -> immutable (boolean)
    getMemberUris(treeMetadata) {
        let members = [];
        // Retrieve members from all collections found in the fragment
        const collections = treeMetadata.metadata.treeMetadata.collections;
        for (const [c, collectionValue] of collections.entries()) {
            for (let m in collectionValue.member) {
                const member = collectionValue.member[m]["@id"];
                members.push(member);
            }
        }
        return members;
    }
    extractEventTime(quads) {
        for (const quad of quads) {
            if (quad.subject.termType === 'NamedNode') {
                const predicate = quad.predicate.value;
                if (predicate === "http://www.w3.org/ns/prov#generatedAtTime") {
                    // Todo: make predicate configurable OR read from stream metadata
                    return new Date(quad.object.value);
                }
            }
        }
        return undefined;
    }
}
exports.EventStream = EventStream;
class PageMetadata {
}
//# sourceMappingURL=EventStream.js.map