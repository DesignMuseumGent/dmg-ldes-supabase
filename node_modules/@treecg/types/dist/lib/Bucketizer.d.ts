import type * as RDF from '@rdfjs/types';
import { BucketizerOptions } from './BucketizerOptions';
import { RelationParameters } from './RelationParameters';
import { Logger } from './utils/Logger';
export declare abstract class Bucketizer {
    readonly factory: RDF.DataFactory;
    propertyPathQuads: RDF.Quad[];
    private bucketHypermediaControlsMap;
    private bucketlessPageNumber;
    private bucketlessPageMemberCounter;
    bucketizerOptions: BucketizerOptions;
    logger: Logger;
    constructor(bucketizerOptions: BucketizerOptions);
    setPropertyPathQuads: (propertyPath: string) => Promise<void>;
    /**
     * Adds extra triples to the array of quads indicating
     * the buckets in which the version object must be placed
     */
    bucketize: (quads: RDF.Quad[], memberId: string) => void;
    /**
     * Selects the bucket for the LDES member based on the value of the property path object
     */
    protected abstract createBuckets: (propertyPathObject: RDF.Term[]) => string[];
    /**
     * Returns the RDF Term that matches the property path and will be used to create a bucket triple
     * @param memberQuads an array of quads representing a member
     * @param memberId identifier of the member
     * @returns an RDF Term
     */
    protected extractPropertyPathObject: (memberQuads: RDF.Quad[], memberId: string) => RDF.Term[];
    protected createBucketTriple: (bucket: string, memberId: string) => RDF.Quad;
    private readonly getEntryBlanknode;
    getBucketHypermediaControlsMap: () => Map<string, RelationParameters[]>;
    getHypermediaControls: (bucket: string) => RelationParameters[] | undefined;
    addHypermediaControls: (bucket: string, controls: RelationParameters[]) => void;
    getPropertyPathQuads: () => RDF.Quad[];
    getBucketProperty(): string;
    getRoot(): string;
    exportState(): any;
    importState(state: any): void;
    fallback: (memberId: string) => RDF.Quad;
}
