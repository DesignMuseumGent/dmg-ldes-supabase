"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractMetadata = void 0;
var N3 = __importStar(require("n3"));
var NameSpaces_1 = __importDefault(require("../util/NameSpaces"));
var context = { "@vocab": NameSpaces_1.default.tree('') };
var collectionContext = { "@vocab": NameSpaces_1.default.tree(''), "subset": NameSpaces_1.default.void("subset") };
function extractMetadata(quads) {
    return __awaiter(this, void 0, void 0, function () {
        var store, collectionIds, nodeIds, relationIds, collectionsMetadata, nodesMetadata, relationsMetadata, _i, collectionIds_1, id, metadata, _a, nodeIds_1, id, metadata, _b, relationIds_1, id, metadata;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0: return [4 /*yield*/, new N3.Store(quads)]; // have some issues with BaseQuad typing.
                case 1:
                    store = _c.sent() // have some issues with BaseQuad typing.
                    ;
                    return [4 /*yield*/, extractCollectionids(store)];
                case 2:
                    collectionIds = _c.sent();
                    return [4 /*yield*/, extractNodeIds(store)];
                case 3:
                    nodeIds = _c.sent();
                    return [4 /*yield*/, extractRelationIds(store)];
                case 4:
                    relationIds = _c.sent();
                    collectionsMetadata = new Map();
                    nodesMetadata = new Map();
                    relationsMetadata = new Map();
                    _i = 0, collectionIds_1 = collectionIds;
                    _c.label = 5;
                case 5:
                    if (!(_i < collectionIds_1.length)) return [3 /*break*/, 8];
                    id = collectionIds_1[_i];
                    return [4 /*yield*/, extractCollectionData(store, id)];
                case 6:
                    metadata = _c.sent();
                    collectionsMetadata.set(id, metadata);
                    _c.label = 7;
                case 7:
                    _i++;
                    return [3 /*break*/, 5];
                case 8:
                    _a = 0, nodeIds_1 = nodeIds;
                    _c.label = 9;
                case 9:
                    if (!(_a < nodeIds_1.length)) return [3 /*break*/, 12];
                    id = nodeIds_1[_a];
                    return [4 /*yield*/, extractNodeData(store, id)];
                case 10:
                    metadata = _c.sent();
                    nodesMetadata.set(id, metadata.node);
                    // Set the dummy relations generated for the hydra:next and as:next predicates
                    metadata.relations.map(function (relation) { return relationsMetadata.set(relation["@id"], relation); });
                    _c.label = 11;
                case 11:
                    _a++;
                    return [3 /*break*/, 9];
                case 12:
                    _b = 0, relationIds_1 = relationIds;
                    _c.label = 13;
                case 13:
                    if (!(_b < relationIds_1.length)) return [3 /*break*/, 16];
                    id = relationIds_1[_b];
                    return [4 /*yield*/, extractRelationMetadata(store, id)];
                case 14:
                    metadata = _c.sent();
                    relationsMetadata.set(id, metadata);
                    _c.label = 15;
                case 15:
                    _b++;
                    return [3 /*break*/, 13];
                case 16: return [2 /*return*/, { collections: collectionsMetadata, nodes: nodesMetadata, relations: relationsMetadata }];
            }
        });
    });
}
exports.extractMetadata = extractMetadata;
/**
 * Extract the ids of the collections from the store
 * @param store
 */
function extractCollectionids(store) {
    var ids = [];
    // Search for collection ids on type
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.rdf('type'), NameSpaces_1.default.tree('Collection'), null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.rdf('type'), NameSpaces_1.default.ldes('EventStream'), null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.rdf('type'), NameSpaces_1.default.hydra('Collection'), null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.rdf('type'), NameSpaces_1.default.as('Collection'), null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.rdf('type'), NameSpaces_1.default.as('OrderedCollection'), null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.rdf('type'), NameSpaces_1.default.dct('Collection'), null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.rdf('type'), NameSpaces_1.default.ldp('Container'), null).map(function (quad) { return quad.subject.id; }));
    // Search for collection ids on view
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.tree('view'), null, null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.hydra('view'), null, null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.void('subset'), null, null).map(function (quad) { return quad.subject.id; }));
    // reverse view properties
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.dct('isPartOf'), null, null).map(function (quad) { return quad.object.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.as('partOf'), null, null).map(function (quad) { return quad.object.id; }));
    // Search for collection ids on members
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.tree('member'), null, null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.hydra('member'), null, null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.ldp('contains'), null, null).map(function (quad) { return quad.subject.id; }));
    return Array.from(new Set(ids));
}
/**
 * Extract the ids of the nodes from the store
 * @param store
 */
function extractNodeIds(store) {
    var ids = [];
    // Search for node ids on type
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.rdf('type'), NameSpaces_1.default.tree('Node'), null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.rdf('type'), NameSpaces_1.default.hydra('PartialCollectionView'), null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.rdf('as'), NameSpaces_1.default.hydra('CollectionPage'), null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.rdf('as'), NameSpaces_1.default.hydra('OrderedCollectionPage'), null).map(function (quad) { return quad.subject.id; }));
    // // Searching on view causes nodes to be displayed that still need to be retrieved form another page
    // // Search for node ids on view
    // ids = ids.concat( store.getQuads(null, ns.tree('view'), null, null).map(quad => quad.object.id) );
    // ids = ids.concat( store.getQuads(null, ns.hydra('view'), null, null).map(quad => quad.object.id) );
    // ids = ids.concat( store.getQuads(null, ns.void('subset'), null, null).map(quad => quad.object.id) );
    // // reverse view properties
    // ids = ids.concat( store.getQuads(null, ns.dct('isPartOf'), null, null).map(quad => quad.subject.id) );
    // ids = ids.concat( store.getQuads(null, ns.as('partOf'), null, null).map(quad => quad.subject.id) );
    // Search for node ids on their properties
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.tree('search'), null, null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.tree('relation'), null, null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.ldes('retentionPolicy'), null, null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.hydra('next'), null, null).map(function (quad) { return quad.subject.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.as('next'), null, null).map(function (quad) { return quad.subject.id; }));
    return Array.from(new Set(ids));
}
/**
 * Extract the ids of the relations from the store
 * @param store
 */
function extractRelationIds(store) {
    var ids = [];
    // Search for node ids
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.tree('relation'), null, null).map(function (quad) { return quad.object.id; }));
    ids = ids.concat(store.getQuads(null, NameSpaces_1.default.tree('node'), null, null).map(function (quad) { return quad.subject.id; }));
    return Array.from(new Set(ids));
}
function extractCollectionData(store, id) {
    var c = {
        "@context": collectionContext,
        "@id": id,
    };
    // Extract collection type
    setField(c, "@type", store.getQuads(id, NameSpaces_1.default.rdf('type'), null, null).map(function (quad) { return quad.object.id; }));
    // Extract view ids
    setField(c, "view", store.getQuads(id, NameSpaces_1.default.tree('view'), null, null).map(function (quad) { return retrieveTerm(store, quad.object); }));
    setField(c, "view", store.getQuads(id, NameSpaces_1.default.hydra('view'), null, null).map(function (quad) { return retrieveTerm(store, quad.object); }));
    setField(c, "subset", store.getQuads(id, NameSpaces_1.default.void('subset'), null, null).map(function (quad) { return retrieveTerm(store, quad.object); }));
    // reverse properties
    setField(c, "subset", store.getQuads(null, NameSpaces_1.default.dct('isPartOf'), id, null).map(function (quad) { return retrieveTerm(store, quad.subject); }));
    setField(c, "subset", store.getQuads(null, NameSpaces_1.default.as('partOf'), id, null).map(function (quad) { return retrieveTerm(store, quad.subject); }));
    // Extract member ids
    setField(c, "member", store.getQuads(id, NameSpaces_1.default.tree('member'), null, null).map(function (quad) { return retrieveTerm(store, quad.object); }));
    setField(c, "member", store.getQuads(id, NameSpaces_1.default.hydra('member'), null, null).map(function (quad) { return retrieveTerm(store, quad.object); }));
    setField(c, "member", store.getQuads(id, NameSpaces_1.default.as('items'), null, null).map(function (quad) { return retrieveTerm(store, quad.object); }));
    setField(c, "member", store.getQuads(id, NameSpaces_1.default.hydra('contains'), null, null).map(function (quad) { return retrieveTerm(store, quad.object); }));
    // Extract shape objects
    setField(c, "shape", store.getQuads(id, NameSpaces_1.default.tree('shape'), null, null).map(function (quad) { return retrieveFullObject(store, quad.object); }));
    setField(c, "shape", store.getQuads(id, NameSpaces_1.default.st('validatedBy'), null, null).map(function (quad) { return retrieveFullObject(store, quad.object); }));
    // Extract full import objects
    setField(c, "import", store.getQuads(id, NameSpaces_1.default.tree('import'), null, null).map(function (quad) { return retrieveTerm(store, quad.object); }));
    setField(c, "importStream", store.getQuads(id, NameSpaces_1.default.tree('importStream'), null, null).map(function (quad) { return retrieveTerm(store, quad.object); }));
    setField(c, "conditionalImport", store.getQuads(id, NameSpaces_1.default.tree('conditionalImport'), null, null).map(function (quad) { return retrieveConditionalImportData(store, quad.object); }));
    // Extract totalItems
    setField(c, "totalItems", store.getQuads(id, NameSpaces_1.default.hydra('totalItems'), null, null).map(function (quad) { return retrieveTerm(store, quad.object); }));
    // TODO:: extract additional metadata?
    return c;
}
function extractNodeData(store, id) {
    var n = {
        "@context": context,
        "@id": id,
    };
    // Extract node type
    setField(n, "@type", store.getQuads(id, NameSpaces_1.default.rdf('type'), null, null).map(function (quad) { return quad.object.id; }));
    // extract full search object
    setField(n, "search", store.getQuads(id, NameSpaces_1.default.tree('search'), null, null).map(function (quad) { return retrieveFullObject(store, quad.object); }));
    // Extract relation ids
    setField(n, "relation", store.getQuads(id, NameSpaces_1.default.tree('relation'), null, null).map(function (quad) { return retrieveTerm(store, quad.object); }));
    // Extract retentionPolicy
    setField(n, "retentionPolicy", store.getQuads(id, NameSpaces_1.default.ldes('retentionPolicy'), null, null).map(function (quad) { return retrieveRetentionPolicyData(store, quad.object); }));
    // Extract full import objects
    setField(n, "import", store.getQuads(id, NameSpaces_1.default.tree('import'), null, null).map(function (quad) { return retrieveFullObject(store, quad.object); }));
    setField(n, "importStream", store.getQuads(id, NameSpaces_1.default.tree('importStream'), null, null).map(function (quad) { return retrieveFullObject(store, quad.object); }));
    setField(n, "conditionalImport", store.getQuads(id, NameSpaces_1.default.tree('conditionalImport'), null, null).map(function (quad) { return retrieveConditionalImportData(store, quad.object); }));
    // Extract next links
    var nextQuads = store.getQuads(id, NameSpaces_1.default.hydra('next'), null, null).concat(store.getQuads(id, NameSpaces_1.default.as('next'), null, null));
    var generatedNextDummyRelations = nextQuads.map(function (quad, index) { return createNextDummyRelation(quad.subject.id, quad.object.id, index); });
    setField(n, "relation", generatedNextDummyRelations.map(function (relation) { return ({ "@id": relation["@id"] }); }));
    // TODO:: extract additional metadata?
    return { node: n, relations: generatedNextDummyRelations };
}
function extractRelationMetadata(store, id) {
    var r = {
        "@context": context,
        "@id": id,
    };
    // Extract relation type
    setField(r, "@type", store.getQuads(id, NameSpaces_1.default.rdf('type'), null, null).map(function (quad) { return quad.object.id; }));
    // Extract remaining Items literal 
    setField(r, "remainingItems", store.getQuads(id, NameSpaces_1.default.tree('remainingItems'), null, null).map(function (quad) { return retrieveFullObject(store, quad.object); }));
    // Extract full path object
    setField(r, "path", store.getQuads(id, NameSpaces_1.default.tree('path'), null, null).map(function (quad) { return retrieveFullObject(store, quad.object); }));
    // Extract full value object
    setField(r, "value", store.getQuads(id, NameSpaces_1.default.tree('value'), null, null).map(function (quad) { return retrieveFullObject(store, quad.object); }));
    // Extract node id
    setField(r, "node", store.getQuads(id, NameSpaces_1.default.tree('node'), null, null).map(function (quad) { return retrieveTerm(store, quad.object); }));
    // Extract full import objects
    setField(r, "import", store.getQuads(id, NameSpaces_1.default.tree('import'), null, null).map(function (quad) { return retrieveFullObject(store, quad.object); }));
    setField(r, "importStream", store.getQuads(id, NameSpaces_1.default.tree('importStream'), null, null).map(function (quad) { return retrieveFullObject(store, quad.object); }));
    setField(r, "conditionalImport", store.getQuads(id, NameSpaces_1.default.tree('conditionalImport'), null, null).map(function (quad) { return retrieveConditionalImportData(store, quad.object); }));
    return r;
}
function retrieveRetentionPolicyData(store, term) {
    var rp = {};
    if (N3.Util.isNamedNode(term)) {
        rp["@id"] = term.value;
    }
    var id = term.id;
    // Extract retention policy data
    setField(rp, "@type", store.getQuads(id, NameSpaces_1.default.rdf('type'), null, null).map(function (quad) { return quad.object.id; }));
    setField(rp, "amount", store.getQuads(id, NameSpaces_1.default.ldes('amount'), null, null).map(function (quad) { return retrieveTerm(store, quad.object); }));
    setField(rp, "versionKey", store.getQuads(id, NameSpaces_1.default.ldes('versionKey'), null, null).map(function (quad) { return retrieveFullObject(store, quad.object); }));
    setField(rp, "path", store.getQuads(id, NameSpaces_1.default.tree('path'), null, null).map(function (quad) { return retrieveFullObject(store, quad.object); }));
    setField(rp, "value", store.getQuads(id, NameSpaces_1.default.tree('value'), null, null).map(function (quad) { return retrieveFullObject(store, quad.object); }));
    return rp;
}
function retrieveConditionalImportData(store, term) {
    var ci = {};
    if (N3.Util.isNamedNode(term)) {
        ci["@id"] = term.value;
    }
    var id = term.id;
    // Extract full import objects
    setField(ci, "path", store.getQuads(id, NameSpaces_1.default.tree('path'), null, null).map(function (quad) { return retrieveFullObject(store, quad.object); }));
    setField(ci, "import", store.getQuads(id, NameSpaces_1.default.tree('import'), null, null).map(function (quad) { return retrieveFullObject(store, quad.object); }));
    setField(ci, "importStream", store.getQuads(id, NameSpaces_1.default.tree('importStream'), null, null).map(function (quad) { return retrieveFullObject(store, quad.object); }));
    return ci;
}
/**
 * Retrieve base object
 * @param store
 * @param term
 * @param recursive
 * @param processedIds
 */
function retrieveTerm(store, term) {
    return retrieveFullObject(store, term, false);
}
/**
 * Recursively retrieve data by following all available predicates
 * @param store
 * @param term
 * @param recursive
 * @param processedIds
 */
function retrieveFullObject(store, term, recursive, processedIds) {
    if (recursive === void 0) { recursive = true; }
    if (processedIds === void 0) { processedIds = []; }
    switch (term.termType) {
        case "Literal":
            return createLiteral(store, term);
        case "BlankNode":
            if (recursive) {
                return createObject(store, term, processedIds);
            }
            else {
                return { '@id': term.id };
            }
        case "NamedNode":
            if (recursive) {
                return createObject(store, term, processedIds);
            }
            else {
                return { '@id': term.id };
            }
        default:
            // We do not process variables in metadata extraction.Literal
            return {};
    }
}
function createNextDummyRelation(sourceURI, targetURI, index) {
    // Generate unique blank Id
    var id = "_:nextRelation-" + index;
    var r = {
        "@context": context,
        "@id": id,
    };
    setField(r, "@type", [NameSpaces_1.default.tree('Relation')]);
    setField(r, "node", [{ "@id": targetURI }]);
    return r;
}
/**
 * Create a literal object
 * @param store
 * @param literal
 */
var createLiteral = function (store, literal) {
    var item = { "@value": literal.value };
    if (literal.datatype)
        item["@type"] = literal.datatype.id;
    if (literal.language)
        item["@language"] = literal.language;
    return item;
};
/**
 * Create an object, and recursively add objects for all
 * @param store
 * @param namedNode
 * @param processedIds
 */
var createObject = function (store, namedNode, processedIds) {
    var item = namedNode.termType === "NamedNode" ? { "@id": namedNode.id } : {};
    var quads = store.getQuads(namedNode.id, null, null, null);
    for (var _i = 0, quads_1 = quads; _i < quads_1.length; _i++) {
        var quad = quads_1[_i];
        if (quad.predicate.id === NameSpaces_1.default.rdf('type'))
            item["@type"] = quad.object.id;
        else {
            // Check for circular dereferencing
            if (!quad.object.id || processedIds.indexOf(quad.object.id) === -1) {
                var newProcessedIds = processedIds.concat(quad.object.id);
                var object = retrieveFullObject(store, quad.object, true, newProcessedIds);
                item[quad.predicate.id] = item[quad.predicate.id] ? item[quad.predicate.id].concat([object]) : [object];
            }
            else {
                console.error("circular dependency discovered for " + quad.object.id);
                var object = { "@id": quad.object.id };
                item[quad.predicate.id] = item[quad.predicate.id] ? item[quad.predicate.id].concat([object]) : [object];
            }
        }
    }
    return item;
};
/**
 * Helper function. Only add a field if there is a value for this field.
 * If the field already has results, concatenate the new results.
 */
function setField(object, field, results) {
    if (results && results.length) {
        if (object[field] && object[field].length) {
            object[field] = object[field].concat(results);
        }
        else {
            object[field] = results;
        }
    }
}
//# sourceMappingURL=metadataExtraction.js.map