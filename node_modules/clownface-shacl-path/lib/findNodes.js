import { sh } from '@tpluscode/rdf-ns-builders';
import TermSet from '@rdf-esm/term-set';
import { assertWellFormedPath } from "./path.js";

function traverse(node, path) {
  assertWellFormedPath(path);
  var list = path.list();

  if (list) {
    return [...list].reduce(traverse, node);
  }

  if (path.term.termType === 'BlankNode') {
    if (path.out(sh.inversePath).term) {
      return node.in(path.out(sh.inversePath).term);
    }

    if (path.out(sh.alternativePath).term) {
      var _list = path.out(sh.alternativePath).list();

      if (_list) {
        var results = [..._list].map(alt => traverse(node, alt)).reduce((uniq, mptr) => mptr.toArray().reduce((uniq, ptr) => uniq.add(ptr.term), uniq), new TermSet());
        return node.node(results);
      }

      throw new Error('Object of sh:alternativePath must be an RDF List');
    }

    if (path.out(sh.zeroOrOnePath).term) {
      return node.node([...node.terms, ...traverse(node, path.out(sh.zeroOrOnePath)).terms]);
    }

    var orMorePath = path.out([sh.zeroOrMorePath, sh.oneOrMorePath]);

    if (orMorePath.term) {
      var _results = new TermSet(path.out(sh.zeroOrMorePath).term ? node.terms : []);

      var current = node;
      var currentTerms = new TermSet(current.terms);

      while (currentTerms.size) {
        var nextNodes = traverse(current, orMorePath).toArray();
        var newResults = new TermSet();

        for (var next of nextNodes) {
          if (!_results.has(next.term)) {
            newResults.add(next.term);

            _results.add(next.term);
          }
        }

        currentTerms = newResults;
        current = node.node([...newResults.values()]);
      }

      return node.node([..._results.values()]);
    }

    throw new Error("Unrecognized property path ".concat(path.value));
  }

  return node.out(path);
}
/**
 * Finds all nodes connected to the input node by following a [SHACL Property Path](https://www.w3.org/TR/shacl/#dfn-shacl-property-path)
 *
 * @param node starting node
 * @param shPath SHACL Property Path
 */


export function findNodes(node, shPath) {
  var path = 'termType' in shPath ? node.node(shPath) : shPath;
  return traverse(node, path);
}