"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toSparql = toSparql;

var _rdfString = require("@tpluscode/rdf-string");

var _rdfNsBuilders = require("@tpluscode/rdf-ns-builders");

var _path = require("./path.cjs");

function sequence(left, operator, index) {
  const leftWrapped = left.length > 1 && left.sequence !== true ? (0, _rdfString.sparql)`(${left.path})` : left.path;
  return right => {
    if (index === 0) {
      return right;
    }

    const rightWrapped = right.length > 1 && right.sequence !== true ? (0, _rdfString.sparql)`(${right.path})` : right.path;
    return {
      path: (0, _rdfString.sparql)`${leftWrapped}${operator}${rightWrapped}`,
      length: 2,
      sequence: left.sequence && right.sequence
    };
  };
}

function traverse(propertyPath, path, index = 0) {
  (0, _path.assertWellFormedPath)(path);
  const list = path.list();

  if (list) {
    const segments = [...list];

    if (segments.length === 1) {
      throw new Error('SHACL Property Path list must have at least 2 elements');
    }

    return segments.reduce(traverse, propertyPath);
  }

  const next = sequence(propertyPath, '/', index);

  if (path.term.termType === 'BlankNode') {
    if (path.out(_rdfNsBuilders.sh.inversePath).term) {
      const inverse = traverse(propertyPath, path.out(_rdfNsBuilders.sh.inversePath));

      if (inverse.length > 1) {
        return next({
          path: (0, _rdfString.sparql)`^(${inverse.path})`,
          length: 1
        });
      }

      return next({
        path: (0, _rdfString.sparql)`^${inverse.path}`,
        length: 1
      });
    }

    if (path.out(_rdfNsBuilders.sh.alternativePath).term) {
      const list = path.out(_rdfNsBuilders.sh.alternativePath).list();

      if (!list) {
        throw new Error('Object of sh:alternativePath must be an RDF List');
      }

      const [first, ...rest] = [...list].map(alt => {
        const altElement = traverse(propertyPath, alt);

        if (altElement.length > 1) {
          return {
            path: (0, _rdfString.sparql)`(${altElement.path})`,
            length: 1
          };
        }

        return altElement;
      });

      if (rest.length) {
        return next({
          path: (0, _rdfString.sparql)`${rest.reduce((alt, next) => (0, _rdfString.sparql)`${alt}|${next.path}`, first.path)}`,
          length: rest.length + 1
        });
      }

      throw new Error('sh:alternativePath must have at least two elements');
    }

    if (path.out(_rdfNsBuilders.sh.zeroOrMorePath).term) {
      const inner = traverse(propertyPath, path.out(_rdfNsBuilders.sh.zeroOrMorePath));

      if (inner.length > 1) {
        return next({
          path: (0, _rdfString.sparql)`(${inner.path})*`,
          length: 1
        });
      }

      return next({
        path: (0, _rdfString.sparql)`${inner.path}*`,
        length: 1
      });
    }

    if (path.out(_rdfNsBuilders.sh.oneOrMorePath).term) {
      const inner = traverse(propertyPath, path.out(_rdfNsBuilders.sh.oneOrMorePath));

      if (inner.length > 1) {
        return next({
          path: (0, _rdfString.sparql)`(${inner.path})+`,
          length: 1
        });
      }

      return next({
        path: (0, _rdfString.sparql)`${inner.path}+`,
        length: 1
      });
    }

    if (path.out(_rdfNsBuilders.sh.zeroOrOnePath).term) {
      const inner = traverse(propertyPath, path.out(_rdfNsBuilders.sh.zeroOrOnePath));

      if (inner.length > 1) {
        return next({
          path: (0, _rdfString.sparql)`(${inner.path})?`,
          length: 1
        });
      }

      return next({
        path: (0, _rdfString.sparql)`${inner.path}?`,
        length: 1
      });
    }

    throw new Error(`Unrecognized property path ${path.value}`);
  }

  return next({
    path: (0, _rdfString.sparql)`${path.term}`,
    length: 1,
    sequence: true
  });
}
/**
 * Creates a SPARQL template string which represents a SHACL path as Property Path
 *
 * @param path SHACL Property Path
 */


function toSparql(path) {
  if ('termType' in path) {
    return (0, _rdfString.sparql)`${path}`;
  }

  return traverse({
    path: (0, _rdfString.sparql)``,
    length: 0
  }, path).path;
}
/**
 * Splits a Sequence Path and returns an array of SPARQL template results.
 * If the path is not a Sequence Path, returns an array with a single element
 *
 * @param path SHACL Property Path
 */


toSparql.sequence = path => {
  (0, _path.assertWellFormedPath)(path);
  const list = path.list();

  if (list) {
    return [...list].map(toSparql);
  }

  return [toSparql(path)];
};