"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findNodes = findNodes;

var _rdfNsBuilders = require("@tpluscode/rdf-ns-builders");

var _termSet = _interopRequireDefault(require("@rdf-esm/term-set"));

var _path = require("./path.cjs");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function traverse(node, path) {
  (0, _path.assertWellFormedPath)(path);
  const list = path.list();

  if (list) {
    return [...list].reduce(traverse, node);
  }

  if (path.term.termType === 'BlankNode') {
    if (path.out(_rdfNsBuilders.sh.inversePath).term) {
      return node.in(path.out(_rdfNsBuilders.sh.inversePath).term);
    }

    if (path.out(_rdfNsBuilders.sh.alternativePath).term) {
      const list = path.out(_rdfNsBuilders.sh.alternativePath).list();

      if (list) {
        const results = [...list].map(alt => traverse(node, alt)).reduce((uniq, mptr) => mptr.toArray().reduce((uniq, ptr) => uniq.add(ptr.term), uniq), new _termSet.default());
        return node.node(results);
      }

      throw new Error('Object of sh:alternativePath must be an RDF List');
    }

    if (path.out(_rdfNsBuilders.sh.zeroOrOnePath).term) {
      return node.node([...node.terms, ...traverse(node, path.out(_rdfNsBuilders.sh.zeroOrOnePath)).terms]);
    }

    const orMorePath = path.out([_rdfNsBuilders.sh.zeroOrMorePath, _rdfNsBuilders.sh.oneOrMorePath]);

    if (orMorePath.term) {
      const results = new _termSet.default(path.out(_rdfNsBuilders.sh.zeroOrMorePath).term ? node.terms : []);
      let current = node;
      let currentTerms = new _termSet.default(current.terms);

      while (currentTerms.size) {
        const nextNodes = traverse(current, orMorePath).toArray();
        const newResults = new _termSet.default();

        for (const next of nextNodes) {
          if (!results.has(next.term)) {
            newResults.add(next.term);
            results.add(next.term);
          }
        }

        currentTerms = newResults;
        current = node.node([...newResults.values()]);
      }

      return node.node([...results.values()]);
    }

    throw new Error(`Unrecognized property path ${path.value}`);
  }

  return node.out(path);
}
/**
 * Finds all nodes connected to the input node by following a [SHACL Property Path](https://www.w3.org/TR/shacl/#dfn-shacl-property-path)
 *
 * @param node starting node
 * @param shPath SHACL Property Path
 */


function findNodes(node, shPath) {
  const path = 'termType' in shPath ? node.node(shPath) : shPath;
  return traverse(node, path);
}