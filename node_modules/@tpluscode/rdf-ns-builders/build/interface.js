"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMembers = void 0;
const ts_morph_1 = require("ts-morph");
const rdf_vocabularies_1 = require("@zazuko/rdf-vocabularies");
const clownface_1 = __importDefault(require("clownface"));
const data_model_1 = require("@rdf-esm/data-model");
const rdfsComment = (0, data_model_1.namedNode)('http://www.w3.org/2000/01/rdf-schema#comment');
function createMember(prefixes, prefix, term, comment) {
    const member = {
        name: `"${term}"`,
        kind: ts_morph_1.StructureKind.PropertySignature,
        type: `NamedNode<'${prefixes[prefix]}${term}'>`,
    };
    if (comment) {
        member.docs = [comment];
    }
    return member;
}
async function createMembers(prefix, { vocabularies, prefixes }) {
    const prefixedRegex = new RegExp(`^${prefix}:(.+)$`);
    const terms = new Map();
    const dataset = (await vocabularies({ only: [prefix] }))[prefix];
    if (!dataset) {
        return [];
    }
    const graph = (0, clownface_1.default)({ dataset });
    [...graph.in().toArray(), ...graph.out().toArray()]
        .forEach((node) => {
        const prefixedName = (0, rdf_vocabularies_1.shrink)(node.value);
        const matchesPrefix = prefixedName.match(prefixedRegex);
        if (prefixedName && matchesPrefix) {
            const term = matchesPrefix[1];
            if (!terms.has(matchesPrefix[1])) {
                terms.set(term, createMember(prefixes, prefix, term, node.out(rdfsComment).values[0]));
            }
        }
    });
    return [...terms.values()].sort();
}
exports.createMembers = createMembers;
