/// <reference types="rdfjs__namespace" />
import { BlankNode, DatasetCore, DefaultGraph, Literal, NamedNode, Quad, Term } from 'rdf-js';
import type { NamespaceBuilder } from '@rdfjs/namespace';
import { Value } from './value';
import { PartialString, SerializationStrategy, TemplateResult } from './TemplateResult';
interface TurtleOptions {
    base?: string | NamedNode;
    directives: boolean;
    graph: NamedNode | DefaultGraph;
    cheapCompression: boolean;
    prefixes?: Record<string, string | NamespaceBuilder>;
}
export declare type TurtleTemplateResult = TemplateResult<TurtleOptions>;
export declare type TurtleValue<T extends Term = Term> = Value<TurtleTemplateResult, T>;
export declare class TurtleStrategy extends SerializationStrategy<TurtleOptions> {
    evaluateBlankNode(term: BlankNode): PartialString;
    evaluateLiteral(term: Literal, options: TurtleOptions): PartialString;
    evaluateNamedNode(term: NamedNode, { base, prefixes }: TurtleOptions): PartialString;
    evaluateVariable(): PartialString;
    evaluateDataset(dataset: DatasetCore, options: TurtleOptions): PartialString;
    evaluateQuad(quad: Quad, options: TurtleOptions, { terminate, newLineAfterSubject }?: {
        terminate?: boolean | undefined;
        newLineAfterSubject?: boolean | undefined;
    }): PartialString;
    getFinalString(result: string, prefixes: Iterable<string>, options: TurtleOptions): string;
    private __evaluateQuads;
    private __appendPredicateObject;
    private __appendObject;
}
export declare const turtle: (strings: TemplateStringsArray, ...values: Value<TemplateResult<TurtleOptions>, NamedNode | Literal | BlankNode>[]) => TemplateResult<TurtleOptions>;
export {};
//# sourceMappingURL=turtle.d.ts.map