"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TemplateResult = exports.SerializationStrategy = void 0;
const data_model_1 = __importDefault(require("@rdf-esm/data-model"));
const xsd_1 = __importDefault(require("./syntax/xsd"));
class SerializationStrategy {
    evaluateTerm(value, options) {
        switch (value.termType) {
            case 'Literal':
                return this.evaluateLiteral(value, options);
            case 'NamedNode':
                return this.evaluateNamedNode(value, options);
            case 'BlankNode':
                return this.evaluateBlankNode(value);
            case 'Variable':
                return this.evaluateVariable(value);
        }
        return {
            value: '',
            prefixes: [],
        };
    }
}
exports.SerializationStrategy = SerializationStrategy;
function isIterable(obj) {
    return Symbol.iterator in Object(obj) && typeof obj !== 'string';
}
class TemplateResult {
    constructor({ strings, values, tag, strategy, defaultOptions, }) {
        this.strings = strings;
        this.values = values;
        this._tag = tag;
        this.__strategy = strategy;
        this.__defaultOptions = defaultOptions;
    }
    toString(options) {
        let actualOptions = this.__defaultOptions;
        if (options) {
            actualOptions = { ...actualOptions, ...options };
        }
        const { value, prefixes } = this._toPartialString(actualOptions);
        return this.__strategy.getFinalString(value, prefixes, actualOptions);
    }
    _toPartialString(options) {
        const prefixes = new Set();
        const l = this.strings.length - 1;
        let result = '';
        for (let i = 0; i < l; i++) {
            let partialResult = null;
            result += this.strings[i];
            const value = this.values[i];
            if (typeof value === 'undefined' || value === null)
                continue;
            if (typeof value === 'boolean') {
                partialResult = this.__strategy.evaluateLiteral(data_model_1.default.literal(value.toString(), xsd_1.default.boolean), options);
            }
            else if (typeof value === 'number') {
                const datatype = Number.isInteger(value) ? xsd_1.default.integer : xsd_1.default.decimal;
                partialResult = this.__strategy.evaluateLiteral(data_model_1.default.literal(value.toString(), datatype), options);
            }
            else if (value instanceof Date) {
                partialResult = this.__strategy.evaluateLiteral(data_model_1.default.literal(value.toISOString(), xsd_1.default.dateTime), options);
            }
            else if (typeof value === 'object') {
                if ('_toPartialString' in value) {
                    partialResult = value._toPartialString(options);
                }
                else if ('subject' in value) {
                    partialResult = this.__strategy.evaluateQuad(value, options);
                }
                else if ('match' in value) {
                    partialResult = this.__strategy.evaluateDataset(value, options);
                }
                else if ('termType' in value) {
                    partialResult = this.__strategy.evaluateTerm(value, options);
                }
                else if (isIterable(value)) {
                    const [first, ...rest] = value;
                    partialResult = this._tag `${first}`._toPartialString(options);
                    for (const item of rest) {
                        const itemResult = this._tag `${item}`._toPartialString(options);
                        partialResult.value += `\n${itemResult.value}`;
                        partialResult.prefixes = [...partialResult.prefixes, ...itemResult.prefixes];
                    }
                }
            }
            if (partialResult === null) {
                partialResult = {
                    value: value.toString(),
                    prefixes: [],
                };
            }
            result += partialResult.value;
            [...partialResult.prefixes].forEach(prefix => prefixes.add(prefix));
        }
        result += this.strings[l];
        return {
            value: result,
            prefixes,
        };
    }
}
exports.TemplateResult = TemplateResult;
