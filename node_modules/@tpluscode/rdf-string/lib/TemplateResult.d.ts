import { BlankNode, DatasetCore, Literal, NamedNode, BaseQuad, Term, Variable } from 'rdf-js';
import { Value } from './value';
declare type TagFunction<TImpl extends TemplateResult<TOptions>, TValue extends Value<TImpl>, TOptions> = {
    (strings: TemplateStringsArray, ...values: TValue[]): TImpl;
};
export interface PartialString {
    value: string;
    prefixes: Iterable<string>;
}
export declare abstract class SerializationStrategy<TOptions> {
    abstract evaluateLiteral(term: Literal, options: TOptions): PartialString;
    abstract evaluateNamedNode(term: NamedNode, options: TOptions): PartialString;
    abstract evaluateVariable(term: Variable): PartialString;
    abstract evaluateBlankNode(term: BlankNode): PartialString;
    abstract evaluateQuad(quad: BaseQuad, options: TOptions): PartialString;
    abstract evaluateDataset(dataset: DatasetCore, options: TOptions): PartialString;
    abstract getFinalString(result: string, prefixes: Iterable<string>, options: TOptions): string;
    evaluateTerm(value: Term, options: TOptions): PartialString;
}
export interface TemplateResultInit<TOptions> {
    strings: TemplateStringsArray;
    values: Value<TemplateResult<TOptions>>[];
    tag: TagFunction<any, Value<any>, TOptions>;
    strategy: SerializationStrategy<TOptions>;
    defaultOptions: TOptions;
}
export declare class TemplateResult<TOptions> {
    protected readonly strings: TemplateStringsArray;
    protected readonly values: readonly (Value<TemplateResult<TOptions>> | object)[];
    protected readonly _tag: TagFunction<TemplateResult<TOptions>, Value<TemplateResult<TOptions>>, TOptions>;
    private readonly __strategy;
    private readonly __defaultOptions;
    constructor({ strings, values, tag, strategy, defaultOptions, }: TemplateResultInit<TOptions>);
    toString(options?: Partial<TOptions>): string;
    _toPartialString(options: TOptions): PartialString;
}
export {};
//# sourceMappingURL=TemplateResult.d.ts.map