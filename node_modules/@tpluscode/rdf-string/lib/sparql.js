"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sparql = exports.SparqlStrategy = void 0;
const prefixes_1 = __importDefault(require("@zazuko/rdf-vocabularies/prefixes"));
const data_model_1 = require("@rdf-esm/data-model");
const term_map_1 = __importDefault(require("@rdf-esm/term-map"));
const TemplateResult_1 = require("./TemplateResult");
const turtleSyntax = __importStar(require("./syntax/turtle"));
const prefixes_2 = require("./prefixes");
function prefixDeclarations(prefixes, prefixMap) {
    return prefixes_2.getNamespaces(prefixes, prefixMap)
        .map(([prefix, ns]) => `PREFIX ${prefix}: <${ns}>`);
}
function toTriple({ subject, predicate, object }) {
    return data_model_1.quad(subject, predicate, object);
}
class SparqlStrategy extends TemplateResult_1.SerializationStrategy {
    evaluateLiteral(term, options) {
        return turtleSyntax.literal(term, options);
    }
    evaluateNamedNode(term, options) {
        return turtleSyntax.namedNode(term, options);
    }
    evaluateBlankNode(term) {
        return {
            value: turtleSyntax.blankNode(term),
            prefixes: [],
        };
    }
    evaluateVariable(term) {
        return {
            value: `?${term.value}`,
            prefixes: [],
        };
    }
    getFinalString(result, prefixes, options) {
        const prologue = options.prologue || typeof options.prologue === 'undefined';
        let prologueLines = [];
        if (prologue) {
            prologueLines = prefixDeclarations(prefixes, {
                ...prefixes_1.default,
                ...prefixes_2.mapBuilders(options.prefixes),
            });
            if (options.base) {
                prologueLines = [`BASE <${options.base}>`, ...prologueLines];
            }
            if (prologueLines.length > 0) {
                prologueLines.push('\n');
            }
        }
        return `${prologueLines.join('\n')}${result}`;
    }
    evaluateDataset(dataset, options) {
        const graphs = [...dataset]
            .reduce((graphs, quad) => {
            const namedGraph = graphs.get(quad.graph) || [];
            graphs.set(quad.graph, [
                ...namedGraph,
                toTriple(quad),
            ]);
            return graphs;
        }, new term_map_1.default());
        return [...graphs.entries()].reduce((previous, [graph, quads]) => {
            const triplePatterns = this.__evaluateTripleArray(quads, options);
            if (data_model_1.defaultGraphInstance.equals(graph)) {
                return {
                    value: `${previous.value}\n${triplePatterns.value}`,
                    prefixes: [...previous.prefixes, ...triplePatterns.prefixes],
                };
            }
            else {
                const graphStr = this.evaluateTerm(graph, options);
                return {
                    value: `${previous.value}\nGRAPH ${graphStr.value} {\n${triplePatterns.value}\n}`,
                    prefixes: [...previous.prefixes, ...graphStr.prefixes, ...triplePatterns.prefixes],
                };
            }
        }, {
            value: '',
            prefixes: [],
        });
    }
    evaluateQuad(quad, options) {
        const subject = this.evaluateTerm(quad.subject, options);
        const predicate = this.evaluateTerm(quad.predicate, options);
        const object = this.evaluateTerm(quad.object, options);
        let pattern = `${subject.value} ${predicate.value} ${object.value} .`;
        let prefixes = [
            ...subject.prefixes,
            ...predicate.prefixes,
            ...object.prefixes,
        ];
        if (!data_model_1.defaultGraphInstance.equals(quad.graph)) {
            const graph = this.evaluateTerm(quad.graph, options);
            pattern = `GRAPH ${graph.value} { ${pattern} }`;
            prefixes = [...prefixes, ...graph.prefixes];
        }
        return {
            value: pattern,
            prefixes,
        };
    }
    __evaluateTripleArray(quads, options) {
        return quads.reduce((previous, quad) => {
            const next = this.evaluateQuad(quad, options);
            return {
                value: `${previous.value}\n${next.value}`,
                prefixes: [...previous.prefixes, ...next.prefixes],
            };
        }, { value: '', prefixes: [] });
    }
}
exports.SparqlStrategy = SparqlStrategy;
exports.sparql = (strings, ...values) => new TemplateResult_1.TemplateResult({
    strings,
    values,
    tag: exports.sparql,
    strategy: new SparqlStrategy(),
    defaultOptions: {
        prologue: true,
    },
});
