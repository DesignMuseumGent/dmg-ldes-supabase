import RDF from '@rdf-esm/data-model';
import knownPrefixes from '@zazuko/rdf-vocabularies/prefixes';
import { SerializationStrategy, TemplateResult } from "./TemplateResult.mjs";
import * as syntax from "./syntax/turtle.mjs";
import { mapBuilders, getNamespaces } from "./prefixes.mjs";

function prefixDeclarations(prefixes, prefixMap) {
  return getNamespaces(prefixes, prefixMap).map(([prefix, ns]) => `@prefix ${prefix}: <${ns}> .`);
}

export class TurtleStrategy extends SerializationStrategy {
  evaluateBlankNode(term) {
    return {
      value: syntax.blankNode(term),
      prefixes: []
    };
  }

  evaluateLiteral(term, options) {
    return syntax.literal(term, options);
  }

  evaluateNamedNode(term, {
    base,
    prefixes
  }) {
    return syntax.namedNode(term, {
      base,
      prefixes
    });
  }

  evaluateVariable() {
    throw new Error('Turtle cannot serialize variables');
  }

  evaluateDataset(dataset, options) {
    const graphQuads = [...dataset.match(null, null, null, options.graph)];

    if (options.cheapCompression) {
      return this.__evaluateQuads(graphQuads, options);
    }

    const subjectMap = graphQuads.reduce((map, quad) => {
      let quads = map.get(quad.subject.value);

      if (!quads) {
        quads = new Set();
        map.set(quad.subject.value, quads);
      }

      quads.add(quad);
      return map;
    }, new Map());
    return [...subjectMap.values()].reduce((result, quads, index) => {
      const nextSubject = this.__evaluateQuads([...quads], options);

      const separator = index ? '\n' : '';
      return {
        value: `${result.value}${separator}${nextSubject.value}`,
        prefixes: [...result.prefixes, ...nextSubject.prefixes]
      };
    }, {
      value: '',
      prefixes: []
    });
  }

  evaluateQuad(quad, options, {
    terminate = true,
    newLineAfterSubject = false
  } = {}) {
    if (!options.graph.equals(quad.graph)) {
      return {
        value: '',
        prefixes: []
      };
    }

    const subject = this.evaluateTerm(quad.subject, options);
    const predicate = this.evaluateTerm(quad.predicate, options);
    const object = this.evaluateTerm(quad.object, options);
    const predicateSeparator = newLineAfterSubject ? '\n   ' : ' ';
    return {
      value: `${subject.value}${predicateSeparator}${predicate.value} ${object.value}${terminate ? ' .' : ''}`,
      prefixes: [...subject.prefixes, ...predicate.prefixes, ...object.prefixes]
    };
  }

  getFinalString(result, prefixes, options) {
    const prologue = options.directives || typeof options.directives === 'undefined';
    let prologueLines = [];

    if (prologue) {
      prologueLines = prefixDeclarations(prefixes, { ...knownPrefixes,
        ...mapBuilders(options.prefixes)
      });

      if (options.base) {
        const baseStr = typeof options.base === 'string' ? options.base : options.base.value;
        prologueLines.push(`@base <${baseStr}> .`);
      }

      if (prologueLines.length > 0) {
        prologueLines.push('\n');
      }
    }

    return `${prologueLines.join('\n')}${result}`;
  }

  __evaluateQuads(quads, options) {
    if (quads.length === 0) {
      return {
        value: '',
        prefixes: []
      };
    }

    let orderedQuads = quads;

    if (!options.cheapCompression) {
      orderedQuads = quads.sort((left, right) => left.predicate.value.localeCompare(right.predicate.value));
    }

    const result = orderedQuads.reduce((context, quad) => {
      if (!context.previous) {
        return { ...this.evaluateQuad(quad, options, {
            terminate: false,
            newLineAfterSubject: true
          }),
          previous: quad
        };
      }

      if (context.previous.subject.equals(quad.subject) && context.previous.predicate.equals(quad.predicate)) {
        return { ...this.__appendObject(context, quad, options),
          previous: quad
        };
      }

      if (context.previous.subject.equals(quad.subject)) {
        return { ...this.__appendPredicateObject(context, quad, options),
          previous: quad
        };
      }

      const quadResult = this.evaluateQuad(quad, options, {
        terminate: false,
        newLineAfterSubject: true
      });
      return {
        value: context.value + ' .\n' + quadResult.value,
        prefixes: [...context.prefixes, ...quadResult.prefixes],
        previous: quad
      };
    }, {
      value: '',
      prefixes: []
    });
    return { ...result,
      value: result.value + ' .'
    };
  }

  __appendPredicateObject(context, quad, options) {
    const currentPredicateResult = this.evaluateTerm(quad.predicate, options);
    const currentObjectResult = this.evaluateTerm(quad.object, options);
    return {
      value: `${context.value} ;\n   ${currentPredicateResult.value} ${currentObjectResult.value}`,
      prefixes: [...context.prefixes, ...currentPredicateResult.prefixes, ...currentObjectResult.prefixes]
    };
  }

  __appendObject(context, quad, options) {
    const currentObjectResult = this.evaluateTerm(quad.object, options);
    return {
      value: `${context.value} ,\n      ${currentObjectResult.value}`,
      prefixes: [...context.prefixes, ...currentObjectResult.prefixes]
    };
  }

}
export const turtle = (strings, ...values) => new TemplateResult({
  strings,
  values,
  tag: turtle,
  strategy: new TurtleStrategy(),
  defaultOptions: {
    directives: true,
    graph: RDF.defaultGraph(),
    cheapCompression: false
  }
});