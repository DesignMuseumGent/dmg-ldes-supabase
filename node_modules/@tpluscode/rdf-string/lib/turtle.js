"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.turtle = exports.TurtleStrategy = void 0;
const data_model_1 = __importDefault(require("@rdf-esm/data-model"));
const prefixes_1 = __importDefault(require("@zazuko/rdf-vocabularies/prefixes"));
const TemplateResult_1 = require("./TemplateResult");
const syntax = __importStar(require("./syntax/turtle"));
const prefixes_2 = require("./prefixes");
function prefixDeclarations(prefixes, prefixMap) {
    return prefixes_2.getNamespaces(prefixes, prefixMap)
        .map(([prefix, ns]) => `@prefix ${prefix}: <${ns}> .`);
}
class TurtleStrategy extends TemplateResult_1.SerializationStrategy {
    evaluateBlankNode(term) {
        return {
            value: syntax.blankNode(term),
            prefixes: [],
        };
    }
    evaluateLiteral(term, options) {
        return syntax.literal(term, options);
    }
    evaluateNamedNode(term, { base, prefixes }) {
        return syntax.namedNode(term, { base, prefixes });
    }
    evaluateVariable() {
        throw new Error('Turtle cannot serialize variables');
    }
    evaluateDataset(dataset, options) {
        const graphQuads = [...dataset.match(null, null, null, options.graph)];
        if (options.cheapCompression) {
            return this.__evaluateQuads(graphQuads, options);
        }
        const subjectMap = graphQuads.reduce((map, quad) => {
            let quads = map.get(quad.subject.value);
            if (!quads) {
                quads = new Set();
                map.set(quad.subject.value, quads);
            }
            quads.add(quad);
            return map;
        }, new Map());
        return [...subjectMap.values()].reduce((result, quads, index) => {
            const nextSubject = this.__evaluateQuads([...quads], options);
            const separator = index ? '\n' : '';
            return {
                value: `${result.value}${separator}${nextSubject.value}`,
                prefixes: [...result.prefixes, ...nextSubject.prefixes],
            };
        }, { value: '', prefixes: [] });
    }
    evaluateQuad(quad, options, { terminate = true, newLineAfterSubject = false } = {}) {
        if (!options.graph.equals(quad.graph)) {
            return {
                value: '',
                prefixes: [],
            };
        }
        const subject = this.evaluateTerm(quad.subject, options);
        const predicate = this.evaluateTerm(quad.predicate, options);
        const object = this.evaluateTerm(quad.object, options);
        const predicateSeparator = newLineAfterSubject ? '\n   ' : ' ';
        return {
            value: `${subject.value}${predicateSeparator}${predicate.value} ${object.value}${terminate ? ' .' : ''}`,
            prefixes: [
                ...subject.prefixes,
                ...predicate.prefixes,
                ...object.prefixes,
            ],
        };
    }
    getFinalString(result, prefixes, options) {
        const prologue = options.directives || typeof options.directives === 'undefined';
        let prologueLines = [];
        if (prologue) {
            prologueLines = prefixDeclarations(prefixes, {
                ...prefixes_1.default,
                ...prefixes_2.mapBuilders(options.prefixes),
            });
            if (options.base) {
                const baseStr = typeof options.base === 'string' ? options.base : options.base.value;
                prologueLines.push(`@base <${baseStr}> .`);
            }
            if (prologueLines.length > 0) {
                prologueLines.push('\n');
            }
        }
        return `${prologueLines.join('\n')}${result}`;
    }
    __evaluateQuads(quads, options) {
        if (quads.length === 0) {
            return {
                value: '',
                prefixes: [],
            };
        }
        let orderedQuads = quads;
        if (!options.cheapCompression) {
            orderedQuads = quads.sort((left, right) => left.predicate.value.localeCompare(right.predicate.value));
        }
        const result = orderedQuads.reduce((context, quad) => {
            if (!context.previous) {
                return {
                    ...this.evaluateQuad(quad, options, {
                        terminate: false,
                        newLineAfterSubject: true,
                    }),
                    previous: quad,
                };
            }
            if (context.previous.subject.equals(quad.subject) && context.previous.predicate.equals(quad.predicate)) {
                return {
                    ...this.__appendObject(context, quad, options),
                    previous: quad,
                };
            }
            if (context.previous.subject.equals(quad.subject)) {
                return {
                    ...this.__appendPredicateObject(context, quad, options),
                    previous: quad,
                };
            }
            const quadResult = this.evaluateQuad(quad, options, {
                terminate: false,
                newLineAfterSubject: true,
            });
            return {
                value: context.value + ' .\n' + quadResult.value,
                prefixes: [...context.prefixes, ...quadResult.prefixes],
                previous: quad,
            };
        }, { value: '', prefixes: [] });
        return {
            ...result,
            value: result.value + ' .',
        };
    }
    __appendPredicateObject(context, quad, options) {
        const currentPredicateResult = this.evaluateTerm(quad.predicate, options);
        const currentObjectResult = this.evaluateTerm(quad.object, options);
        return {
            value: `${context.value} ;\n   ${currentPredicateResult.value} ${currentObjectResult.value}`,
            prefixes: [...context.prefixes, ...currentPredicateResult.prefixes, ...currentObjectResult.prefixes],
        };
    }
    __appendObject(context, quad, options) {
        const currentObjectResult = this.evaluateTerm(quad.object, options);
        return {
            value: `${context.value} ,\n      ${currentObjectResult.value}`,
            prefixes: [...context.prefixes, ...currentObjectResult.prefixes],
        };
    }
}
exports.TurtleStrategy = TurtleStrategy;
exports.turtle = (strings, ...values) => new TemplateResult_1.TemplateResult({
    strings,
    values,
    tag: exports.turtle,
    strategy: new TurtleStrategy(),
    defaultOptions: {
        directives: true,
        graph: data_model_1.default.defaultGraph(),
        cheapCompression: false,
    },
});
