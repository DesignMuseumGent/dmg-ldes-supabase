import knownPrefixes from '@zazuko/rdf-vocabularies/prefixes';
import { defaultGraphInstance, quad } from '@rdf-esm/data-model';
import TermMap from '@rdf-esm/term-map';
import { SerializationStrategy, TemplateResult } from "./TemplateResult.mjs";
import * as turtleSyntax from "./syntax/turtle.mjs";
import { getNamespaces, mapBuilders } from "./prefixes.mjs";

function prefixDeclarations(prefixes, prefixMap) {
  return getNamespaces(prefixes, prefixMap).map(([prefix, ns]) => `PREFIX ${prefix}: <${ns}>`);
}

function toTriple({
  subject,
  predicate,
  object
}) {
  return quad(subject, predicate, object);
}

export class SparqlStrategy extends SerializationStrategy {
  evaluateLiteral(term, options) {
    return turtleSyntax.literal(term, options);
  }

  evaluateNamedNode(term, options) {
    return turtleSyntax.namedNode(term, options);
  }

  evaluateBlankNode(term) {
    return {
      value: turtleSyntax.blankNode(term),
      prefixes: []
    };
  }

  evaluateVariable(term) {
    return {
      value: `?${term.value}`,
      prefixes: []
    };
  }

  getFinalString(result, prefixes, options) {
    const prologue = options.prologue || typeof options.prologue === 'undefined';
    let prologueLines = [];

    if (prologue) {
      prologueLines = prefixDeclarations(prefixes, { ...knownPrefixes,
        ...mapBuilders(options.prefixes)
      });

      if (options.base) {
        prologueLines = [`BASE <${options.base}>`, ...prologueLines];
      }

      if (prologueLines.length > 0) {
        prologueLines.push('\n');
      }
    }

    return `${prologueLines.join('\n')}${result}`;
  }

  evaluateDataset(dataset, options) {
    const graphs = [...dataset].reduce((graphs, quad) => {
      const namedGraph = graphs.get(quad.graph) || [];
      graphs.set(quad.graph, [...namedGraph, toTriple(quad)]);
      return graphs;
    }, new TermMap());
    return [...graphs.entries()].reduce((previous, [graph, quads]) => {
      const triplePatterns = this.__evaluateTripleArray(quads, options);

      if (defaultGraphInstance.equals(graph)) {
        return {
          value: `${previous.value}\n${triplePatterns.value}`,
          prefixes: [...previous.prefixes, ...triplePatterns.prefixes]
        };
      } else {
        const graphStr = this.evaluateTerm(graph, options);
        return {
          value: `${previous.value}\nGRAPH ${graphStr.value} {\n${triplePatterns.value}\n}`,
          prefixes: [...previous.prefixes, ...graphStr.prefixes, ...triplePatterns.prefixes]
        };
      }
    }, {
      value: '',
      prefixes: []
    });
  }

  evaluateQuad(quad, options) {
    const subject = this.evaluateTerm(quad.subject, options);
    const predicate = this.evaluateTerm(quad.predicate, options);
    const object = this.evaluateTerm(quad.object, options);
    let pattern = `${subject.value} ${predicate.value} ${object.value} .`;
    let prefixes = [...subject.prefixes, ...predicate.prefixes, ...object.prefixes];

    if (!defaultGraphInstance.equals(quad.graph)) {
      const graph = this.evaluateTerm(quad.graph, options);
      pattern = `GRAPH ${graph.value} { ${pattern} }`;
      prefixes = [...prefixes, ...graph.prefixes];
    }

    return {
      value: pattern,
      prefixes
    };
  }

  __evaluateTripleArray(quads, options) {
    return quads.reduce((previous, quad) => {
      const next = this.evaluateQuad(quad, options);
      return {
        value: `${previous.value}\n${next.value}`,
        prefixes: [...previous.prefixes, ...next.prefixes]
      };
    }, {
      value: '',
      prefixes: []
    });
  }

}
export const sparql = (strings, ...values) => new TemplateResult({
  strings,
  values,
  tag: sparql,
  strategy: new SparqlStrategy(),
  defaultOptions: {
    prologue: true
  }
});