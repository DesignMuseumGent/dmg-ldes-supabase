{"version":3,"file":"SparqlJsonParser.js","sourceRoot":"","sources":["SparqlJsonParser.ts"],"names":[],"mappings":"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","sourcesContent":["import {DataFactory} from \"rdf-data-factory\";\nimport * as RDF from \"@rdfjs/types\";\nimport {Transform} from \"readable-stream\";\n\n// tslint:disable-next-line:no-var-requires\nconst JsonParser = require('@bergos/jsonparse');\n\n/**\n * Parser for the SPARQL 1.1 Query Results JSON format.\n * @see https://www.w3.org/TR/sparql11-results-json/\n */\nexport class SparqlJsonParser {\n\n  private readonly dataFactory: RDF.DataFactory;\n  private readonly prefixVariableQuestionMark?: boolean;\n  private readonly suppressMissingStreamResultsError: boolean;\n\n  constructor(settings?: ISettings) {\n    settings = settings || {};\n    this.dataFactory = settings.dataFactory || new DataFactory();\n    this.prefixVariableQuestionMark = !!settings.prefixVariableQuestionMark;\n    this.suppressMissingStreamResultsError = settings.suppressMissingStreamResultsError ?? true;\n  }\n\n  /**\n   * Convert a SPARQL JSON bindings response to an array of bindings objects.\n   * @param sparqlResponse A SPARQL JSON response.\n   * @return {IBindings[]} An array of bindings.\n   */\n  public parseJsonResults(sparqlResponse: any): IBindings[] {\n    return sparqlResponse.results.bindings.map((rawBindings: any) => this.parseJsonBindings(rawBindings));\n  }\n\n  /**\n   * Convert a SPARQL JSON bindings response stream to a stream of bindings objects.\n   *\n   * The bindings stream will emit a 'variables' event that will contain\n   * the array of variables (as RDF.Variable[]), as defined in the response head.\n   *\n   * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL JSON response stream.\n   * @return {NodeJS.ReadableStream} A stream of bindings.\n   */\n  public parseJsonResultsStream(sparqlResponseStream: NodeJS.ReadableStream): NodeJS.ReadableStream {\n    const errorListener = (error: Error) => resultStream.emit('error', error);\n    sparqlResponseStream.on('error', errorListener);\n\n    const jsonParser = new JsonParser();\n    jsonParser.onError = errorListener;\n    let variablesFound = false;\n    let resultsFound = false;\n    jsonParser.onValue = (value: any) => {\n      if(jsonParser.key === \"vars\" && jsonParser.stack.length === 2 && jsonParser.stack[1].key === 'head') {\n        resultStream.emit('variables', value.map((v: string) => this.dataFactory.variable(v)));\n        variablesFound = true;\n      } else if(jsonParser.key === \"results\" && jsonParser.stack.length === 1) {\n        resultsFound = true;\n      } else if(typeof jsonParser.key === 'number' && jsonParser.stack.length === 3 && jsonParser.stack[1].key === 'results' && jsonParser.stack[2].key === 'bindings') {\n        try {\n          resultStream.push(this.parseJsonBindings(value))\n        } catch (error) {\n          resultStream.emit(\"error\", error);\n        }\n      } else if(jsonParser.key === \"metadata\" && jsonParser.stack.length === 1) {\n        resultStream.emit('metadata', value);\n      }\n    }\n\n    const resultStream = sparqlResponseStream\n      .on(\"end\", _ => {\n        if (!resultsFound && !this.suppressMissingStreamResultsError) {\n          resultStream.emit(\"error\", new Error(\"No valid SPARQL query results were found.\"))\n        } else if (!variablesFound) {\n          resultStream.emit('variables', []);\n        }\n      })\n      .pipe(new Transform({\n        objectMode: true,\n        transform(chunk: any, encoding: string, callback: (error?: Error | null, data?: any) => void) {\n          jsonParser.write(chunk);\n          callback();\n        }\n      }));\n    return resultStream;\n  }\n\n  /**\n   * Convert a SPARQL JSON result binding to a bindings object.\n   * @param rawBindings A SPARQL JSON result binding.\n   * @return {IBindings} A bindings object.\n   */\n  public parseJsonBindings(rawBindings: any): IBindings {\n    const bindings: IBindings = {};\n    for (const key in rawBindings) {\n      const rawValue: any = rawBindings[key];\n      bindings[this.prefixVariableQuestionMark ? ('?' + key) : key] = this.parseJsonValue(rawValue);\n    }\n    return bindings;\n  }\n\n  /**\n   * Convert a SPARQL JSON result value to an RDF term.\n   * @param rawValue A SPARQL JSON result value\n   * @return {RDF.Term} An RDF term.\n   */\n  public parseJsonValue(rawValue: any): RDF.Term {\n    let value: RDF.Term;\n    switch (rawValue.type) {\n    case 'bnode':\n      value = this.dataFactory.blankNode(rawValue.value);\n      break;\n    case 'literal':\n      if (rawValue['xml:lang']) {\n        value = this.dataFactory.literal(rawValue.value, rawValue['xml:lang']);\n      } else if (rawValue.datatype) {\n        value = this.dataFactory.literal(rawValue.value, this.dataFactory.namedNode(rawValue.datatype));\n      } else {\n        value = this.dataFactory.literal(rawValue.value);\n      }\n      break;\n    case 'typed-literal':\n      // Virtuoso uses this non-spec-compliant way of defining typed literals\n      value = this.dataFactory.literal(rawValue.value, this.dataFactory.namedNode(rawValue.datatype));\n      break;\n    case 'triple':\n      const tripleValue = rawValue.value;\n      if (!tripleValue || !tripleValue.subject || !tripleValue.predicate || !tripleValue.object) {\n        throw new Error('Invalid quoted triple: ' + JSON.stringify(rawValue));\n      }\n      value = this.dataFactory.quad(\n        <RDF.Quad_Subject> this.parseJsonValue(tripleValue.subject),\n        <RDF.Quad_Predicate> this.parseJsonValue(tripleValue.predicate),\n        <RDF.Quad_Object> this.parseJsonValue(tripleValue.object),\n      );\n      break;\n    default:\n      value = this.dataFactory.namedNode(rawValue.value);\n      break;\n    }\n    return value;\n  }\n\n  /**\n   * Convert a SPARQL JSON boolean response to a boolean.\n   * This will throw an error if the given reponse was not a valid boolean response.\n   * @param sparqlResponse A SPARQL JSON response.\n   * @return {IBindings[]} An array of bindings.\n   */\n  public parseJsonBoolean(sparqlResponse: any): boolean {\n    if ('boolean' in sparqlResponse) {\n      return sparqlResponse.boolean;\n    }\n    throw new Error('No valid ASK response was found.');\n  }\n\n  /**\n   * Convert a SPARQL JSON boolean response stream to a promise resolving to a boolean.\n   * This will reject if the given reponse was not a valid boolean response.\n   * @param {NodeJS.ReadableStream} sparqlResponseStream A SPARQL JSON response stream.\n   * @return {Promise<boolean>} The response boolean.\n   */\n  public parseJsonBooleanStream(sparqlResponseStream: NodeJS.ReadableStream): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      const parser = new JsonParser();\n      parser.onError = reject;\n      parser.onValue = (value: any) => {\n        if(parser.key === \"boolean\" && typeof value === 'boolean' && parser.stack.length === 1) {\n          resolve(value);\n        }\n      }\n      sparqlResponseStream\n          .on('error', reject)\n          .on('data', d => parser.write(d))\n          .on('end', () => reject(new Error('No valid ASK response was found.')));\n    });\n  }\n\n}\n\n/**\n * Constructor settings object interface for {@link SparqlJsonParser}.\n */\nexport interface ISettings {\n  /**\n   * A custom datafactory.\n   */\n  dataFactory?: RDF.DataFactory;\n  /**\n   * If variable names should be prefixed with a quotation mark.\n   */\n  prefixVariableQuestionMark?: boolean;\n  /**\n   * If the error about missing results in a result stream should be suppressed.\n   */\n  suppressMissingStreamResultsError?: boolean;\n}\n\n/**\n * A bindings object.\n */\nexport interface IBindings {\n  [key: string]: RDF.Term;\n}\n\n"]}