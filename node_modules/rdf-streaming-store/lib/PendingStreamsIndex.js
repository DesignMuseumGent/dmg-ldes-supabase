"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PendingStreamsIndex = void 0;
const rdf_string_1 = require("rdf-string");
const rdf_terms_1 = require("rdf-terms");
/**
 * A PendingStreamsIndex stores pending streams indexed by the quad pattern they have been created for.
 */
class PendingStreamsIndex {
    constructor() {
        this.indexedStreams = new Map();
        this.allStreams = [];
    }
    termToString(term) {
        return term && term.termType !== 'Variable' ? (0, rdf_string_1.termToString)(term) : PendingStreamsIndex.ID_VARIABLE;
    }
    /**
     * Add a new pending stream for the given quad pattern.
     * @param pendingStream A pending stream.
     * @param subject A term.
     * @param predicate A term.
     * @param object A term.
     * @param graph A term.
     */
    addPatternListener(pendingStream, subject, predicate, object, graph) {
        // Append to list of pendingStreams
        this.allStreams.push(pendingStream);
        // Append to index of pendingStreams
        const key = `${this.termToString(subject)}${PendingStreamsIndex.ID_SEPARATOR}${this.termToString(predicate)}${PendingStreamsIndex.ID_SEPARATOR}${this.termToString(object)}${PendingStreamsIndex.ID_SEPARATOR}${this.termToString(graph)}`;
        let existingListeners = this.indexedStreams.get(key);
        if (!existingListeners) {
            existingListeners = [];
            this.indexedStreams.set(key, existingListeners);
        }
        existingListeners.push(pendingStream);
    }
    /**
     * Find all the pending streams from which their quad pattern match the given quad.
     * @param quad The quad to match patterns to.
     */
    getPendingStreamsForQuad(quad) {
        // Determine the combinations of quad patterns to look up
        let keys = [(0, rdf_terms_1.getTerms)(quad).map(term => (0, rdf_string_1.termToString)(term))];
        for (let i = 0; i < rdf_terms_1.QUAD_TERM_NAMES.length; i++) {
            const keysOld = keys;
            keys = [];
            for (const key of keysOld) {
                keys.push(key);
                const keyModified = [...key];
                keyModified[i] = PendingStreamsIndex.ID_VARIABLE;
                keys.push(keyModified);
            }
        }
        // Fetch the pendingStreams for the quad pattern combinations
        const pendingStreams = [];
        for (const key of keys) {
            const found = this.indexedStreams.get(key.join(PendingStreamsIndex.ID_SEPARATOR));
            if (found) {
                pendingStreams.push(...found);
            }
        }
        return pendingStreams;
    }
}
exports.PendingStreamsIndex = PendingStreamsIndex;
PendingStreamsIndex.ID_VARIABLE = '?';
PendingStreamsIndex.ID_SEPARATOR = ':';
//# sourceMappingURL=PendingStreamsIndex.js.map