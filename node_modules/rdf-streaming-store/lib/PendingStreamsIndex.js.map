{"version":3,"file":"PendingStreamsIndex.js","sourceRoot":"","sources":["PendingStreamsIndex.ts"],"names":[],"mappings":";;;AACA,2CAA0C;AAC1C,yCAAsD;AAGtD;;GAEG;AACH,MAAa,mBAAmB;IAAhC;QAIkB,mBAAc,GAAG,IAAI,GAAG,EAAyB,CAAC;QAClD,eAAU,GAAkB,EAAE,CAAC;IAiEjD,CAAC;IA/DW,YAAY,CAAC,IAAsB;QAC3C,OAAO,IAAI,IAAI,IAAI,CAAC,QAAQ,KAAK,UAAU,CAAC,CAAC,CAAC,IAAA,yBAAY,EAAC,IAAI,CAAC,CAAC,CAAC,CAAC,mBAAmB,CAAC,WAAW,CAAC;IACrG,CAAC;IAED;;;;;;;OAOG;IACI,kBAAkB,CACvB,aAA0B,EAC1B,OAAyB,EACzB,SAA2B,EAC3B,MAAwB,EACxB,KAAuB;QAEvB,mCAAmC;QACnC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QAEpC,oCAAoC;QACpC,MAAM,GAAG,GAAG,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,GAAG,mBAAmB,CAAC,YAAY,GAC1E,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,GAAG,mBAAmB,CAAC,YAAY,GAC/D,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,GAAG,mBAAmB,CAAC,YAAY,GAC5D,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE,CAAC;QAC7B,IAAI,iBAAiB,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QACrD,IAAI,CAAC,iBAAiB,EAAE;YACtB,iBAAiB,GAAG,EAAE,CAAC;YACvB,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,EAAE,iBAAiB,CAAC,CAAC;SACjD;QACD,iBAAiB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;IACxC,CAAC;IAED;;;OAGG;IACI,wBAAwB,CAAC,IAAO;QACrC,yDAAyD;QACzD,IAAI,IAAI,GAAe,CAAE,IAAA,oBAAQ,EAAC,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAA,yBAAY,EAAC,IAAI,CAAC,CAAC,CAAE,CAAC;QAC1E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,2BAAe,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC/C,MAAM,OAAO,GAAG,IAAI,CAAC;YACrB,IAAI,GAAG,EAAE,CAAC;YACV,KAAK,MAAM,GAAG,IAAI,OAAO,EAAE;gBACzB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACf,MAAM,WAAW,GAAG,CAAE,GAAG,GAAG,CAAE,CAAC;gBAC/B,WAAW,CAAC,CAAC,CAAC,GAAG,mBAAmB,CAAC,WAAW,CAAC;gBACjD,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;aACxB;SACF;QAED,6DAA6D;QAC7D,MAAM,cAAc,GAAG,EAAE,CAAC;QAC1B,KAAK,MAAM,GAAG,IAAI,IAAI,EAAE;YACtB,MAAM,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAAC,CAAC,CAAC;YAClF,IAAI,KAAK,EAAE;gBACT,cAAc,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC;aAC/B;SACF;QACD,OAAO,cAAc,CAAC;IACxB,CAAC;;AArEH,kDAsEC;AArEyB,+BAAW,GAAG,GAAG,CAAC;AAClB,gCAAY,GAAG,GAAG,CAAC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { termToString } from 'rdf-string';\nimport { getTerms, QUAD_TERM_NAMES } from 'rdf-terms';\nimport type { PassThrough } from 'readable-stream';\n\n/**\n * A PendingStreamsIndex stores pending streams indexed by the quad pattern they have been created for.\n */\nexport class PendingStreamsIndex<Q extends RDF.BaseQuad = RDF.Quad> {\n  private static readonly ID_VARIABLE = '?';\n  private static readonly ID_SEPARATOR = ':';\n\n  public readonly indexedStreams = new Map<string, PassThrough[]>();\n  public readonly allStreams: PassThrough[] = [];\n\n  protected termToString(term?: RDF.Term | null): string {\n    return term && term.termType !== 'Variable' ? termToString(term) : PendingStreamsIndex.ID_VARIABLE;\n  }\n\n  /**\n   * Add a new pending stream for the given quad pattern.\n   * @param pendingStream A pending stream.\n   * @param subject A term.\n   * @param predicate A term.\n   * @param object A term.\n   * @param graph A term.\n   */\n  public addPatternListener(\n    pendingStream: PassThrough,\n    subject?: RDF.Term | null,\n    predicate?: RDF.Term | null,\n    object?: RDF.Term | null,\n    graph?: RDF.Term | null,\n  ): void {\n    // Append to list of pendingStreams\n    this.allStreams.push(pendingStream);\n\n    // Append to index of pendingStreams\n    const key = `${this.termToString(subject)}${PendingStreamsIndex.ID_SEPARATOR}${\n      this.termToString(predicate)}${PendingStreamsIndex.ID_SEPARATOR}${\n      this.termToString(object)}${PendingStreamsIndex.ID_SEPARATOR}${\n      this.termToString(graph)}`;\n    let existingListeners = this.indexedStreams.get(key);\n    if (!existingListeners) {\n      existingListeners = [];\n      this.indexedStreams.set(key, existingListeners);\n    }\n    existingListeners.push(pendingStream);\n  }\n\n  /**\n   * Find all the pending streams from which their quad pattern match the given quad.\n   * @param quad The quad to match patterns to.\n   */\n  public getPendingStreamsForQuad(quad: Q): PassThrough[] {\n    // Determine the combinations of quad patterns to look up\n    let keys: string[][] = [ getTerms(quad).map(term => termToString(term)) ];\n    for (let i = 0; i < QUAD_TERM_NAMES.length; i++) {\n      const keysOld = keys;\n      keys = [];\n      for (const key of keysOld) {\n        keys.push(key);\n        const keyModified = [ ...key ];\n        keyModified[i] = PendingStreamsIndex.ID_VARIABLE;\n        keys.push(keyModified);\n      }\n    }\n\n    // Fetch the pendingStreams for the quad pattern combinations\n    const pendingStreams = [];\n    for (const key of keys) {\n      const found = this.indexedStreams.get(key.join(PendingStreamsIndex.ID_SEPARATOR));\n      if (found) {\n        pendingStreams.push(...found);\n      }\n    }\n    return pendingStreams;\n  }\n}\n"]}