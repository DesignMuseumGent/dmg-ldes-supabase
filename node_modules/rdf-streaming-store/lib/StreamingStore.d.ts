/// <reference types="node" />
import type { EventEmitter } from 'events';
import type * as RDF from '@rdfjs/types';
import { Store } from 'n3';
import { PendingStreamsIndex } from './PendingStreamsIndex';
/**
 * A StreamingStore allows data lookup and insertion to happen in parallel.
 * Concretely, this means that `match()` calls happening before `import()` calls, will still consider those triples that
 * are inserted later, which is done by keeping the response streams of `match()` open.
 * Only when the `end()` method is invoked, all response streams will close, and the StreamingStore will be considered
 * immutable.
 *
 * WARNING: `end()` MUST be called at some point, otherwise all `match` streams will remain unended.
 */
export declare class StreamingStore<Q extends RDF.BaseQuad = RDF.Quad, S extends RDF.Store<Q> = Store<Q>> implements RDF.Source<Q>, RDF.Sink<RDF.Stream<Q>, EventEmitter> {
    protected readonly store: S;
    protected readonly pendingStreams: PendingStreamsIndex<Q>;
    protected ended: boolean;
    constructor(store?: RDF.Store<Q>);
    /**
     * Mark this store as ended.
     *
     * This will make sure that all running and future `match` calls will end,
     * and all next `import` calls to this store will throw an error.
     */
    end(): void;
    protected importToListeners(stream: RDF.Stream<Q>): void;
    import(stream: RDF.Stream<Q>): EventEmitter;
    match(subject?: RDF.Term | null, predicate?: RDF.Term | null, object?: RDF.Term | null, graph?: RDF.Term | null): RDF.Stream<Q>;
    /**
     * The internal store with all imported quads.
     */
    getStore(): S;
}
