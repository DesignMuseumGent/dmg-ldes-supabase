{"version":3,"file":"Ordering.js","sourceRoot":"","sources":["../../../lib/util/Ordering.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport * as LRUCache from 'lru-cache';\nimport type { LangStringLiteral } from '../expressions';\nimport { TermTransformer } from '../transformers/TermTransformer';\nimport { TypeAlias, TypeURL } from './Consts';\nimport type { ISuperTypeProvider, SuperTypeCallback, TypeCache, GeneralSuperTypeDict } from './TypeHandling';\nimport { getSuperTypeDict } from './TypeHandling';\n\n// Determine the relative numerical order of the two given terms.\n/**\n * @param enableExtendedXSDTypes System will behave like when this was true. @deprecated\n */\nexport function orderTypes(termA: RDF.Term | undefined, termB: RDF.Term | undefined, isAscending: boolean,\n  typeDiscoveryCallback?: SuperTypeCallback, typeCache?: TypeCache, enableExtendedXSDTypes?: boolean): -1 | 0 | 1 {\n  if (termA === termB) {\n    return 0;\n  }\n\n  // We handle undefined that is lower than everything else.\n  if (termA === undefined) {\n    return isAscending ? -1 : 1;\n  }\n  if (termB === undefined) {\n    return isAscending ? 1 : -1;\n  }\n\n  // We handle terms\n  if (termA.equals(termB)) {\n    return 0;\n  }\n  return isTermLowerThan(termA, termB, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes) === isAscending ?\n    -1 :\n    1;\n}\n\nfunction isTermLowerThan(termA: RDF.Term, termB: RDF.Term,\n  typeDiscoveryCallback?: SuperTypeCallback, typeCache?: TypeCache, enableExtendedXSDTypes?: boolean): boolean {\n  if (termA.termType !== termB.termType) {\n    return _TERM_ORDERING_PRIORITY[termA.termType] < _TERM_ORDERING_PRIORITY[termB.termType];\n  }\n  return termA.termType === 'Literal' ?\n    isLiteralLowerThan(termA, <RDF.Literal>termB, typeDiscoveryCallback, typeCache) :\n    termA.value < termB.value;\n}\n\nfunction isLiteralLowerThan(litA: RDF.Literal, litB: RDF.Literal,\n  typeDiscoveryCallback?: SuperTypeCallback, typeCache?: TypeCache): boolean {\n  const openWorldType: ISuperTypeProvider = {\n    discoverer: typeDiscoveryCallback || (() => 'term'),\n    cache: typeCache || new LRUCache(),\n  };\n  const termTransformer = new TermTransformer(openWorldType);\n  const myLitA = termTransformer.transformLiteral(litA);\n  const myLitB = termTransformer.transformLiteral(litB);\n  const typeA = myLitA.dataType;\n  const typeB = myLitB.dataType;\n\n  const superTypeDictA: GeneralSuperTypeDict = getSuperTypeDict(typeA, openWorldType);\n  const superTypeDictB: GeneralSuperTypeDict = getSuperTypeDict(typeB, openWorldType);\n\n  if (TypeURL.XSD_BOOLEAN in superTypeDictA && TypeURL.XSD_BOOLEAN in superTypeDictB ||\n      TypeURL.XSD_DATE_TIME in superTypeDictA && TypeURL.XSD_DATE_TIME in superTypeDictB ||\n      TypeAlias.SPARQL_NUMERIC in superTypeDictA && TypeAlias.SPARQL_NUMERIC in superTypeDictB ||\n      TypeURL.XSD_STRING in superTypeDictA && TypeURL.XSD_STRING in superTypeDictB) {\n    return myLitA.typedValue < myLitB.typedValue;\n  }\n  if (TypeURL.RDF_LANG_STRING in superTypeDictA && TypeURL.RDF_LANG_STRING in superTypeDictB) {\n    return myLitA.typedValue < myLitB.typedValue ||\n      (myLitA.typedValue === myLitB.typedValue &&\n        (<LangStringLiteral>myLitA).language < (<LangStringLiteral>myLitB).language);\n  }\n  return typeA < typeB || (myLitA.dataType === myLitB.dataType && myLitA.str() < myLitB.str());\n}\n\n// SPARQL specifies that blankNode < namedNode < literal.\nconst _TERM_ORDERING_PRIORITY = {\n  Variable: 0,\n  BlankNode: 1,\n  NamedNode: 2,\n  Literal: 3,\n  Quad: 4,\n  DefaultGraph: 5,\n};\n"]}