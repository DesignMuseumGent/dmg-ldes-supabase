"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.orderTypes = void 0;
const LRUCache = require("lru-cache");
const TermTransformer_1 = require("../transformers/TermTransformer");
const Consts_1 = require("./Consts");
const TypeHandling_1 = require("./TypeHandling");
// Determine the relative numerical order of the two given terms.
/**
 * @param enableExtendedXSDTypes System will behave like when this was true. @deprecated
 */
function orderTypes(termA, termB, isAscending, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes) {
    if (termA === termB) {
        return 0;
    }
    // We handle undefined that is lower than everything else.
    if (termA === undefined) {
        return isAscending ? -1 : 1;
    }
    if (termB === undefined) {
        return isAscending ? 1 : -1;
    }
    // We handle terms
    if (termA.equals(termB)) {
        return 0;
    }
    return isTermLowerThan(termA, termB, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes) === isAscending ?
        -1 :
        1;
}
exports.orderTypes = orderTypes;
function isTermLowerThan(termA, termB, typeDiscoveryCallback, typeCache, enableExtendedXSDTypes) {
    if (termA.termType !== termB.termType) {
        return _TERM_ORDERING_PRIORITY[termA.termType] < _TERM_ORDERING_PRIORITY[termB.termType];
    }
    return termA.termType === 'Literal' ?
        isLiteralLowerThan(termA, termB, typeDiscoveryCallback, typeCache) :
        termA.value < termB.value;
}
function isLiteralLowerThan(litA, litB, typeDiscoveryCallback, typeCache) {
    const openWorldType = {
        discoverer: typeDiscoveryCallback || (() => 'term'),
        cache: typeCache || new LRUCache(),
    };
    const termTransformer = new TermTransformer_1.TermTransformer(openWorldType);
    const myLitA = termTransformer.transformLiteral(litA);
    const myLitB = termTransformer.transformLiteral(litB);
    const typeA = myLitA.dataType;
    const typeB = myLitB.dataType;
    const superTypeDictA = (0, TypeHandling_1.getSuperTypeDict)(typeA, openWorldType);
    const superTypeDictB = (0, TypeHandling_1.getSuperTypeDict)(typeB, openWorldType);
    if (Consts_1.TypeURL.XSD_BOOLEAN in superTypeDictA && Consts_1.TypeURL.XSD_BOOLEAN in superTypeDictB ||
        Consts_1.TypeURL.XSD_DATE_TIME in superTypeDictA && Consts_1.TypeURL.XSD_DATE_TIME in superTypeDictB ||
        Consts_1.TypeAlias.SPARQL_NUMERIC in superTypeDictA && Consts_1.TypeAlias.SPARQL_NUMERIC in superTypeDictB ||
        Consts_1.TypeURL.XSD_STRING in superTypeDictA && Consts_1.TypeURL.XSD_STRING in superTypeDictB) {
        return myLitA.typedValue < myLitB.typedValue;
    }
    if (Consts_1.TypeURL.RDF_LANG_STRING in superTypeDictA && Consts_1.TypeURL.RDF_LANG_STRING in superTypeDictB) {
        return myLitA.typedValue < myLitB.typedValue ||
            (myLitA.typedValue === myLitB.typedValue &&
                myLitA.language < myLitB.language);
    }
    return typeA < typeB || (myLitA.dataType === myLitB.dataType && myLitA.str() < myLitB.str());
}
// SPARQL specifies that blankNode < namedNode < literal.
const _TERM_ORDERING_PRIORITY = {
    Variable: 0,
    BlankNode: 1,
    NamedNode: 2,
    Literal: 3,
    Quad: 4,
    DefaultGraph: 5,
};
//# sourceMappingURL=Ordering.js.map