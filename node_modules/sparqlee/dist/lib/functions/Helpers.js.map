{"version":3,"file":"Helpers.js","sourceRoot":"","sources":["../../../lib/functions/Helpers.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * These helpers provide a (albeit inflexible) DSL for writing function\n * definitions for the SPARQL functions.\n */\nimport type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport type { ICompleteSharedContext } from '../evaluators/evaluatorHelpers/BaseExpressionEvaluator';\nimport type { Literal } from '../expressions';\nimport * as E from '../expressions';\nimport * as C from '../util/Consts';\nimport { TypeURL } from '../util/Consts';\nimport * as Err from '../util/Errors';\nimport type { ArgumentType } from './Core';\nimport type { ImplementationFunction } from './OverloadTree';\nimport { OverloadTree } from './OverloadTree';\n\ntype Term = E.TermExpression;\n\nconst DF = new DataFactory();\n\nexport function declare(identifier: string): Builder {\n  return new Builder(identifier);\n}\n\nexport class Builder {\n  private readonly overloadTree: OverloadTree;\n  private collected: boolean;\n\n  public constructor(identifier: string) {\n    this.overloadTree = new OverloadTree(identifier);\n    this.collected = false;\n  }\n\n  public collect(): OverloadTree {\n    if (this.collected) {\n      // Only 1 time allowed because we can't copy a tree. (And we don't need this).\n      throw new Error('Builders can only be collected once!');\n    }\n    this.collected = true;\n    return this.overloadTree;\n  }\n\n  public set(argTypes: ArgumentType[], func: ImplementationFunction): Builder {\n    this.overloadTree.addOverload(argTypes, func);\n    return this;\n  }\n\n  public copy({ from, to }: { from: ArgumentType[]; to: ArgumentType[] }): Builder {\n    const impl = this.overloadTree.getImplementationExact(from);\n    if (!impl) {\n      throw new Err.UnexpectedError(\n        'Tried to copy implementation, but types not found',\n        { from, to },\n      );\n    }\n    return this.set(to, impl);\n  }\n\n  public onUnary<T extends Term>(type: ArgumentType, op: (context: ICompleteSharedContext) =>\n  (val: T) => Term): Builder {\n    return this.set([ type ], context => ([ val ]: [T]) => op(context)(val));\n  }\n\n  public onUnaryTyped<T>(type: ArgumentType,\n    op: (context: ICompleteSharedContext) => (val: T) => Term): Builder {\n    return this.set([ type ], context => ([ val ]: [E.Literal<T>]) => op(context)(val.typedValue));\n  }\n\n  public onBinary<L extends Term, R extends Term>(types: ArgumentType[],\n    op: (context: ICompleteSharedContext) => (left: L, right: R) => Term): Builder {\n    return this.set(types, context => ([ left, right ]: [L, R]) => op(context)(left, right));\n  }\n\n  public onBinaryTyped<L, R>(types: ArgumentType[],\n    op: (context: ICompleteSharedContext) => (left: L, right: R) => Term): Builder {\n    return this.set(types, context =>\n      ([ left, right ]: [E.Literal<L>, E.Literal<R>]) => op(context)(left.typedValue, right.typedValue));\n  }\n\n  public onTernaryTyped<A1, A2, A3>(types: ArgumentType[],\n    op: (context: ICompleteSharedContext) => (a1: A1, a2: A2, a3: A3) => Term): Builder {\n    return this.set(types, context => ([ a1, a2, a3 ]: [E.Literal<A1>, E.Literal<A2>, E.Literal<A3>]) =>\n      op(context)(a1.typedValue, a2.typedValue, a3.typedValue));\n  }\n\n  public onTernary<A1 extends Term, A2 extends Term, A3 extends Term>(types: ArgumentType[],\n    op: (context: ICompleteSharedContext) => (a1: A1, a2: A2, a3: A3) => Term): Builder {\n    return this.set(types, context => ([ a1, a2, a3 ]: [A1, A2, A3]) => op(context)(a1, a2, a3));\n  }\n\n  public onQuaternaryTyped<A1, A2, A3, A4>(types: ArgumentType[],\n    op: (context: ICompleteSharedContext) => (a1: A1, a2: A2, a3: A3, a4: A4) => Term): Builder {\n    return this.set(types, context =>\n      ([ a1, a2, a3, a4 ]: [E.Literal<A1>, E.Literal<A2>, E.Literal<A3>, E.Literal<A4>]) =>\n        op(context)(a1.typedValue, a2.typedValue, a3.typedValue, a4.typedValue));\n  }\n\n  public onTerm1(op: (context: ICompleteSharedContext) => (term: Term) => Term): Builder {\n    return this.set([ 'term' ], context => ([ term ]: [Term]) => op(context)(term));\n  }\n\n  public onLiteral1<T>(op: (context: ICompleteSharedContext) => (lit: E.Literal<T>) => Term): Builder {\n    return this.set([ 'literal' ], context => ([ term ]: [E.Literal<T>]) => op(context)(term));\n  }\n\n  public onBoolean1(op: (context: ICompleteSharedContext) => (lit: E.BooleanLiteral) => Term): Builder {\n    return this\n      .set([ C.TypeURL.XSD_BOOLEAN ], context => ([ lit ]: [E.BooleanLiteral]) => op(context)(lit));\n  }\n\n  public onBoolean1Typed(op: (context: ICompleteSharedContext) => (lit: boolean) => Term): Builder {\n    return this\n      .set([ C.TypeURL.XSD_BOOLEAN ], context => ([ lit ]: [E.BooleanLiteral]) => op(context)(lit.typedValue));\n  }\n\n  public onString1(op: (context: ICompleteSharedContext) => (lit: E.Literal<string>) => Term): Builder {\n    return this\n      .set([ C.TypeURL.XSD_STRING ], context => ([ lit ]: [E.Literal<string>]) => op(context)(lit));\n  }\n\n  public onString1Typed(op: (context: ICompleteSharedContext) => (lit: string) => Term): Builder {\n    return this\n      .set([ C.TypeURL.XSD_STRING ], context => ([ lit ]: [E.Literal<string>]) => op(context)(lit.typedValue));\n  }\n\n  public onLangString1(op: (context: ICompleteSharedContext) => (lit: E.LangStringLiteral) => Term): Builder {\n    return this\n      .set([ C.TypeURL.RDF_LANG_STRING ], context => ([ lit ]: [E.LangStringLiteral]) => op(context)(lit));\n  }\n\n  public onStringly1(op: (context: ICompleteSharedContext) => (lit: E.Literal<string>) => Term): Builder {\n    return this\n      .set([ C.TypeAlias.SPARQL_STRINGLY ], context => ([ lit ]: [E.Literal<string>]) => op(context)(lit));\n  }\n\n  public onStringly1Typed(op: (context: ICompleteSharedContext) => (lit: string) => Term): Builder {\n    return this\n      .set([ C.TypeAlias.SPARQL_STRINGLY ], context => ([ lit ]: [E.Literal<string>]) => op(context)(lit.typedValue));\n  }\n\n  public onNumeric1(op: (context: ICompleteSharedContext) => (val: E.NumericLiteral) => Term): Builder {\n    return this\n      .set([ C.TypeAlias.SPARQL_NUMERIC ], context => ([ val ]: [E.NumericLiteral]) => op(context)(val))\n      .invalidLexicalForm([ C.TypeAlias.SPARQL_NON_LEXICAL ], 1);\n  }\n\n  public onDateTime1(op: (context: ICompleteSharedContext) => (date: E.DateTimeLiteral) => Term): Builder {\n    return this\n      .set([ C.TypeURL.XSD_DATE_TIME ], context => ([ val ]: [E.DateTimeLiteral]) => op(context)(val))\n      .invalidLexicalForm([ C.TypeAlias.SPARQL_NON_LEXICAL ], 1);\n  }\n\n  /**\n   * We return the base types and not the provided types because we don't want to create invalid terms.\n   * Providing negative number to a function unary - for example should not\n   * return a term of type negative number having a positive value.\n   * @param op the numeric operator performed\n   */\n  public numericConverter(op: (context: ICompleteSharedContext) => (val: number) => number): Builder {\n    const evalHelper = (context: ICompleteSharedContext) => (arg: Term): number =>\n      op(context)((<Literal<number>>arg).typedValue);\n    return this.onBinary([ TypeURL.XSD_INTEGER ], context => arg =>\n      integer(evalHelper(context)(arg)))\n      .onBinary([ TypeURL.XSD_DECIMAL ], context => arg =>\n        decimal(evalHelper(context)(arg)))\n      .onBinary([ TypeURL.XSD_FLOAT ], context => arg =>\n        float(evalHelper(context)(arg)))\n      .onBinary([ TypeURL.XSD_DOUBLE ], context => arg =>\n        double(evalHelper(context)(arg)))\n      .invalidLexicalForm([ C.TypeAlias.SPARQL_NON_LEXICAL ], 1);\n  }\n\n  /**\n   * !!! Be aware when using this function, it will create different overloads with different return types !!!\n   * Arithmetic operators take 2 numeric arguments, and return a single numerical\n   * value. The type of the return value is heavily dependant on the types of the\n   * input arguments. In JS everything is a double, but in SPARQL it is not.\n   *\n   * The different arguments are handled by type promotion and subtype substitution.\n   * The way numeric function arguments work is described here:\n   * https://www.w3.org/TR/xpath20/#mapping\n   * Above url is referenced in the sparql spec: https://www.w3.org/TR/sparql11-query/#OperatorMapping\n   */\n  public arithmetic(op: (context: ICompleteSharedContext) => (left: number, right: number) => number): Builder {\n    const evalHelper = (context: ICompleteSharedContext) => (left: Term, right: Term): number =>\n      op(context)((<Literal<number>>left).typedValue, (<Literal<number>>right).typedValue);\n    return this.onBinary([ TypeURL.XSD_INTEGER, TypeURL.XSD_INTEGER ], context => (left, right) =>\n      integer(evalHelper(context)(left, right)))\n      .onBinary([ TypeURL.XSD_DECIMAL, TypeURL.XSD_DECIMAL ], context => (left, right) =>\n        decimal(evalHelper(context)(left, right)))\n      .onBinary([ TypeURL.XSD_FLOAT, TypeURL.XSD_FLOAT ], context => (left, right) =>\n        float(evalHelper(context)(left, right)))\n      .onBinary([ TypeURL.XSD_DOUBLE, TypeURL.XSD_DOUBLE ], context => (left, right) =>\n        double(evalHelper(context)(left, right)));\n  }\n\n  public numberTest(test: (context: ICompleteSharedContext) => (left: number, right: number) => boolean): Builder {\n    return this.numeric(context => ([ left, right ]: E.NumericLiteral[]) => {\n      const result = test(context)(left.typedValue, right.typedValue);\n      return bool(result);\n    });\n  }\n\n  public stringTest(test: (context: ICompleteSharedContext) => (left: string, right: string) => boolean): Builder {\n    return this\n      .set(\n        [ C.TypeURL.XSD_STRING, C.TypeURL.XSD_STRING ],\n        context => ([ left, right ]: E.StringLiteral[]) => {\n          const result = test(context)(left.typedValue, right.typedValue);\n          return bool(result);\n        },\n      )\n      .invalidLexicalForm([ C.TypeAlias.SPARQL_NON_LEXICAL, C.TypeURL.XSD_STRING ], 1)\n      .invalidLexicalForm([ C.TypeURL.XSD_STRING, C.TypeAlias.SPARQL_NON_LEXICAL ], 2);\n  }\n\n  public booleanTest(test: (context: ICompleteSharedContext) => (left: boolean, right: boolean) => boolean): Builder {\n    return this\n      .set(\n        [ C.TypeURL.XSD_BOOLEAN, C.TypeURL.XSD_BOOLEAN ],\n        context => ([ left, right ]: E.BooleanLiteral[]) => {\n          const result = test(context)(left.typedValue, right.typedValue);\n          return bool(result);\n        },\n      )\n      .invalidLexicalForm([ C.TypeAlias.SPARQL_NON_LEXICAL, C.TypeURL.XSD_BOOLEAN ], 1)\n      .invalidLexicalForm([ C.TypeURL.XSD_BOOLEAN, C.TypeAlias.SPARQL_NON_LEXICAL ], 2);\n  }\n\n  public dateTimeTest(test: (context: ICompleteSharedContext) => (left: Date, right: Date) => boolean): Builder {\n    return this\n      .set(\n        [ C.TypeURL.XSD_DATE_TIME, C.TypeURL.XSD_DATE_TIME ],\n        context => ([ left, right ]: E.DateTimeLiteral[]) => {\n          const result = test(context)(left.typedValue, right.typedValue);\n          return bool(result);\n        },\n      )\n      .invalidLexicalForm([ C.TypeAlias.SPARQL_NON_LEXICAL, C.TypeURL.XSD_DATE_TIME ], 1)\n      .invalidLexicalForm([ C.TypeURL.XSD_DATE_TIME, C.TypeAlias.SPARQL_NON_LEXICAL ], 2);\n  }\n\n  public numeric(op: ImplementationFunction): Builder {\n    return this\n      .set([ C.TypeAlias.SPARQL_NUMERIC, C.TypeAlias.SPARQL_NUMERIC ], op)\n      .invalidLexicalForm([ C.TypeAlias.SPARQL_NUMERIC, C.TypeAlias.SPARQL_NON_LEXICAL ], 2)\n      .invalidLexicalForm([ C.TypeAlias.SPARQL_NON_LEXICAL, C.TypeAlias.SPARQL_NUMERIC ], 1);\n  }\n\n  public invalidLexicalForm(types: ArgumentType[], index: number): Builder {\n    return this.set(types, () => (args: Term[]): E.TermExpression => {\n      throw new Err.InvalidLexicalForm(args[index - 1].toRDF());\n    });\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Literal Construction helpers\n// ----------------------------------------------------------------------------\n\nexport function bool(val: boolean): E.BooleanLiteral {\n  return new E.BooleanLiteral(val);\n}\n\nexport function integer(num: number): E.IntegerLiteral {\n  return new E.IntegerLiteral(num);\n}\n\nexport function decimal(num: number): E.DecimalLiteral {\n  return new E.DecimalLiteral(num);\n}\n\nexport function float(num: number): E.FloatLiteral {\n  return new E.FloatLiteral(num);\n}\n\nexport function double(num: number): E.DoubleLiteral {\n  return new E.DoubleLiteral(num);\n}\n\nexport function string(str: string): E.StringLiteral {\n  return new E.StringLiteral(str);\n}\n\nexport function langString(str: string, lang: string): E.LangStringLiteral {\n  return new E.LangStringLiteral(str, lang);\n}\n\nexport function dateTime(date: Date, str: string): E.DateTimeLiteral {\n  return new E.DateTimeLiteral(date, str);\n}\n\nexport function expressionToVar(variableExpression: E.VariableExpression): RDF.Variable {\n  return DF.variable(variableExpression.name.slice(1));\n}\n"]}