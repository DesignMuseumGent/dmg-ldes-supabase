{"version":3,"file":"OverloadTree.js","sourceRoot":"","sources":["../../../lib/functions/OverloadTree.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ICompleteSharedContext } from '../evaluators/evaluatorHelpers/BaseExpressionEvaluator';\nimport type * as E from '../expressions';\nimport { isLiteralTermExpression } from '../expressions';\nimport type { KnownLiteralTypes } from '../util/Consts';\nimport { TypeURL } from '../util/Consts';\nimport type { GeneralSuperTypeDict, ISuperTypeProvider, OverrideType } from '../util/TypeHandling';\nimport {\n  asGeneralType,\n  asKnownLiteralType,\n  asOverrideType,\n  getSuperTypes,\n  superTypeDictTable,\n} from '../util/TypeHandling';\nimport type { ArgumentType } from './Core';\nimport { double, float, string } from './Helpers';\n\nexport type SearchStack = OverloadTree[];\nexport type ImplementationFunction = (sharedContext: ICompleteSharedContext) => E.SimpleApplication;\ninterface IFunctionArgumentsCacheObj {\n  func?: ImplementationFunction; cache?: FunctionArgumentsCache;\n}\nexport type FunctionArgumentsCache = Record<string, IFunctionArgumentsCacheObj>;\n/**\n * Maps argument types on their specific implementation in a tree like structure.\n * When adding any functionality to this class, make sure you add it to SpecialFunctions as well.\n */\nexport class OverloadTree {\n  private implementation?: ImplementationFunction | undefined;\n  // We need this field. e.g. decimal decimal should be kept even when double double is added.\n  // We use promotion count to check priority.\n  private promotionCount?: number | undefined;\n  private readonly generalOverloads: Record<'term' | E.TermType, OverloadTree>;\n  private readonly literalOverLoads: [OverrideType, OverloadTree][];\n  private readonly depth: number;\n\n  public constructor(private readonly identifier: string, depth?: number) {\n    this.implementation = undefined;\n    this.generalOverloads = Object.create(null);\n    this.literalOverLoads = [];\n    this.depth = depth || 0;\n    this.promotionCount = undefined;\n  }\n\n  private getSubtree(overrideType: ArgumentType): OverloadTree | undefined {\n    const generalType = asGeneralType(overrideType);\n    if (generalType) {\n      return this.generalOverloads[generalType];\n    }\n    for (const [ type, overloadTree ] of this.literalOverLoads) {\n      if (overrideType === type) {\n        return overloadTree;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Get the implementation for the types that exactly match @param args .\n   */\n  public getImplementationExact(args: ArgumentType[]): ImplementationFunction | undefined {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this\n    let node: OverloadTree | undefined = this;\n    for (const expression of args) {\n      node = node.getSubtree(expression);\n      if (!node) {\n        return undefined;\n      }\n    }\n    return node.implementation;\n  }\n\n  /**\n   * Searches in a depth first way for the best matching overload. considering this a the tree's root.\n   * @param args:\n   * @param functionArgumentsCache\n   * @param superTypeProvider\n   */\n  public search(args: E.TermExpression[], superTypeProvider: ISuperTypeProvider,\n    functionArgumentsCache: FunctionArgumentsCache):\n    ImplementationFunction | undefined {\n    let cacheIter: IFunctionArgumentsCacheObj | undefined = functionArgumentsCache[this.identifier];\n    let searchIndex = 0;\n    while (searchIndex < args.length && cacheIter?.cache) {\n      const term = args[searchIndex];\n      const literalExpression = isLiteralTermExpression(term);\n      cacheIter = cacheIter.cache[literalExpression ? literalExpression.dataType : term.termType];\n      searchIndex++;\n    }\n    if (searchIndex === args.length && cacheIter?.func) {\n      return cacheIter.func;\n    }\n\n    // SearchStack is a stack of all node's that need to be checked for implementation.\n    // It provides an easy way to keep order in our search.\n    const searchStack: { node: OverloadTree; index: number }[] = [];\n    const startIndex = 0;\n    if (args.length === 0) {\n      return this.implementation;\n    }\n    // GetSubTreeWithArg return a SearchStack containing the node's that should be contacted next.\n    // We also log the index since there is no other way to remember this index.\n    // the provided stack should be pushed on top of our search stack since it also has it's order.\n    searchStack.push(...this.getSubTreeWithArg(args[startIndex], superTypeProvider).map(node =>\n      ({ node, index: startIndex + 1 })));\n    while (searchStack.length > 0) {\n      const { index, node } = <{ node: OverloadTree; index: number }>searchStack.pop();\n      // We check the implementation because it would be possible a path is created but not implemented.\n      // ex: f(double, double, double) and f(term, term). and calling f(double, double).\n      if (index === args.length && node.implementation) {\n        this.addToCache(functionArgumentsCache, args, node.implementation);\n        return node.implementation;\n      }\n      searchStack.push(...node.getSubTreeWithArg(args[index], superTypeProvider).map(item =>\n        ({ node: item, index: index + 1 })));\n    }\n    // Calling a function with one argument but finding no implementation should return no implementation.\n    // Not even the one with no arguments.\n    return undefined;\n  }\n\n  private addToCache(functionArgumentsCache: FunctionArgumentsCache, args: E.TermExpression[],\n    func?: ImplementationFunction | undefined): void {\n    function getDefault(lruCache: FunctionArgumentsCache, key: string): IFunctionArgumentsCacheObj {\n      if (!(key in lruCache)) {\n        lruCache[key] = { };\n      }\n      return lruCache[key]!;\n    }\n    let cache = getDefault(functionArgumentsCache, this.identifier);\n    for (const term of args) {\n      const literalExpression = isLiteralTermExpression(term);\n      const key = literalExpression ? literalExpression.dataType : term.termType;\n      cache.cache = cache.cache || {};\n      cache = getDefault(cache.cache, key);\n    }\n    cache.func = func;\n  }\n\n  /**\n   * Adds an overload to the tree structure considering this as the tree's root.\n   * @param argumentTypes a list of argumentTypes that would need to be provided in\n   * the same order to get the implementation.\n   * @param func the implementation for this overload.\n   */\n  public addOverload(argumentTypes: ArgumentType[], func: ImplementationFunction): void {\n    this._addOverload([ ...argumentTypes ], func, 0);\n  }\n\n  private _addOverload(argumentTypes: ArgumentType[],\n    func: ImplementationFunction, promotionCount: number): void {\n    const [ argumentType, ..._argumentTypes ] = argumentTypes;\n    if (!argumentType) {\n      if (this.promotionCount === undefined || promotionCount <= this.promotionCount) {\n        this.promotionCount = promotionCount;\n        this.implementation = func;\n      }\n      return;\n    }\n    let nextTree = this.getSubtree(argumentType);\n    if (!nextTree) {\n      const newNode = new OverloadTree(this.identifier, this.depth + 1);\n      const generalType = asGeneralType(argumentType);\n      if (generalType) {\n        this.generalOverloads[generalType] = newNode;\n      }\n      const overrideType = asOverrideType(argumentType);\n      if (overrideType) {\n        this.literalOverLoads.push([ overrideType, newNode ]);\n      }\n      nextTree = newNode;\n    }\n    nextTree._addOverload(_argumentTypes, func, promotionCount);\n    // Defined by https://www.w3.org/TR/xpath-31/#promotion .\n    // e.g. When a function takes a string, it can also accept a XSD_ANY_URI if it's cast first.\n    // TODO: When promoting decimal type a cast needs to be preformed.\n    if (argumentType === TypeURL.XSD_STRING) {\n      this.addPromotedOverload(TypeURL.XSD_ANY_URI, func, arg =>\n        string(arg.str()), _argumentTypes, promotionCount);\n    }\n    // TODO: in case of decimal a round needs to happen.\n    if (argumentType === TypeURL.XSD_DOUBLE) {\n      this.addPromotedOverload(TypeURL.XSD_FLOAT, func, arg =>\n        double((<E.NumericLiteral>arg).typedValue), _argumentTypes, promotionCount);\n      this.addPromotedOverload(TypeURL.XSD_DECIMAL, func, arg =>\n        double((<E.NumericLiteral>arg).typedValue), _argumentTypes, promotionCount);\n    }\n    if (argumentType === TypeURL.XSD_FLOAT) {\n      this.addPromotedOverload(TypeURL.XSD_DECIMAL, func, arg =>\n        float((<E.NumericLiteral>arg).typedValue), _argumentTypes, promotionCount);\n    }\n  }\n\n  private addPromotedOverload(typeToPromote: OverrideType, func: ImplementationFunction,\n    conversionFunction: (arg: E.TermExpression) => E.TermExpression,\n    argumentTypes: ArgumentType[], promotionCount: number): void {\n    let nextTree = this.getSubtree(typeToPromote);\n    if (!nextTree) {\n      const newNode = new OverloadTree(this.identifier, this.depth + 1);\n      this.literalOverLoads.push([ typeToPromote, newNode ]);\n      nextTree = newNode;\n    }\n    nextTree._addOverload(argumentTypes, funcConf => args => func(funcConf)([\n      ...args.slice(0, this.depth),\n      conversionFunction(args[this.depth]),\n      ...args.slice(this.depth + 1, args.length),\n    ]), promotionCount + 1);\n  }\n\n  /**\n   * @param arg term to try and match to possible overloads of this node.\n   * @returns SearchStack a stack with top element the next node that should be asked for implementation or overload.\n   */\n  private getSubTreeWithArg(arg: E.TermExpression, openWorldType: ISuperTypeProvider): SearchStack {\n    const res: SearchStack = [];\n    const literalExpression = isLiteralTermExpression(arg);\n    // These types refer to Type exported by lib/util/Consts.ts\n    if (this.generalOverloads.term) {\n      res.push(this.generalOverloads.term);\n    }\n    // TermTypes are defined in E.TermType.\n    if (this.generalOverloads[arg.termType]) {\n      res.push(this.generalOverloads[arg.termType]);\n    }\n    if (literalExpression) {\n      // Defending implementation. Mainly the scary sort.\n      // This function has cost O(n) + O(m * log(m)) with n = amount of overloads and m = amount of matched overloads\n      // We map over each of the overloads, filter only the once that can be used (this is normally 1 or 2).\n      // The sort function on an array with 1 or 2 arguments will be negligible.\n      const concreteType = asKnownLiteralType(literalExpression.dataType);\n      let subExtensionTable: GeneralSuperTypeDict;\n      if (concreteType) {\n        // Concrete dataType is known by sparqlee.\n        subExtensionTable = superTypeDictTable[concreteType];\n      } else {\n        // Datatype is a custom datatype\n        subExtensionTable = getSuperTypes(literalExpression.dataType, openWorldType);\n      }\n      const matches: [number, OverloadTree][] = this.literalOverLoads.filter(([ matchType, _ ]) =>\n        matchType in subExtensionTable)\n        .map(([ matchType, tree ]) => [ subExtensionTable[<KnownLiteralTypes> matchType], tree ]);\n      matches.sort(([ prioA, matchTypeA ], [ prioB, matchTypeB ]) => prioA - prioB);\n      res.push(...matches.map(([ _, sortedType ]) => sortedType));\n    }\n    return res;\n  }\n}\n\n"]}