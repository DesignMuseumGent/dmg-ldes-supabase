"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyncEvaluator = void 0;
const LRUCache = require("lru-cache");
const AlgebraTransformer_1 = require("../transformers/AlgebraTransformer");
const SyncRecursiveEvaluator_1 = require("./evaluatorHelpers/SyncRecursiveEvaluator");
class SyncEvaluator {
    constructor(algExpr, context = {}) {
        this.algExpr = algExpr;
        this.context = context;
        // eslint-disable-next-line unicorn/no-useless-undefined
        const creator = context.extensionFunctionCreator || (() => undefined);
        const baseContext = SyncEvaluator.completeContext(context);
        const transformer = new AlgebraTransformer_1.AlgebraTransformer(Object.assign({ type: 'sync', creator }, baseContext));
        this.expr = transformer.transformAlgebra(algExpr);
        this.evaluator = new SyncRecursiveEvaluator_1.SyncRecursiveEvaluator(baseContext, transformer);
    }
    static completeContext(context) {
        return {
            now: context.now || new Date(Date.now()),
            baseIRI: context.baseIRI || undefined,
            functionArgumentsCache: context.functionArgumentsCache || {},
            superTypeProvider: {
                cache: context.typeCache || new LRUCache(),
                discoverer: context.getSuperType || (() => 'term'),
            },
            extensionFunctionCreator: context.extensionFunctionCreator,
            exists: context.exists,
            aggregate: context.aggregate,
            bnode: context.bnode,
        };
    }
    evaluate(mapping) {
        const result = this.evaluator.evaluate(this.expr, mapping);
        return result.toRDF();
    }
    evaluateAsEBV(mapping) {
        const result = this.evaluator.evaluate(this.expr, mapping);
        return result.coerceEBV();
    }
    evaluateAsInternal(mapping) {
        return this.evaluator.evaluate(this.expr, mapping);
    }
}
exports.SyncEvaluator = SyncEvaluator;
//# sourceMappingURL=SyncEvaluator.js.map