{"version":3,"file":"BaseExpressionEvaluator.js","sourceRoot":"","sources":["../../../../lib/evaluators/evaluatorHelpers/BaseExpressionEvaluator.ts"],"names":[],"mappings":";;;AAGA,qDAA0D;AAG1D,yCAAyC;AA0BzC,MAAa,uBAAuB;IAClC,YAAsC,eAAiC;QAAjC,oBAAe,GAAf,eAAe,CAAkB;IAAI,CAAC;IAElE,IAAI,CAAC,IAAY,EAAE,OAAqB;QAChD,OAAO,IAAI,CAAC;IACd,CAAC;IAES,QAAQ,CAAC,IAAgB,EAAE,OAAqB;QACxD,MAAM,IAAI,GAAG,OAAO,CAAC,GAAG,CAAC,IAAA,yBAAe,EAAC,IAAI,CAAC,CAAC,CAAC;QAChD,IAAI,CAAC,IAAI,EAAE;YACT,MAAM,IAAI,GAAG,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;SACxD;QACD,OAAO,IAAI,CAAC,eAAe,CAAC,sBAAsB,CAAC,IAAI,CAAC,CAAC;IAC3D,CAAC;CACF;AAdD,0DAcC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type * as LRUCache from 'lru-cache';\nimport type * as E from '../../expressions';\nimport { expressionToVar } from '../../functions/Helpers';\nimport type { FunctionArgumentsCache } from '../../functions/OverloadTree';\nimport type { ITermTransformer } from '../../transformers/TermTransformer';\nimport * as Err from '../../util/Errors';\nimport type { ISuperTypeProvider, SuperTypeCallback, TypeCache } from '../../util/TypeHandling';\n\nexport interface ISharedContext {\n  now?: Date;\n  baseIRI?: string;\n  /**\n   * @deprecated This value is unused, will be removed in the next major version.\n   */\n  overloadCache?: LRUCache<string, any>;\n  typeCache?: TypeCache;\n  getSuperType?: SuperTypeCallback;\n  /**\n   * @deprecated This value is unused (extended XSD types is always enabled), will be removed in the next major version.\n   */\n  enableExtendedXsdTypes?: boolean;\n  functionArgumentsCache?: FunctionArgumentsCache;\n}\n\nexport interface ICompleteSharedContext {\n  now: Date;\n  baseIRI?: string;\n  functionArgumentsCache: FunctionArgumentsCache;\n  superTypeProvider: ISuperTypeProvider;\n}\n\nexport class BaseExpressionEvaluator {\n  public constructor(protected readonly termTransformer: ITermTransformer) { }\n\n  protected term(expr: E.Term, mapping: RDF.Bindings): E.Term {\n    return expr;\n  }\n\n  protected variable(expr: E.Variable, mapping: RDF.Bindings): E.Term {\n    const term = mapping.get(expressionToVar(expr));\n    if (!term) {\n      throw new Err.UnboundVariableError(expr.name, mapping);\n    }\n    return this.termTransformer.transformRDFTermUnsafe(term);\n  }\n}\n"]}