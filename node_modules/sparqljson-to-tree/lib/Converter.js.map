{"version":3,"file":"Converter.js","sourceRoot":"","sources":["Converter.ts"],"names":[],"mappings":"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","sourcesContent":["import * as RDF from \"rdf-js\";\nimport {getTermRaw} from \"rdf-literal\";\nimport {IBindings, ISettings, SparqlJsonParser} from \"sparqljson-parse\";\n\n/**\n * Converts SPARQL JSON results to a tree-based structure by splitting variables on a certain delimiter.\n */\nexport class Converter {\n\n  private readonly delimiter: string;\n  private readonly parser: SparqlJsonParser;\n  private readonly materializeRdfJsTerms: boolean;\n\n  constructor(settings?: IConverterSettings) {\n    settings = settings || { delimiter: '_' };\n    settings.prefixVariableQuestionMark = false;\n    this.delimiter = settings.delimiter || '_';\n    this.parser = new SparqlJsonParser(settings);\n    this.materializeRdfJsTerms = settings.materializeRdfJsTerms;\n  }\n\n  /**\n   * Adds a value to a tree.\n   * @param tree A tree datastructure.\n   * @param {string[]} path The path of keys in the tree.\n   * @param {Term} value A value to add.\n   * @param {string} lastKeyPath The accumulated key path (separated by the given delimiter)\n   *                             through recursive calls, can be empty.\n   * @param {ISchema} schema A schema.\n   * @param {string} delimiter The string to join key paths by.\n   */\n  public static addValueToTree(tree: any, path: string[], value: RDF.Term, lastKeyPath: string,\n                               schema: ISchema, delimiter: string) {\n    const key = path[0];\n    const keyPath = lastKeyPath ? (lastKeyPath + delimiter + key) : key;\n    const singularize: boolean = schema.singularizeVariables[keyPath];\n    if (path.length === 1) {\n      // Leaf nodes\n      if (singularize) {\n        if (!tree[key]) {\n          tree[key] = value;\n        }\n      } else {\n        if (!tree[key]) {\n          tree[key] = [];\n        }\n        tree[key].push(value);\n      }\n    } else {\n      // Inner nodes\n      let nextNode;\n      if (singularize) {\n        if (!tree[key]) {\n          tree[key] = {};\n        }\n        nextNode = tree[key];\n      } else {\n        if (!tree[key]) {\n          tree[key] = [{}];\n        }\n        nextNode = tree[key][0];\n      }\n      Converter.addValueToTree(nextNode, path.slice(1), value, keyPath, schema, delimiter);\n    }\n  }\n\n  /**\n   * Recursively merge the two given trees.\n   * @param tree1 A first tree (has key priority on literals).\n   * @param tree2 A second tree. All arrays will/should only have a single element.\n   * @return {any} The merged tree.\n   */\n  public static mergeTrees(tree1: any, tree2: any): IMergeResult {\n    if (typeof tree1 !== typeof tree2) {\n      throw new Error(`Two incompatible tree nodes were found: ${typeof tree1} and ${typeof tree2}`);\n    }\n    if (Array.isArray(tree1) !== Array.isArray(tree2)) {\n      throw new Error(`Two incompatible tree nodes were found: Array?${Array.isArray(tree1)} and Array?${\n        Array.isArray(tree2)}`);\n    }\n\n    if (typeof tree1 === 'object' && typeof tree2 === 'object') {\n      if (tree1.termType && tree2.termType) {\n        if (tree1.equals(tree2)) {\n          return { valid: true, result: tree1 };\n        } else {\n          return { valid: false, result: tree1 };\n        }\n      }\n\n      if (Array.isArray(tree1) && Array.isArray(tree2)) {\n        if (tree1.length > 0) {\n          const merged = [];\n          let valid = false;\n          for (const tree1Element of tree1) {\n            const mergedElement = Converter.mergeTrees(tree1Element, tree2[0]);\n            if (mergedElement.valid) {\n              valid = true;\n              merged.push(mergedElement.result);\n            } else {\n              merged.push(tree1Element);\n            }\n          }\n\n          if (valid) {\n            return { valid: true, result: merged };\n          }\n        }\n        return { valid: true, result: tree1.concat(tree2) };\n      } else {\n        const merged: any = {};\n\n        for (const key2 in tree2) {\n          merged[key2] = tree2[key2];\n        }\n        for (const key1 in tree1) {\n          if (merged[key1]) {\n            const mergedElement = Converter.mergeTrees(tree1[key1], merged[key1]);\n            if (mergedElement.valid) {\n              merged[key1] = mergedElement.result;\n            } else {\n              return { valid: false, result: tree1 };\n            }\n          } else {\n            merged[key1] = tree1[key1];\n          }\n        }\n\n        return { valid: true, result: merged };\n      }\n    } else {\n      throw new Error(`Unmergable tree types: ${typeof tree1} and ${typeof tree2}`);\n    }\n  }\n\n  /**\n   * Materialize all RDF terms in the given tree to raw values.\n   * This does not mutate the original tree.\n   * @param tree A tree.\n   * @return {any} A materialized tree.\n   */\n  public static materializeTree(tree: any): any {\n    if (tree.termType) {\n      return getTermRaw(tree);\n    } else if (Array.isArray(tree)) {\n      return tree.map(Converter.materializeTree);\n    } else {\n      const materialized: any = {};\n      for (const key in tree) {\n        materialized[key] = Converter.materializeTree(tree[key]);\n      }\n      return materialized;\n    }\n  }\n\n  /**\n   * Convert a complete SPARQL JSON response to a GraphQL results tree.\n   * @param sparqlResponse A SPARQL JSON response.\n   * @param {ISchema} schema A schema.\n   * @return {any} A GraphQL results tree.\n   */\n  public sparqlJsonResultsToTree(sparqlResponse: any, schema?: ISchema): any {\n    return this.bindingsToTree(this.parser.parseJsonResults(sparqlResponse), schema || { singularizeVariables: {} });\n  }\n\n  /**\n   * Convert an array of bindings to a GraphQL results tree.\n   * @param {IBindings[]} bindingsArray An array of bindings.\n   * @param {ISchema} schema A schema.\n   * @return {any} A GraphQL results tree.\n   */\n  public bindingsToTree(bindingsArray: IBindings[], schema: ISchema): any {\n    const singularRoot = schema && schema.singularizeVariables[''];\n    let tree: any = singularRoot ? {} : [];\n    for (const bindings of bindingsArray) {\n      const subTree: any = singularRoot ? {} : [{}];\n\n      for (const key in bindings) {\n        const path: string[] = key.split(this.delimiter);\n        const value: RDF.Term = bindings[key];\n        Converter.addValueToTree(singularRoot ? subTree : subTree[0], path, value, '', schema, this.delimiter);\n      }\n\n      tree = Converter.mergeTrees(tree, subTree).result;\n    }\n\n    if (this.materializeRdfJsTerms) {\n      tree = Converter.materializeTree(tree);\n    }\n\n    return tree;\n  }\n\n}\n\n/**\n * Constructor settings object interface for {@link Converter}.\n */\nexport interface IConverterSettings extends ISettings {\n  /**\n   * The string to split variable names by.\n   * Defaults to '_'.\n   */\n  delimiter?: string;\n  /**\n   * If RDFJS terms should be converted to their raw value.\n   * Defaults to false.\n   */\n  materializeRdfJsTerms?: boolean;\n}\n\nexport interface ISchema {\n  /**\n   * Defines for each variable if the tree structure should have an array or a singular value for its values.\n   * If true, a single value is represented, without array.\n   * Defaults to false (arrays), due to the open-world-assumption in RDF.\n   */\n  singularizeVariables: {[id: string]: boolean};\n}\n\nexport interface IMergeResult {\n  /**\n   * If the merging was successful.\n   * If not, information was withheld from the result.\n   */\n  valid: boolean;\n  /**\n   * The result of the merge.\n   */\n  result: any;\n}\n"]}