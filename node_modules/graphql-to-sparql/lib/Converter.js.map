{"version":3,"file":"Converter.js","sourceRoot":"","sources":["Converter.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,+CAA6F;AAG7F,uCAgBmB;AACnB,2DAMiC;AACjC,uDAAoE;AAGpE,iCAA4B;AAE5B;;GAEG;AACH,MAAa,SAAS;IAIpB,YAAY,QAA2B;QACrC,QAAQ,GAAG,QAAQ,IAAI,EAAE,CAAC;QAC1B,QAAQ,CAAC,iBAAiB,GAAG,QAAQ,CAAC,iBAAiB,IAAI,GAAG,CAAC;QAC/D,QAAQ,CAAC,yBAAyB,GAAG,QAAQ,CAAC,yBAAyB,IAAI,CAAC,CAAC;QAE7E,IAAI,CAAC,IAAI,GAAG,IAAI,WAAI,CAAC,QAAQ,CAAC,CAAC;QAE/B,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,CAAC;IACxC,CAAC;IAEM,MAAM,CAAC,oBAAoB,CAAC,IAAU,EAAE,QAA0B;QACvE,IAAI,CAAC,mBAAmB,CAAC,IAAI,6BAAmB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QAClE,IAAI,CAAC,mBAAmB,CAAC,IAAI,wCAA8B,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QAC7E,IAAI,CAAC,mBAAmB,CAAC,IAAI,uCAA6B,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QAC5E,IAAI,CAAC,mBAAmB,CAAC,IAAI,4CAAkC,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QACjF,IAAI,CAAC,mBAAmB,CAAC,IAAI,4CAAkC,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QACjF,IAAI,CAAC,mBAAmB,CAAC,IAAI,mCAAyB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;IAC1E,CAAC;IAEM,MAAM,CAAC,yBAAyB,CAAC,IAAU,EAAE,QAA0B;QAC5E,IAAI,CAAC,wBAAwB,CAAC,IAAI,kCAAwB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QAC5E,IAAI,CAAC,wBAAwB,CAAC,IAAI,6BAAmB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QACvE,IAAI,CAAC,wBAAwB,CAAC,IAAI,+BAAqB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QACzE,IAAI,CAAC,wBAAwB,CAAC,IAAI,gCAAsB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QAC1E,IAAI,CAAC,wBAAwB,CAAC,IAAI,iCAAuB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QAC3E,IAAI,CAAC,wBAAwB,CAAC,IAAI,8BAAoB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QACxE,IAAI,CAAC,wBAAwB,CAAC,IAAI,8BAAoB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QACxE,IAAI,CAAC,wBAAwB,CAAC,IAAI,8BAAoB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QACxE,IAAI,CAAC,wBAAwB,CAAC,IAAI,gCAAsB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;IAC5E,CAAC;IAEM,MAAM,CAAC,6BAA6B,CAAC,IAAU,EAAE,QAA0B;QAChF,IAAI,CAAC,4BAA4B,CAAC,IAAI,2CAA2B,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QACnF,IAAI,CAAC,4BAA4B,CAAC,IAAI,4CAA4B,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QACpF,IAAI,CAAC,4BAA4B,CAAC,IAAI,0CAA0B,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QAClF,IAAI,CAAC,4BAA4B,CAAC,IAAI,0CAA0B,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;QAClF,IAAI,CAAC,4BAA4B,CAAC,IAAI,wCAAwB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;IAClF,CAAC;IAED;;;;;;OAMG;IACU,sBAAsB,CAAC,YAAmC,EAAE,OAAsB,EAC3D,OAAyB;;YAC3D,OAAO,IAAI,CAAC,gCAAgC,CAAC,YAAY,EACvD,MAAM,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,OAAO,CAAC,CAAC;QAC3D,CAAC;KAAA;IAED;;;;;;OAMG;IACI,gCAAgC,CAAC,YAAmC,EAAE,OAAgC,EACrE,OAAyB;QAC/D,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;QACxB,MAAM,QAAQ,GAAiB,OAAO,YAAY,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAA,gBAAK,EAAC,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC;QACrG,MAAM,mBAAmB,GAAG,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;QAC1D,MAAM,cAAc,GAAoB;YACtC,OAAO;YACP,mBAAmB;YACnB,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,YAAY,EAAE;YAC3C,IAAI,EAAE,EAAE;YACR,gBAAgB,EAAE,kCAAgB,CAAC,MAAM;YACzC,oBAAoB,EAAE,OAAO,CAAC,oBAAoB,IAAI,EAAE;YACxD,OAAO,EAAE,IAAK;YACd,iBAAiB,EAAE,EAAE;YACrB,aAAa,EAAE,OAAO,CAAC,aAAa,IAAI,EAAE;YAC1C,iBAAiB,EAAE,EAAE;SACtB,CAAC;QAEF,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,cAAc,CAAC,CAAC;IACxD,CAAC;IAED;;;;;;;OAOG;IACI,cAAc,CAAC,QAAsB;QAC1C,MAAM,mBAAmB,GAA6C,EAAE,CAAC;QACzE,MAAM,cAAc,GAAqB,EAAE,CAAC;QAC5C,KAAK,MAAM,UAAU,IAAI,QAAQ,CAAC,WAAW,EAAE;YAC7C,IAAI,UAAU,CAAC,IAAI,KAAK,oBAAoB,EAAE;gBAC5C,mBAAmB,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,UAAU,CAAC;aACzD;iBAAM;gBACL,cAAc,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;aACjC;SACF;QACM,QAAS,CAAC,WAAW,GAAG,cAAc,CAAC;QAC9C,OAAO,mBAAmB,CAAC;IAC7B,CAAC;IAEO,sBAAsB,CAAC,QAA0B;QACvD,SAAS,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QACpD,SAAS,CAAC,yBAAyB,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QACzD,SAAS,CAAC,6BAA6B,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IAC/D,CAAC;CAEF;AAhHD,8BAgHC","sourcesContent":["import {DefinitionNode, DocumentNode, FragmentDefinitionNode, parse} from \"graphql/language\";\nimport {JsonLdContextNormalized, JsonLdContext} from \"jsonld-context-parser\";\nimport {Algebra} from \"sparqlalgebrajs\";\nimport {\n  NodeHandlerDefinitionFragment,\n  NodeHandlerDefinitionOperation,\n  NodeHandlerDocument,\n  NodeHandlerSelectionField,\n  NodeHandlerSelectionFragmentSpread,\n  NodeHandlerSelectionInlineFragment,\n  NodeValueHandlerBoolean,\n  NodeValueHandlerEnum,\n  NodeValueHandlerFloat,\n  NodeValueHandlerInt,\n  NodeValueHandlerList,\n  NodeValueHandlerNull,\n  NodeValueHandlerObject,\n  NodeValueHandlerString,\n  NodeValueHandlerVariable,\n} from \"./handler\";\nimport {\n  DirectiveNodeHandlerInclude,\n  DirectiveNodeHandlerOptional,\n  DirectiveNodeHandlerPlural,\n  DirectiveNodeHandlerSingle,\n  DirectiveNodeHandlerSkip,\n} from \"./handler/directivenode\";\nimport {IConvertContext, SingularizeState} from \"./IConvertContext\";\nimport {IConvertOptions} from \"./IConvertOptions\";\nimport {IConvertSettings} from \"./IConvertSettings\";\nimport {Util} from \"./Util\";\n\n/**\n * Translate GraphQL queries into SPARQL algebra.\n */\nexport class Converter {\n\n  private readonly util: Util;\n\n  constructor(settings?: IConvertSettings) {\n    settings = settings || {};\n    settings.variableDelimiter = settings.variableDelimiter || '_';\n    settings.expressionVariableCounter = settings.expressionVariableCounter || 0;\n\n    this.util = new Util(settings);\n\n    this.initializeNodeHandlers(settings);\n  }\n\n  public static registerNodeHandlers(util: Util, settings: IConvertSettings) {\n    util.registerNodeHandler(new NodeHandlerDocument(util, settings));\n    util.registerNodeHandler(new NodeHandlerDefinitionOperation(util, settings));\n    util.registerNodeHandler(new NodeHandlerDefinitionFragment(util, settings));\n    util.registerNodeHandler(new NodeHandlerSelectionFragmentSpread(util, settings));\n    util.registerNodeHandler(new NodeHandlerSelectionInlineFragment(util, settings));\n    util.registerNodeHandler(new NodeHandlerSelectionField(util, settings));\n  }\n\n  public static registerNodeValueHandlers(util: Util, settings: IConvertSettings) {\n    util.registerNodeValueHandler(new NodeValueHandlerVariable(util, settings));\n    util.registerNodeValueHandler(new NodeValueHandlerInt(util, settings));\n    util.registerNodeValueHandler(new NodeValueHandlerFloat(util, settings));\n    util.registerNodeValueHandler(new NodeValueHandlerString(util, settings));\n    util.registerNodeValueHandler(new NodeValueHandlerBoolean(util, settings));\n    util.registerNodeValueHandler(new NodeValueHandlerNull(util, settings));\n    util.registerNodeValueHandler(new NodeValueHandlerEnum(util, settings));\n    util.registerNodeValueHandler(new NodeValueHandlerList(util, settings));\n    util.registerNodeValueHandler(new NodeValueHandlerObject(util, settings));\n  }\n\n  public static registerDirectiveNodeHandlers(util: Util, settings: IConvertSettings) {\n    util.registerDirectiveNodeHandler(new DirectiveNodeHandlerInclude(util, settings));\n    util.registerDirectiveNodeHandler(new DirectiveNodeHandlerOptional(util, settings));\n    util.registerDirectiveNodeHandler(new DirectiveNodeHandlerPlural(util, settings));\n    util.registerDirectiveNodeHandler(new DirectiveNodeHandlerSingle(util, settings));\n    util.registerDirectiveNodeHandler(new DirectiveNodeHandlerSkip(util, settings));\n  }\n\n  /**\n   * Translates a GraphQL query into SPARQL algebra.\n   * @param {string | DocumentNode} graphqlQuery A GraphQL query string or node.\n   * @param {IContext} context A JSON-LD context.\n   * @param {IConvertOptions} options An options object.\n   * @return {Promise<Operation>} A promise resolving to an operation.\n   */\n  public async graphqlToSparqlAlgebra(graphqlQuery: string | DocumentNode, context: JsonLdContext,\n                                      options?: IConvertOptions): Promise<Algebra.Operation> {\n    return this.graphqlToSparqlAlgebraRawContext(graphqlQuery,\n      await this.util.contextParser.parse(context), options);\n  }\n\n  /**\n   * Translates a GraphQL query into SPARQL algebra.\n   * @param {string | DocumentNode} graphqlQuery A GraphQL query string or node.\n   * @param {IContext} context A JSON-LD context.\n   * @param {IConvertOptions} options An options object.\n   * @return {Operation} An operation.\n   */\n  public graphqlToSparqlAlgebraRawContext(graphqlQuery: string | DocumentNode, context: JsonLdContextNormalized,\n                                          options?: IConvertOptions): Algebra.Operation {\n    options = options || {};\n    const document: DocumentNode = typeof graphqlQuery === 'string' ? parse(graphqlQuery) : graphqlQuery;\n    const fragmentDefinitions = this.indexFragments(document);\n    const convertContext: IConvertContext = {\n      context,\n      fragmentDefinitions,\n      graph: this.util.dataFactory.defaultGraph(),\n      path: [],\n      singularizeState: SingularizeState.PLURAL, // We don't make this configurable to enforce query consistency\n      singularizeVariables: options.singularizeVariables || {},\n      subject: null!,\n      terminalVariables: [],\n      variablesDict: options.variablesDict || {},\n      variablesMetaDict: {},\n    };\n\n    return this.util.handleNode(document, convertContext);\n  }\n\n  /**\n   * Create an index of all fragment definitions in the given document.\n   *\n   * This will assign a new array of definition nodes without fragment definition.\n   *\n   * @param {DocumentNode} document A document node.\n   * @return {{[p: string]: FragmentDefinitionNode}} An index of fragment definition nodes.\n   */\n  public indexFragments(document: DocumentNode): {[name: string]: FragmentDefinitionNode} {\n    const fragmentDefinitions: {[name: string]: FragmentDefinitionNode} = {};\n    const newDefinitions: DefinitionNode[] = [];\n    for (const definition of document.definitions) {\n      if (definition.kind === 'FragmentDefinition') {\n        fragmentDefinitions[definition.name.value] = definition;\n      } else {\n        newDefinitions.push(definition);\n      }\n    }\n    (<any> document).definitions = newDefinitions;\n    return fragmentDefinitions;\n  }\n\n  private initializeNodeHandlers(settings: IConvertSettings) {\n    Converter.registerNodeHandlers(this.util, settings);\n    Converter.registerNodeValueHandlers(this.util, settings);\n    Converter.registerDirectiveNodeHandlers(this.util, settings);\n  }\n\n}\n"]}