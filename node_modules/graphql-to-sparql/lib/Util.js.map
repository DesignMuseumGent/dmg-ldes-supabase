{"version":3,"file":"Util.js","sourceRoot":"","sources":["Util.ts"],"names":[],"mappings":";;;AAAA,uDAA6C;AAE7C,iEAA6E;AAE7E,qDAAiD;AAUjD;;GAEG;AACH,MAAa,IAAI;IAYf,YAAY,QAA0B;QAJrB,iBAAY,GAA8C,EAAE,CAAC;QAC7D,sBAAiB,GAAmD,EAAE,CAAC;QACvE,0BAAqB,GAAkD,EAAE,CAAC;QAGzF,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,WAAW,IAAI,IAAI,8BAAW,EAAE,CAAC;QAC7D,IAAI,CAAC,gBAAgB,GAAG,IAAI,yBAAO,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACtD,IAAI,CAAC,aAAa,GAAG,IAAI,qCAAa,EAAE,CAAC;IAC3C,CAAC;IAED;;;OAGG;IACI,mBAAmB,CAAC,WAAoC;QAC7D,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,UAAU,CAAC,GAAG,WAAW,CAAC;IAC1D,CAAC;IAED;;;;OAIG;IACI,wBAAwB,CAAC,gBAA8C;QAC5E,IAAI,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,UAAU,CAAC,GAAG,gBAAgB,CAAC;IACzE,CAAC;IAED;;;OAGG;IACI,4BAA4B,CAAC,oBAAiD;QACnF,IAAI,CAAC,qBAAqB,CAAC,oBAAoB,CAAC,UAAU,CAAC,GAAG,oBAAoB,CAAC;IACrF,CAAC;IAED;;;;;OAKG;IACI,UAAU,CAA6B,IAAO,EAAE,cAA+B;QACpF,MAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACjD,IAAI,CAAC,WAAW,EAAE;YAChB,MAAM,IAAI,KAAK,CAAC,6BAA6B,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;SAC5D;QACD,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;IAClD,CAAC;IAED;;;;;;OAMG;IACI,eAAe,CAAsB,IAAO,EAAE,SAAiB,EAC1B,cAA+B;QACzE,MAAM,gBAAgB,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC3D,IAAI,CAAC,gBAAgB,EAAE;YACrB,MAAM,IAAI,KAAK,CAAC,mCAAmC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;SAClE;QACD,OAAO,gBAAgB,CAAC,MAAM,CAAC,IAAI,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC;IAClE,CAAC;IAED;;;;;OAKG;IACI,mBAAmB,CAAC,gBAAmC,EAAE,cAA+B;QAE7F,MAAM,oBAAoB,GAAG,IAAI,CAAC,qBAAqB,CAAC,gBAAgB,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC/F,IAAI,CAAC,oBAAoB,EAAE;YACzB,OAAO,IAAI,CAAC;SACb;QACD,OAAO,oBAAoB,CAAC,MAAM,CAAC,gBAAgB,EAAE,cAAc,CAAC,CAAC;IACvE,CAAC;IAED;;;;;OAKG;IACI,cAAc,CAAC,UAA+B;QACnD,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;YAC3B,OAAO,UAAU,CAAC,CAAC,CAAC,CAAC;SACtB;QAED,qCAAqC;QACrC,MAAM,IAAI,GAAwB,EAAE,CAAC;QACrC,MAAM,OAAO,GAAwB,EAAE,CAAC;QACxC,KAAK,MAAM,SAAS,IAAI,UAAU,EAAE;YAClC,IAAI,SAAS,CAAC,IAAI,KAAK,KAAK,EAAE;gBAC5B,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;aACtB;iBAAM;gBACL,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;aACzB;SACF;QAED,IAAI,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,MAAM,EAAE;YACrC,iCAAiC;YACjC,OAAO,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;SACvC;aAAM,IAAI,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,MAAM,GAAG,CAAC;eAC3C,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,UAAU;eAC9B,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,KAAK,EAAE;YACvC,kFAAkF;YAClF,oEAAoE;YACpE,MAAM,gBAAgB,GAAwC,OAAO,CAAC,CAAC,CAAC,CAAC;YACzE,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACrC,OAAO,IAAI,CAAC,gBAAgB,CAAC,cAAc,CACzC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,EAC9B,gBAAgB,CAAC,KAAK,CAAC,CAAC,CAAC,CAC1B,CAAC;SACH;aAAM,IAAI,OAAO,CAAC,MAAM,KAAK,UAAU,CAAC,MAAM,EAAE;YAC/C,sBAAsB;YACtB,OAAO,IAAI,CAAC,0BAA0B,CAAC,OAAO,CAAC,CAAC;SACjD;aAAM;YACL,6EAA6E;YAC7E,OAAO,IAAI,CAAC,0BAA0B,CAAC;gBACrC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC;gBAC9B,IAAI,CAAC,0BAA0B,CAAC,OAAO,CAAC;aACzC,CAAC,CAAC;SACJ;IACH,CAAC;IAEM,mBAAmB,CAAC,UAA+B;QACxD,OAAO,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAsB,EAAG,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,EAAE,UAAU;aACxF,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE,CAAgB,EAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;IAChD,CAAC;IAEM,0BAA0B,CAAC,UAA+B;QAC/D,OAAO,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;IACtD,CAAC;IAED;;;;;OAKG;IACI,iBAAiB,CAAC,IAAc,EAAE,UAAkB;QACzD,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;IACnC,CAAC;IAED;;;;OAIG;IACI,aAAa,CAAC,KAAgB;QACnC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC;IACxD,CAAC;IAED;;;;;;OAMG;IACI,cAAc,CAAC,UAAkB,EAAE,cAA+B;QACvE,OAAO,IAAI,CAAC,WAAW,CAAC,QAAS,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM;YAC3D,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,CAAC;IACtH,CAAC;IAED;;;;;OAKG;IACI,gBAAgB,CAAC,KAAa,EAAE,OAAgC;QACrE,MAAM,YAAY,GAAG,OAAO,CAAC,UAAU,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;QACrD,IAAI,IAAI,CAAC,QAAQ,CAAC,cAAc,IAAI,CAAC,YAAY,EAAE;YACjD,MAAM,IAAI,KAAK,CAAC,iCAAiC,GAAG,KAAK,CAAC,CAAC;SAC5D;QACD,OAAO,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,YAAY,IAAI,KAAK,CAAC,CAAC;IAC3D,CAAC;IAED;;;;;;OAMG;IACI,WAAW,CAAC,IAA6C,EAAE,IAAY;QAC5E,IAAI,IAAI,EAAE;YACR,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE;gBAC3B,IAAI,QAAQ,CAAC,IAAI,CAAC,KAAK,KAAK,IAAI,EAAE;oBAChC,OAAO,QAAQ,CAAC;iBACjB;aACF;SACF;IACH,CAAC;IAED;;;;;;OAMG;IACI,cAAc,CAAC,OAAiB,EAAE,aAA4B,EAAE,cAA+B;QACpG,OAAO,IAAI,CAAC,gBAAgB,CAAC,aAAa,CACxC,OAAO,EACP,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,iDAAiD,CAAC,EAC7E,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,EAAE,cAAc,CAAC,OAAO,CAAC,EACvE,cAAc,CAAC,KAAK,CAAC,CAAC;IAC1B,CAAC;IAED;;;;;;;;OAQG;IACI,iBAAiB,CAAC,OAAiB,EAAE,aAAuB,EAAE,MAAgB,EAAE,KAAe,EAC7E,OAAgC;QACvD,MAAM,SAAS,GAAkB,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;QACrF,IAAI,OAAO,IAAI,OAAO,CAAC,aAAa,EAAE,CAAC,aAAa,CAAC,KAAK,CAAC;eAC/C,OAAO,CAAC,aAAa,EAAE,CAAC,aAAa,CAAC,KAAK,CAAE,CAAC,UAAU,CAAC,EAAE;YACrE,OAAO,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;SAC/E;QACD,OAAO,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,OAAO,EAAE,SAAS,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;IAChF,CAAC;IAED;;;;;;;;;OASG;IACI,cAAc,CAAC,OAAiB,EAAE,aAAuB,EAAE,qBAAoC,EAChF,MAAgB,EAAE,KAAe,EACjC,OAAgC;QACpD,MAAM,gBAAgB,GAAkB,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;QAC5F,IAAI,UAAU,GAA+B,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,gBAAgB,CAAC,CAAC;QAEhG,uDAAuD;QACvD,KAAK,MAAM,oBAAoB,IAAI,qBAAqB,CAAC,MAAM,EAAE;YAC/D,IAAI,oBAAoB,CAAC,IAAI,KAAK,WAAW,EAAE;gBAC7C,MAAM,IAAI,KAAK,CAAC,sEAAsE;sBAClF,oBAAoB,CAAC,IAAI,CAAC,CAAC;aAChC;YACD,UAAU,GAAG,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC;gBAC3C,UAAU;gBACV,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,IAAI,CAAC,gBAAgB,CAAC,oBAAoB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;aAC7F,CAAC,CAAC;SACJ;QAED,kDAAkD;QAClD,IAAI,OAAO,IAAI,OAAO,CAAC,aAAa,EAAE,CAAC,aAAa,CAAC,KAAK,CAAC;eAC/C,OAAO,CAAC,aAAa,EAAE,CAAC,aAAa,CAAC,KAAK,CAAE,CAAC,UAAU,CAAC,EAAE;YACrE,OAAO,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,MAAM,EAAE,UAAU,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;SAC7E;QACD,OAAO,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,OAAO,EAAE,UAAU,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;IAC9E,CAAC;CAEF;AAtRD,oBAsRC","sourcesContent":["import {DataFactory} from \"rdf-data-factory\";\nimport {ArgumentNode, FieldNode, ListValueNode, NamedTypeNode, NameNode, ValueNode} from \"graphql/language\";\nimport {ContextParser, JsonLdContextNormalized} from \"jsonld-context-parser\";\nimport * as RDF from \"@rdfjs/types\";\nimport {Algebra, Factory} from \"sparqlalgebrajs\";\nimport {IValueNodeHandlerOutput, NodeHandlerAdapter, NodeValueHandlerAdapter} from \"./handler\";\nimport {IConvertContext} from \"./IConvertContext\";\nimport {IConvertSettings} from \"./IConvertSettings\";\nimport {\n  DirectiveNodeHandlerAdapter,\n  IDirectiveContext,\n  IDirectiveNodeHandlerOutput\n} from \"./handler/directivenode/DirectiveNodeHandlerAdapter\";\n\n/**\n * Utilities for conversion.\n */\nexport class Util {\n\n  public readonly dataFactory: RDF.DataFactory;\n  public readonly operationFactory: Factory;\n  public readonly contextParser: ContextParser;\n\n  protected readonly settings: IConvertSettings;\n\n  private readonly nodeHandlers: {[kind: string]: NodeHandlerAdapter<any>} = {};\n  private readonly nodeValueHandlers: {[kind: string]: NodeValueHandlerAdapter<any>} = {};\n  private readonly directiveNodeHandlers: {[kind: string]: DirectiveNodeHandlerAdapter} = {};\n\n  constructor(settings: IConvertSettings) {\n    this.settings = settings;\n    this.dataFactory = settings.dataFactory || new DataFactory();\n    this.operationFactory = new Factory(this.dataFactory);\n    this.contextParser = new ContextParser();\n  }\n\n  /**\n   * Register a new {@link NodeHandlerAdapter}.\n   * @param {NodeHandlerAdapter<any>} nodeHandler A handler for converting GraphQL nodes to operations.\n   */\n  public registerNodeHandler(nodeHandler: NodeHandlerAdapter<any>) {\n    this.nodeHandlers[nodeHandler.targetKind] = nodeHandler;\n  }\n\n  /**\n   * Register a new {@link NodeValueHandlerAdapter}\n   * @param {NodeValueHandlerAdapter<any>} nodeValueHandler A handler for converting GraphQL value nodes\n   *                                                        to terms and patterns.\n   */\n  public registerNodeValueHandler(nodeValueHandler: NodeValueHandlerAdapter<any>) {\n    this.nodeValueHandlers[nodeValueHandler.targetKind] = nodeValueHandler;\n  }\n\n  /**\n   * Register a new {@link DirectiveNodeHandlerAdapter}\n   * @param {DirectiveNodeHandlerAdapter} directiveNodeHandler A handler for handling GraphQL directives.\n   */\n  public registerDirectiveNodeHandler(directiveNodeHandler: DirectiveNodeHandlerAdapter) {\n    this.directiveNodeHandlers[directiveNodeHandler.targetKind] = directiveNodeHandler;\n  }\n\n  /**\n   * Get the operation for the given GraphQL node.\n   * @param {T} node A GraphQL node.\n   * @param {IConvertContext} convertContext A conversion context.\n   * @return {Operation} A SPARQL algebra operation.\n   */\n  public handleNode<T extends { kind: string }>(node: T, convertContext: IConvertContext): Algebra.Operation {\n    const nodeHandler = this.nodeHandlers[node.kind];\n    if (!nodeHandler) {\n      throw new Error(`Unsupported GraphQL node '${node.kind}'`);\n    }\n    return nodeHandler.handle(node, convertContext);\n  }\n\n  /**\n   * Get the terms and patterns for the given value node.\n   * @param {T} node A GraphQL node.\n   * @param {string} fieldName The name of the field or argument in which the value was encapsulated.\n   * @param {IConvertContext} convertContext A conversion context.\n   * @return {IValueNodeHandlerOutput} The RDF terms and patterns.\n   */\n  public handleNodeValue<T extends ValueNode>(node: T, fieldName: string,\n                                              convertContext: IConvertContext): IValueNodeHandlerOutput {\n    const nodeValueHandler = this.nodeValueHandlers[node.kind];\n    if (!nodeValueHandler) {\n      throw new Error(`Unsupported GraphQL value node '${node.kind}'`);\n    }\n    return nodeValueHandler.handle(node, fieldName, convertContext);\n  }\n\n  /**\n   * Get the handler output for the given directive.\n   * @param {IDirectiveContext} directiveContext The current directive context.\n   * @param {IConvertContext} convertContext A conversion context.\n   * @return {IDirectiveNodeHandlerOutput} The directive node handler output or null.\n   */\n  public handleDirectiveNode(directiveContext: IDirectiveContext, convertContext: IConvertContext)\n    : IDirectiveNodeHandlerOutput | null {\n    const directiveNodeHandler = this.directiveNodeHandlers[directiveContext.directive.name.value];\n    if (!directiveNodeHandler) {\n      return null;\n    }\n    return directiveNodeHandler.handle(directiveContext, convertContext);\n  }\n\n  /**\n   * Join the given array of operations.\n   * If all operations are BGPs, then a single big BGP with all patterns from the given BGPs will be created.\n   * @param {Operation[]} operations An array of operations.\n   * @return {Operation} A single joined operation.\n   */\n  public joinOperations(operations: Algebra.Operation[]): Algebra.Operation {\n    if (operations.length === 1) {\n      return operations[0];\n    }\n\n    // Check if which operations are BGPs\n    const bgps: Algebra.Operation[] = [];\n    const nonBgps: Algebra.Operation[] = [];\n    for (const operation of operations) {\n      if (operation.type === 'bgp') {\n        bgps.push(operation);\n      } else {\n        nonBgps.push(operation);\n      }\n    }\n\n    if (bgps.length === operations.length) {\n      // Create a big BGP from all BGPs\n      return this.joinOperationsAsBgp(bgps);\n    } else if (bgps.length === operations.length - 1\n      && nonBgps[0].type === 'leftjoin'\n      && nonBgps[0].input[0].type === 'bgp') {\n      // Check if we have one left-join (with a BGP on the left), and the rest are BGPs.\n      // If so, merge the BGPS within the left-hand-side of the left-join.\n      const originalLeftJoin: Algebra.LeftJoin = <Algebra.LeftJoin> nonBgps[0];\n      bgps.push(originalLeftJoin.input[0]);\n      return this.operationFactory.createLeftJoin(\n        this.joinOperationsAsBgp(bgps),\n        originalLeftJoin.input[1],\n      );\n    } else if (nonBgps.length === operations.length) {\n      // Create nested joins\n      return this.joinOperationsAsNestedJoin(nonBgps);\n    } else {\n      // Join as much BGPs together as possible, and join with the other operations\n      return this.joinOperationsAsNestedJoin([\n        this.joinOperationsAsBgp(bgps),\n        this.joinOperationsAsNestedJoin(nonBgps),\n      ]);\n    }\n  }\n\n  public joinOperationsAsBgp(operations: Algebra.Operation[]): Algebra.Operation {\n    return this.operationFactory.createBgp((<Algebra.Pattern[]> []).concat.apply([], operations\n      .map((op) => (<Algebra.Bgp> op).patterns)));\n  }\n\n  public joinOperationsAsNestedJoin(operations: Algebra.Operation[]): Algebra.Operation {\n    return this.operationFactory.createJoin(operations);\n  }\n\n  /**\n   * Append a field's label to a path.\n   * @param {string[]} path A path.\n   * @param {string} fieldLabel A field label.\n   * @return {string[]} A new path array.\n   */\n  public appendFieldToPath(path: string[], fieldLabel: string): string[] {\n    return path.concat([fieldLabel]);\n  }\n\n  /**\n   * Get the label of a field by taking into account the alias.\n   * @param {FieldNode} field A field node.\n   * @return {string} The field name or alias.\n   */\n  public getFieldLabel(field: FieldNode): string {\n    return (field.alias ? field.alias : field.name).value;\n  }\n\n  /**\n   * Convert a field node to a variable built from the node name and the current path inside the context.\n   * @param {string} fieldLabel A field label.\n   * @param {IConvertContext} convertContext A convert context.\n   * @param {string} variableDelimiter A variable delimiter.\n   * @return {Variable} A variable.\n   */\n  public nameToVariable(fieldLabel: string, convertContext: IConvertContext): RDF.Variable {\n    return this.dataFactory.variable!((convertContext.path.length\n      ? convertContext.path.join(this.settings.variableDelimiter) + this.settings.variableDelimiter : '') + fieldLabel);\n  }\n\n  /**\n   * Convert a GraphQL term into a URI using the given context.\n   * @param {string} value A GraphQL term.\n   * @param {IContext} context A JSON-LD context.\n   * @return {NamedNode} A named node.\n   */\n  public valueToNamedNode(value: string, context: JsonLdContextNormalized): RDF.NamedNode {\n    const contextValue = context.expandTerm(value, true);\n    if (this.settings.requireContext && !contextValue) {\n      throw new Error('No context entry was found for ' + value);\n    }\n    return this.dataFactory.namedNode(contextValue || value);\n  }\n\n  /**\n   * Get an argument by name.\n   * This will return null if the argument could not be found.\n   * @param {ReadonlyArray<ArgumentNode>} args Arguments or null.\n   * @param {string} name The name of an argument.\n   * @return {ArgumentNode} The named argument.\n   */\n  public getArgument(args: ReadonlyArray<ArgumentNode> | undefined, name: string): ArgumentNode | undefined {\n    if (args) {\n      for (const argument of args) {\n        if (argument.name.value === name) {\n          return argument;\n        }\n      }\n    }\n  }\n\n  /**\n   * Create a pattern with an rdf:type predicate.\n   * @param {Term} subject The subject.\n   * @param {NamedTypeNode} typeCondition The object name.\n   * @param {IConvertContext} convertContext A convert context.\n   * @return {Pattern} A pattern.\n   */\n  public newTypePattern(subject: RDF.Term, typeCondition: NamedTypeNode, convertContext: IConvertContext) {\n    return this.operationFactory.createPattern(\n      subject,\n      this.dataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),\n      this.valueToNamedNode(typeCondition.name.value, convertContext.context),\n      convertContext.graph);\n  }\n\n  /**\n   * Create a quad pattern when the predicate is a name node that needs to be translated using the context.\n   * @param {Term} subject The subject.\n   * @param {NameNode} predicateName The name node for the predicate.\n   * @param {Term} object The object.\n   * @param {Term} graph The graph.\n   * @param {IContext} context A context.\n   * @return {Pattern} A quad pattern.\n   */\n  public createQuadPattern(subject: RDF.Term, predicateName: NameNode, object: RDF.Term, graph: RDF.Term,\n                           context: JsonLdContextNormalized): Algebra.Pattern {\n    const predicate: RDF.NamedNode = this.valueToNamedNode(predicateName.value, context);\n    if (context && context.getContextRaw()[predicateName.value]\n      && (<any> context.getContextRaw()[predicateName.value])['@reverse']) {\n      return this.operationFactory.createPattern(object, predicate, subject, graph);\n    }\n    return this.operationFactory.createPattern(subject, predicate, object, graph);\n  }\n\n  /**\n   * Create a quad path when the predicate is a list node with field alternatives\n   * that need to be translated using the context.\n   * @param {Term} subject The subject.\n   * @param {NameNode} predicateName The name node for the predicate.\n   * @param {Term} object The object.\n   * @param {Term} graph The graph.\n   * @param {IContext} context A context.\n   * @return {Path} A quad property path.\n   */\n  public createQuadPath(subject: RDF.Term, predicateName: NameNode, predicateAlternatives: ListValueNode,\n                        object: RDF.Term, graph: RDF.Term,\n                        context: JsonLdContextNormalized): Algebra.Path {\n    const predicateInitial: RDF.NamedNode = this.valueToNamedNode(predicateName.value, context);\n    let pathSymbol: Algebra.PropertyPathSymbol = this.operationFactory.createLink(predicateInitial);\n\n    // Add all fields in the list as predicate alternatives\n    for (const predicateAlternative of predicateAlternatives.values) {\n      if (predicateAlternative.kind !== 'EnumValue') {\n        throw new Error('Invalid value type for \\'alt\\' argument, must be EnumValue, but got '\n          + predicateAlternative.kind);\n      }\n      pathSymbol = this.operationFactory.createAlt([\n        pathSymbol,\n        this.operationFactory.createLink(this.valueToNamedNode(predicateAlternative.value, context)),\n      ]);\n    }\n\n    // Reverse the path based on the initial predicate\n    if (context && context.getContextRaw()[predicateName.value]\n      && (<any> context.getContextRaw()[predicateName.value])['@reverse']) {\n      return this.operationFactory.createPath(object, pathSymbol, subject, graph);\n    }\n    return this.operationFactory.createPath(subject, pathSymbol, object, graph);\n  }\n\n}\n"]}