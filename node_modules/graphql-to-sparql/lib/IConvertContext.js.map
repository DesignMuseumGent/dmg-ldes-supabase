{"version":3,"file":"IConvertContext.js","sourceRoot":"","sources":["IConvertContext.ts"],"names":[],"mappings":";;;AA8EA;;GAEG;AACH,IAAY,gBASX;AATD,WAAY,gBAAgB;IAC1B;;OAEG;IACH,2DAAM,CAAA;IACN;;OAEG;IACH,2DAAM,CAAA;AACR,CAAC,EATW,gBAAgB,GAAhB,wBAAgB,KAAhB,wBAAgB,QAS3B","sourcesContent":["import {FragmentDefinitionNode, ValueNode} from \"graphql/language\";\nimport {JsonLdContextNormalized} from \"jsonld-context-parser\";\nimport * as RDF from \"@rdfjs/types\";\n\n/**\n * A context object that is passed through conversion steps.\n *\n * This is defined for each query conversion within a converter instance.\n */\nexport interface IConvertContext {\n  /**\n   * A JSON-LD context.\n   */\n  context: JsonLdContextNormalized;\n  /**\n   * The current JSON path within the GraphQL query.\n   */\n  path: string[];\n  /**\n   * The subject term.\n   */\n  subject: RDF.Term;\n  /**\n   * The graph term.\n   */\n  graph: RDF.Term;\n  /**\n   * All variables that have no deeper child and should be selected withing the GraphQL query.\n   */\n  terminalVariables: RDF.Variable[];\n  /**\n   * All available fragment definitions.\n   */\n  fragmentDefinitions: {[name: string]: FragmentDefinitionNode};\n  /**\n   * A variable dictionary in case there are dynamic arguments in the query.\n   */\n  variablesDict: IVariablesDictionary;\n  /**\n   * A dictionary of variable metadata.\n   */\n  variablesMetaDict: IVariablesMetaDictionary;\n  /**\n   * The fields that are to be singularized.\n   */\n  singularizeVariables?: ISingularizeVariables;\n  /**\n   * The current singularization state.\n   */\n  singularizeState: SingularizeState;\n  /**\n   * If unknown variables that are being used should NOT throw an error.\n   */\n  ignoreUnknownVariables?: boolean;\n}\n\n/**\n * A variable dictionary in case there are dynamic arguments in the query.\n */\nexport interface IVariablesDictionary {\n  [id: string]: ValueNode;\n}\n\n/**\n * A dictionary of variable metadata.\n */\nexport interface IVariablesMetaDictionary {\n  [id: string]: { mandatory: boolean, list: boolean, type: string };\n}\n\n/**\n * A mapping from (nested) field names to a boolean indicating whether or not this field should be singularized.\n * If the field is not present, singularization for this field is false.\n */\nexport interface ISingularizeVariables {\n  [id: string]: boolean;\n}\n\n/**\n * A singularization state for variable values.\n */\nexport enum SingularizeState {\n  /**\n   * If only a first matching value should be picked.\n   */\n  SINGLE,\n  /**\n   * If all matching values should be picked.\n   */\n  PLURAL,\n}\n"]}