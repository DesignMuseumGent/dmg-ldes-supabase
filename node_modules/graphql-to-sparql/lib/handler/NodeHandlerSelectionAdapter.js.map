{"version":3,"file":"NodeHandlerSelectionAdapter.js","sourceRoot":"","sources":["NodeHandlerSelectionAdapter.ts"],"names":[],"mappings":"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","sourcesContent":["import {FieldNode, IntValueNode, SelectionNode} from \"graphql/language\";\nimport * as RDF from \"@rdfjs/types\";\nimport {Algebra, Util as AlgebraUtil} from \"sparqlalgebrajs\";\nimport {IConvertContext, SingularizeState} from \"../IConvertContext\";\nimport {IConvertSettings} from \"../IConvertSettings\";\nimport {Util} from \"../Util\";\nimport {INodeQuadContext, NodeHandlerAdapter} from \"./NodeHandlerAdapter\";\n\n/**\n * A handler for converting GraphQL selection nodes to operations.\n */\nexport abstract class NodeHandlerSelectionAdapter<T extends SelectionNode> extends NodeHandlerAdapter<T> {\n\n  constructor(targetKind: T['kind'], util: Util, settings: IConvertSettings) {\n    super(targetKind, util, settings);\n  }\n\n  /**\n   * Get the quad context of a field node that should be used for the whole definition node.\n   * @param {FieldNode} field A field node.\n   * @param {string} fieldLabel A field label.\n   * @param {IConvertContext} convertContext A convert context.\n   * @return {INodeQuadContext} The subject and optional auxiliary patterns.\n   */\n  public getNodeQuadContextFieldNode(field: FieldNode, fieldLabel: string, convertContext: IConvertContext)\n    : INodeQuadContext {\n    return this.getNodeQuadContextSelectionSet(field.selectionSet, fieldLabel, {\n      ...convertContext,\n      path: this.util.appendFieldToPath(convertContext.path, fieldLabel),\n    });\n  }\n\n  /**\n   * Convert a field node to an operation.\n   * @param {IConvertContext} convertContext A convert context.\n   * @param {FieldNode} fieldNode The field node to convert.\n   * @param {boolean} pushTerminalVariables If terminal variables should be created.\n   * @param {Pattern[]} auxiliaryPatterns Optional patterns that should be part of the BGP.\n   * @return {Operation} The reslting operation.\n   */\n  public fieldToOperation(convertContext: IConvertContext, fieldNode: FieldNode,\n                          pushTerminalVariables: boolean, auxiliaryPatterns?: Algebra.Pattern[]): Algebra.Operation {\n    // If a deeper node is being selected, and if the current object should become the next subject\n    const nesting = pushTerminalVariables;\n\n    // Offset and limit can be changed using the magic arguments 'first' and 'offset'.\n    let offset = 0;\n    let limit;\n\n    // Ignore 'id' and 'graph' fields, because we have processed them earlier in getNodeQuadContextSelectionSet.\n    if (fieldNode.name.value === 'id' || fieldNode.name.value === 'graph') {\n      pushTerminalVariables = false;\n\n      // Validate all _-arguments, because even though they were handled before,\n      // the validity of variables could not be checked,\n      // as variablesMetaDict wasn't populated at that time yet.\n      if (fieldNode.arguments) {\n        for (const argument of fieldNode.arguments) {\n          if (argument.name.value === '_') {\n            this.util.handleNodeValue(argument.value, fieldNode.name.value, convertContext);\n          }\n        }\n      }\n    }\n\n    // Determine the field label for variable naming, taking into account aliases\n    const fieldLabel: string = this.util.getFieldLabel(fieldNode);\n\n    // Handle the singular/plural scope\n    if (convertContext.singularizeState === SingularizeState.SINGLE) {\n      convertContext.singularizeVariables![this.util.nameToVariable(fieldLabel, convertContext).value] = true;\n    }\n\n    // Handle meta fields\n    if (pushTerminalVariables) {\n      const operationOverride = this.handleMetaField(convertContext, fieldLabel, auxiliaryPatterns);\n      if (operationOverride) {\n        return operationOverride;\n      }\n    }\n\n    const operations: Algebra.Operation[] = auxiliaryPatterns\n      ? [this.util.operationFactory.createBgp(auxiliaryPatterns)] : [];\n\n    // Define subject and object\n    const subjectOutput = this.getNodeQuadContextFieldNode(fieldNode, fieldLabel, convertContext);\n    let object: RDF.Term = subjectOutput.subject || this.util.nameToVariable(fieldLabel, convertContext);\n    let graph: RDF.Term = subjectOutput.graph || convertContext.graph;\n    if (subjectOutput.auxiliaryPatterns) {\n      operations.push(this.util.operationFactory.createBgp(subjectOutput.auxiliaryPatterns));\n    }\n\n    // Check if there is a '_' argument\n    // We do this before handling all other arguments so that the order of final triple patterns is sane.\n    let createQuadPattern: boolean = true;\n    let overrideObjectTerms: RDF.Term[] | null = null;\n    if (pushTerminalVariables && fieldNode.arguments && fieldNode.arguments.length) {\n      for (const argument of fieldNode.arguments) {\n        if (argument.name.value === '_') {\n          // '_'-arguments do not create an additional predicate link, but set the value directly.\n          const valueOutput = this.util.handleNodeValue(argument.value, fieldNode.name.value, convertContext);\n          overrideObjectTerms = valueOutput.terms;\n          operations.push(this.util.operationFactory.createBgp(\n            valueOutput.terms.map((term) => this.util.createQuadPattern(\n              convertContext.subject, fieldNode.name, term, convertContext.graph, convertContext.context)),\n          ));\n          if (valueOutput.auxiliaryPatterns) {\n            operations.push(this.util.operationFactory.createBgp(valueOutput.auxiliaryPatterns));\n          }\n          pushTerminalVariables = false;\n          break;\n        } else if (argument.name.value === 'graph') {\n          // 'graph'-arguments do not create an additional predicate link, but set the graph.\n          const valueOutput = this.util.handleNodeValue(argument.value, fieldNode.name.value, convertContext);\n          if (valueOutput.terms.length !== 1) {\n            throw new Error(`Only single values can be set as graph, but got ${valueOutput.terms\n              .length} at ${fieldNode.name.value}`);\n          }\n          graph = valueOutput.terms[0];\n          convertContext = { ...convertContext, graph };\n          if (valueOutput.auxiliaryPatterns) {\n            operations.push(this.util.operationFactory.createBgp(valueOutput.auxiliaryPatterns));\n          }\n          break;\n        } else if (argument.name.value === 'alt') {\n          // 'alt'-arguments do not create an additional predicate link, but create alt-property paths.\n\n          let pathValue = argument.value;\n          if (pathValue.kind !== 'ListValue') {\n            pathValue = { kind: 'ListValue', values: [ pathValue ] };\n          }\n\n          operations.push(this.util.createQuadPath(convertContext.subject, fieldNode.name, pathValue, object,\n            convertContext.graph, convertContext.context));\n          createQuadPattern = false;\n\n          break;\n        }\n      }\n    }\n\n    // Create at least a pattern for the parent node and the current path.\n    if (pushTerminalVariables && createQuadPattern) {\n      operations.push(this.util.operationFactory.createBgp([\n        this.util.createQuadPattern(convertContext.subject, fieldNode.name, object,\n          convertContext.graph, convertContext.context),\n      ]));\n    }\n\n    // Create patterns for the node's arguments\n    if (fieldNode.arguments && fieldNode.arguments.length) {\n      for (const argument of fieldNode.arguments) {\n        if (argument.name.value === '_' || argument.name.value === 'graph' || argument.name.value === 'alt') {\n          // no-op\n        } else if (argument.name.value === 'first') {\n          if (argument.value.kind !== 'IntValue') {\n            throw new Error('Invalid value type for \\'first\\' argument: ' + argument.value.kind);\n          }\n          limit = parseInt((<IntValueNode> argument.value).value, 10);\n        } else if (argument.name.value === 'offset') {\n          if (argument.value.kind !== 'IntValue') {\n            throw new Error('Invalid value type for \\'offset\\' argument: ' + argument.value.kind);\n          }\n          offset = parseInt((<IntValueNode> argument.value).value, 10);\n        } else {\n          const valueOutput = this.util.handleNodeValue(argument.value, argument.name.value, convertContext);\n          operations.push(this.util.operationFactory.createBgp(\n            valueOutput.terms.map((term) => this.util.createQuadPattern(\n              object, argument.name, term, convertContext.graph, convertContext.context)),\n          ));\n          if (valueOutput.auxiliaryPatterns) {\n            operations.push(this.util.operationFactory.createBgp(valueOutput.auxiliaryPatterns));\n          }\n        }\n      }\n    }\n\n    // Directives\n    const directiveOutputs = this.getDirectiveOutputs(fieldNode.directives, fieldLabel, convertContext);\n    if (!directiveOutputs) {\n      return this.util.operationFactory.createBgp([]);\n    }\n\n    // Recursive call for nested selection sets\n    let operation: Algebra.Operation = this.util.joinOperations(operations);\n    if (fieldNode.selectionSet && fieldNode.selectionSet.selections.length) {\n      // Override the object if needed\n      if (overrideObjectTerms) {\n        if (overrideObjectTerms.length !== 1) {\n          throw new Error(`Only single values can be set as id, but got ${overrideObjectTerms\n            .length} at ${fieldNode.name.value}`);\n        }\n        object = overrideObjectTerms[0];\n      }\n\n      // Change path value when there was an alias on this node.\n      const subConvertContext: IConvertContext = {\n        ...convertContext,\n        ...nesting ? { path: this.util.appendFieldToPath(convertContext.path, fieldLabel) } : {},\n        graph,\n        subject: nesting ? object : convertContext.subject,\n      };\n\n      // If the magic keyword 'totalCount' is present, include a count aggregator.\n      let totalCount: boolean = false;\n      const selections: ReadonlyArray<SelectionNode> = fieldNode.selectionSet.selections\n        .filter((selection) => {\n          if (selection.kind === 'Field' && selection.name.value === 'totalCount') {\n            totalCount = true;\n            return false;\n          }\n          return true;\n        });\n\n      let joinedOperation = this.util.joinOperations(operations\n        .concat(selections.map((selectionNode) => this.util.handleNode(selectionNode, subConvertContext))));\n\n      // Modify the operation if there was a count selection\n      if (totalCount) {\n        // Create to a count aggregation\n        const expressionVariable = this.util.dataFactory.variable!('var' + this.settings.expressionVariableCounter!++);\n        const countOverVariable: RDF.Variable = this.util.dataFactory\n          .variable!(object.value + this.settings.variableDelimiter + 'totalCount');\n        const aggregator: Algebra.BoundAggregate = this.util.operationFactory.createBoundAggregate(expressionVariable,\n          'count', this.util.operationFactory.createTermExpression(object), false);\n\n        const countProject = this.util.operationFactory.createProject(\n          this.util.operationFactory.createExtend(\n            this.util.operationFactory.createGroup(operation, [], [aggregator]), countOverVariable,\n            this.util.operationFactory.createTermExpression(expressionVariable),\n          ),\n          [countOverVariable],\n        );\n        convertContext.terminalVariables.push(countOverVariable);\n\n        // If no other selections exist (next to totalCount),\n        // then we just return the count operations as-is,\n        // otherwise, we join the count operation with all other selections\n        if (!selections.length) {\n          joinedOperation = countProject;\n        } else {\n          joinedOperation = this.util.operationFactory.createJoin([\n            this.util.operationFactory.createProject(joinedOperation, []),\n            countProject,\n          ]);\n        }\n      }\n\n      operation = joinedOperation;\n    } else if (pushTerminalVariables && object.termType === 'Variable') {\n      // If no nested selection sets exist,\n      // consider the object variable as a terminal variable that should be selected.\n      convertContext.terminalVariables.push(object);\n    }\n\n    // Wrap the operation in a slice if a 'first' or 'offset' argument was provided.\n    if (offset || limit) {\n      operation = this.util.operationFactory.createSlice(this.util.operationFactory.createProject(\n        operation, AlgebraUtil.inScopeVariables(operation)), offset, limit);\n    }\n\n    // Override operation if needed\n    return this.handleDirectiveOutputs(directiveOutputs, operation);\n  }\n\n  /**\n   * Check if the given node is a meta field, for things like introspection.\n   * If so, return a new operation for this, otherwise, null is returned.\n   * @param {IConvertContext} convertContext A convert context.\n   * @param {Term} subject The subject.\n   * @param {string} fieldLabel The field label to convert.\n   * @param {Pattern[]} auxiliaryPatterns Optional patterns that should be part of the BGP.\n   * @return {Operation} An operation or undefined.\n   */\n  public handleMetaField(convertContext: IConvertContext, fieldLabel: string,\n                         auxiliaryPatterns?: Algebra.Pattern[]): Algebra.Operation | undefined {\n    // TODO: in the future, we should add support for GraphQL wide range of introspection features:\n    // http://graphql.org/learn/introspection/\n    if (fieldLabel === '__typename') {\n      const object: RDF.Variable = this.util.nameToVariable(fieldLabel, convertContext);\n      convertContext.terminalVariables.push(object);\n      return this.util.operationFactory.createBgp([\n        this.util.operationFactory.createPattern(\n          convertContext.subject,\n          this.util.dataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),\n          this.util.nameToVariable(fieldLabel, convertContext),\n          convertContext.graph,\n        ),\n      ].concat(auxiliaryPatterns || []));\n    }\n  }\n\n}\n"]}