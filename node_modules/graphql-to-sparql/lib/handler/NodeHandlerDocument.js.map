{"version":3,"file":"NodeHandlerDocument.js","sourceRoot":"","sources":["NodeHandlerDocument.ts"],"names":[],"mappings":"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","sourcesContent":["import {DocumentNode} from \"graphql\";\nimport {DefinitionNode} from \"graphql/language\";\nimport * as RDF from \"@rdfjs/types\";\nimport {Algebra, Factory, Util as AlgebraUtil} from \"sparqlalgebrajs\";\nimport {IConvertContext} from \"../IConvertContext\";\nimport {IConvertSettings} from \"../IConvertSettings\";\nimport {Util} from \"../Util\";\nimport {INodeQuadContext, NodeHandlerAdapter} from \"./NodeHandlerAdapter\";\n\n/**\n * Converts GraphQL documents to joined operations for all its definitions.\n */\nexport class NodeHandlerDocument extends NodeHandlerAdapter<DocumentNode> {\n\n  constructor(util: Util, settings: IConvertSettings) {\n    super('Document', util, settings);\n  }\n\n  public handle(document: DocumentNode, convertContext: IConvertContext): Algebra.Operation {\n    const definitionOperations = document.definitions\n      .map((definition) => {\n        const subjectOutput = this.getNodeQuadContextDefinitionNode(definition,\n          {...convertContext, ignoreUnknownVariables: true});\n        const queryParseContext: IConvertContext = {\n          ...convertContext,\n          graph: subjectOutput.graph || convertContext.graph,\n          subject: subjectOutput.subject || this.util.dataFactory.blankNode(),\n        };\n        let definitionOperation = this.util.handleNode(definition, queryParseContext);\n        if (subjectOutput && subjectOutput.auxiliaryPatterns) {\n          definitionOperation = this.util.joinOperations([\n            definitionOperation,\n            this.util.operationFactory.createBgp(subjectOutput.auxiliaryPatterns),\n          ]);\n        }\n        return definitionOperation;\n      });\n    const operation = this.util.operationFactory.createProject(\n      definitionOperations.length === 1 ? definitionOperations[0] : this.util.operationFactory.createUnion(definitionOperations),\n      convertContext.terminalVariables);\n\n    // Convert blank nodes to variables\n    return this.translateBlankNodesToVariables(operation);\n  }\n\n  /**\n   * Get the quad context of a definition node that should be used for the whole definition node.\n   * @param {DefinitionNode} definition A definition node.\n   * @param {IConvertContext} convertContext A convert context.\n   * @return {INodeQuadContext} The subject and optional auxiliary patterns.\n   */\n  public getNodeQuadContextDefinitionNode(definition: DefinitionNode, convertContext: IConvertContext)\n    : INodeQuadContext {\n    if (definition.kind === 'OperationDefinition') {\n      return this.getNodeQuadContextSelectionSet(definition.selectionSet,\n        definition.name ? definition.name.value : '', convertContext);\n    }\n    throw new Error(`Unsupported definition: ${definition.kind}`);\n  }\n\n  /**\n   * Translates blank nodes inside the query to variables.\n   * @param {Project} operation The operation to translate.\n   * @return {Operation} The transformed operation.\n   */\n  public translateBlankNodesToVariables(operation: Algebra.Project): Algebra.Operation {\n    const self = this;\n    const blankToVariableMapping: {[bLabel: string]: RDF.Variable} = {};\n    const variablesRaw: {[vLabel: string]: boolean} = Array.from(operation.variables)\n      .reduce((acc: {[vLabel: string]: boolean}, variable: RDF.Variable) => {\n        acc[variable.value] = true;\n        return acc;\n      }, {});\n    return AlgebraUtil.mapOperation(operation, {\n      path: (op: Algebra.Path, factory: Factory) => {\n        return {\n          recurse: false,\n          result: factory.createPath(\n            blankToVariable(op.subject),\n            op.predicate,\n            blankToVariable(op.object),\n            blankToVariable(op.graph),\n          ),\n        };\n      },\n      pattern: (op: Algebra.Pattern, factory: Factory) => {\n        return {\n          recurse: false,\n          result: factory.createPattern(\n            blankToVariable(op.subject),\n            blankToVariable(op.predicate),\n            blankToVariable(op.object),\n            blankToVariable(op.graph),\n          ),\n        };\n      },\n    });\n\n    function blankToVariable(term: RDF.Term): RDF.Term {\n      if (term.termType === 'BlankNode') {\n        let variable = blankToVariableMapping[term.value];\n        if (!variable) {\n          variable = AlgebraUtil.createUniqueVariable(term.value, variablesRaw, self.util.dataFactory);\n          variablesRaw[variable.value] = true;\n          blankToVariableMapping[term.value] = variable;\n        }\n        return variable;\n      }\n      return term;\n    }\n  }\n\n}\n"]}