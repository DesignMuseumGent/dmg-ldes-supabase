{"version":3,"file":"NodeHandlerAdapter.js","sourceRoot":"","sources":["NodeHandlerAdapter.ts"],"names":[],"mappings":"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","sourcesContent":["import {DirectiveNode, FieldNode, SelectionSetNode} from \"graphql/language\";\nimport * as RDF from \"@rdfjs/types\";\nimport {Algebra} from \"sparqlalgebrajs\";\nimport {IConvertContext} from \"../IConvertContext\";\nimport {IConvertSettings} from \"../IConvertSettings\";\nimport {Util} from \"../Util\";\nimport {IDirectiveNodeHandlerOutput} from \"./directivenode/DirectiveNodeHandlerAdapter\";\n\n/**\n * A handler for converting GraphQL nodes to operations.\n */\nexport abstract class NodeHandlerAdapter<T extends { kind: string }> {\n\n  public readonly targetKind: string;\n  protected readonly util: Util;\n  protected readonly settings: IConvertSettings;\n\n  constructor(targetKind: T['kind'], util: Util, settings: IConvertSettings) {\n    this.targetKind = targetKind;\n    this.util = util;\n    this.settings = settings;\n  }\n\n  /**\n   * Get the operation for the given GraphQL node.\n   * @param {T} node A GraphQL node.\n   * @param {IConvertContext} convertContext A conversion context.\n   * @return {Operation} A SPARQL algebra operation.\n   */\n  public abstract handle(node: T, convertContext: IConvertContext): Algebra.Operation;\n\n  /* ----- Node quad context ----- */\n\n  /**\n   * Get the quad context of a selection set node that should be used for the whole definition node.\n   *\n   * This is a pre-processing step of selection sets.\n   * Its only purpose is to determine the subject within a selection set,\n   * because this subject is needed to link with its parent.\n   * In a later phase, the selection set will be processed using the discovered subject,\n   * and the field identifying the subject will be ignored.\n   *\n   * @param {SelectionSetNode} selectionSet A selection set node.\n   * @param {string} fieldLabel A field label.\n   * @param {IConvertContext} convertContext A convert context.\n   * @return {INodeQuadContext} The subject, graph and auxiliary patterns.\n   */\n  public getNodeQuadContextSelectionSet(selectionSet: SelectionSetNode | undefined, fieldLabel: string,\n                                        convertContext: IConvertContext)\n    : INodeQuadContext {\n    const nodeQuadContext: INodeQuadContext = {};\n    if (selectionSet) {\n      for (const selectionNode of selectionSet.selections) {\n        if (selectionNode.kind === 'Field') {\n          const fieldNode = selectionNode;\n          this.handleNodeQuadContextField(fieldNode, convertContext, nodeQuadContext, 'id', 'subject');\n          this.handleNodeQuadContextField(fieldNode, convertContext, nodeQuadContext, 'graph', 'graph');\n        }\n      }\n    }\n    return nodeQuadContext;\n  }\n\n  /**\n   * Handles a single field for determining the node quad context.\n   * @param {FieldNode} fieldNode A field node.\n   * @param {IConvertContext} convertContext A convert context.\n   * @param {INodeQuadContext} nodeQuadContext The node quad context to populate.\n   * @param {string} fieldName The field name to check for.\n   * @param {'subject' | 'graph'} nodeQuadContextKey The key to fill into the node quad context.\n   */\n  public handleNodeQuadContextField(fieldNode: FieldNode, convertContext: IConvertContext,\n                                    nodeQuadContext: INodeQuadContext, fieldName: string,\n                                    nodeQuadContextKey: 'subject' | 'graph') {\n    if (!nodeQuadContext[nodeQuadContextKey] && fieldNode.name.value === fieldName) {\n      // Get (or set) the nodeQuadContextKey for fieldName fields\n      if (!nodeQuadContext[nodeQuadContextKey]) {\n        const argument = this.util.getArgument(fieldNode.arguments, '_');\n        if (argument) {\n          const valueOutput = this.util.handleNodeValue(argument.value, fieldNode.name.value, convertContext);\n          if (valueOutput.terms.length !== 1) {\n            throw new Error(`Only single values can be set as ${fieldName}, but got ${valueOutput.terms\n              .length} at ${fieldNode.name.value}`);\n          }\n          nodeQuadContext[nodeQuadContextKey] = valueOutput.terms[0];\n          if (valueOutput.auxiliaryPatterns) {\n            if (!nodeQuadContext.auxiliaryPatterns) {\n              nodeQuadContext.auxiliaryPatterns = [];\n            }\n            nodeQuadContext.auxiliaryPatterns.concat(valueOutput.auxiliaryPatterns);\n          }\n        }\n      }\n      if (!nodeQuadContext[nodeQuadContextKey]) {\n        const term = this.util.nameToVariable(this.util.getFieldLabel(fieldNode), convertContext);\n        convertContext.terminalVariables.push(term);\n        nodeQuadContext[nodeQuadContextKey] = term;\n      }\n    }\n  }\n\n  /* ----- Directives ----- */\n\n  /**\n   * Get an operation override defined by one of the directives.\n   *\n   * This should be called before a sub-operation is handled.\n   *\n   * @param {ReadonlyArray<DirectiveNode>} directives An option directives array.\n   * @param {string} fieldLabel The current field label.\n   * @param {IConvertContext} convertContext A convert context.\n   * @return {IDirectiveNodeHandlerOutput[]} The directive node handler outputs, or null if it should be ignored.\n   */\n  public getDirectiveOutputs(\n    directives: ReadonlyArray<DirectiveNode> | undefined,\n    fieldLabel: string,\n    convertContext: IConvertContext,\n  ): IDirectiveNodeHandlerOutput[] | null {\n    const outputs: IDirectiveNodeHandlerOutput[] = [];\n    if (directives) {\n      for (const directive of directives) {\n        const output = this.util.handleDirectiveNode({ directive, fieldLabel }, convertContext);\n        if (output) {\n          if (output.ignore) {\n            return null;\n          }\n          outputs.push(output);\n        }\n      }\n    }\n    return outputs;\n  }\n\n  /**\n   * Handle the directive outputs with respect to an operation.\n   *\n   * This should be called after a sub-operation was handled.\n   *\n   * @param {IDirectiveNodeHandlerOutput[]} directiveOutputs\n   * @param {Operation} operation\n   * @return {Operation}\n   */\n  public handleDirectiveOutputs(directiveOutputs: IDirectiveNodeHandlerOutput[],\n                                operation: Algebra.Operation): Algebra.Operation {\n    for (const directiveOutput of directiveOutputs) {\n      if (directiveOutput.ignore) {\n        return this.util.operationFactory.createBgp([]);\n      }\n      if (directiveOutput.operationOverrider) {\n        operation = directiveOutput.operationOverrider(operation);\n      }\n    }\n    return operation;\n  }\n\n}\n\n/**\n * The output of getting a node's quad context.\n */\nexport interface INodeQuadContext {\n  subject?: RDF.Term;\n  graph?: RDF.Term;\n  auxiliaryPatterns?: Algebra.Pattern[];\n}\n"]}