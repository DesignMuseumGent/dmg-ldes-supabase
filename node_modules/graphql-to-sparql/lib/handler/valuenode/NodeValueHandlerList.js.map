{"version":3,"file":"NodeValueHandlerList.js","sourceRoot":"","sources":["NodeValueHandlerList.ts"],"names":[],"mappings":";;;AAMA,uEAA2F;AAE3F;;GAEG;AACH,MAAa,oBAAqB,SAAQ,iDAAsC;IAM9E,YAAY,IAAU,EAAE,QAA0B;QAChD,KAAK,CAAC,WAAW,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;QACnC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,kDAAkD,CAAC,CAAC;QACrG,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,iDAAiD,CAAC,CAAC;QACnG,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,gDAAgD,CAAC,CAAC;IACnG,CAAC;IAEM,MAAM,CAAC,SAAwB,EAAE,SAAiB,EAC3C,cAA+B;QAC3C,MAAM,SAAS,GAAe,EAAE,CAAC;QACjC,IAAI,iBAAiB,GAAsB,EAAE,CAAC;QAC9C,+BAA+B;QAC/B,KAAK,MAAM,CAAC,IAAI,SAAS,CAAC,MAAM,EAAE;YAChC,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC;YACzE,KAAK,MAAM,IAAI,IAAI,QAAQ,CAAC,KAAK,EAAE;gBACjC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACtB;YACD,IAAI,QAAQ,CAAC,iBAAiB,EAAE;gBAC9B,iBAAiB,GAAG,iBAAiB,CAAC,MAAM,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;aAC1E;SACF;QAED,IAAI,IAAI,CAAC,QAAQ,CAAC,gBAAgB,EAAE;YAClC,4BAA4B;YAE5B,gCAAgC;YAChC,MAAM,aAAa,GAAa,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,CAAC;YAClE,IAAI,QAAQ,GAAa,aAAa,CAAC;YACvC,IAAI,SAAS,GAAW,SAAS,CAAC,MAAM,CAAC;YACzC,KAAK,MAAM,IAAI,IAAI,SAAS,EAAE;gBAC5B,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAC7D,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE,IAAI,EAAE,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC;gBACzD,MAAM,YAAY,GAAa,EAAE,SAAS,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,CAAC;gBACpG,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,aAAa,CAC7D,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,YAAY,EAAE,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC;gBAChE,QAAQ,GAAG,YAAY,CAAC;aACzB;YACD,OAAO,EAAE,KAAK,EAAE,CAAE,aAAa,CAAE,EAAE,iBAAiB,EAAE,CAAC;SACxD;aAAM;YACL,8EAA8E;YAC9E,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,iBAAiB,EAAE,CAAC;SAChD;IACH,CAAC;CAEF;AAlDD,oDAkDC","sourcesContent":["import {ListValueNode} from \"graphql/language\";\nimport * as RDF from \"@rdfjs/types\";\nimport {Algebra} from \"sparqlalgebrajs\";\nimport {IConvertContext} from \"../../IConvertContext\";\nimport {IConvertSettings} from \"../../IConvertSettings\";\nimport {Util} from \"../../Util\";\nimport {IValueNodeHandlerOutput, NodeValueHandlerAdapter} from \"./NodeValueHandlerAdapter\";\n\n/**\n * Converts GraphQL lists to RDF lists if settings.arraysToRdfLists is true, otherwise it converts to multiple values.\n */\nexport class NodeValueHandlerList extends NodeValueHandlerAdapter<ListValueNode> {\n\n  protected readonly nodeFirst: RDF.NamedNode;\n  protected readonly nodeRest: RDF.NamedNode;\n  protected readonly nodeNil: RDF.NamedNode;\n\n  constructor(util: Util, settings: IConvertSettings) {\n    super('ListValue', util, settings);\n    this.nodeFirst = this.util.dataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#first');\n    this.nodeRest = this.util.dataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#rest');\n    this.nodeNil = this.util.dataFactory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#nil');\n  }\n\n  public handle(valueNode: ListValueNode, fieldName: string,\n                convertContext: IConvertContext): IValueNodeHandlerOutput {\n    const listTerms: RDF.Term[] = [];\n    let auxiliaryPatterns: Algebra.Pattern[] = [];\n    // Create terms for list values\n    for (const v of valueNode.values) {\n      const subValue = this.util.handleNodeValue(v, fieldName, convertContext);\n      for (const term of subValue.terms) {\n        listTerms.push(term);\n      }\n      if (subValue.auxiliaryPatterns) {\n        auxiliaryPatterns = auxiliaryPatterns.concat(subValue.auxiliaryPatterns);\n      }\n    }\n\n    if (this.settings.arraysToRdfLists) {\n      // Convert array to RDF list\n\n      // Create chained list structure\n      const firstListNode: RDF.Term = this.util.dataFactory.blankNode();\n      let listNode: RDF.Term = firstListNode;\n      let remaining: number = listTerms.length;\n      for (const term of listTerms) {\n        auxiliaryPatterns.push(this.util.operationFactory.createPattern(\n          listNode, this.nodeFirst, term, convertContext.graph));\n        const nextListNode: RDF.Term = --remaining === 0 ? this.nodeNil : this.util.dataFactory.blankNode();\n        auxiliaryPatterns.push(this.util.operationFactory.createPattern(\n          listNode, this.nodeRest, nextListNode, convertContext.graph));\n        listNode = nextListNode;\n      }\n      return { terms: [ firstListNode ], auxiliaryPatterns };\n    } else {\n      // Convert array to multiple terms that will be linked via the same predicate.\n      return { terms: listTerms, auxiliaryPatterns };\n    }\n  }\n\n}\n"]}