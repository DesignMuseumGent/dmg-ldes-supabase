{"version":3,"file":"NodeHandlerSelectionFragmentSpread.js","sourceRoot":"","sources":["NodeHandlerSelectionFragmentSpread.ts"],"names":[],"mappings":";;;AAKA,+EAA0E;AAE1E;;GAEG;AACH,MAAa,kCAAmC,SAAQ,yDAA+C;IAErG,YAAY,IAAU,EAAE,QAA0B;QAChD,KAAK,CAAC,gBAAgB,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;IAC1C,CAAC;IAEM,MAAM,CAAC,kBAAsC,EAAE,cAA+B;QACnF,MAAM,sBAAsB,GAA2B,cAAc;aAClE,mBAAmB,CAAC,kBAAkB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACtD,IAAI,CAAC,sBAAsB,EAAE;YAC3B,MAAM,IAAI,KAAK,CAAC,iCAAiC,GAAG,kBAAkB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACpF;QAED,6EAA6E;QAC7E,MAAM,SAAS,GAAc;YAC3B,KAAK,EAAE,SAAS;YAChB,SAAS,EAAE,SAAS;YACpB,UAAU,EAAE,sBAAsB,CAAC,UAAU;YAC7C,IAAI,EAAE,OAAO;YACb,IAAI,EAAE,kBAAkB,CAAC,IAAI;YAC7B,YAAY,EAAE,sBAAsB,CAAC,YAAY;SAClD,CAAC;QACF,MAAM,iBAAiB,GAAG;YACxB,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,OAAO,EAAE,sBAAsB,CAAC,aAAa,EAAE,cAAc,CAAC;SACvG,CAAC;QACF,OAAO,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,cAAc,CAC9C,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,EAAE,CAAC,EACxC,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,SAAS,EAAE,KAAK,EAAE,iBAAiB,CAAC,CAC3E,CAAC;IACJ,CAAC;CAEF;AA/BD,gFA+BC","sourcesContent":["import {FieldNode, FragmentDefinitionNode, FragmentSpreadNode} from \"graphql/language\";\nimport {Algebra} from \"sparqlalgebrajs\";\nimport {IConvertContext} from \"../IConvertContext\";\nimport {IConvertSettings} from \"../IConvertSettings\";\nimport {Util} from \"../Util\";\nimport {NodeHandlerSelectionAdapter} from \"./NodeHandlerSelectionAdapter\";\n\n/**\n * Converts GraphQL fragment spread to one or more quad patterns with a given type within an optional.\n */\nexport class NodeHandlerSelectionFragmentSpread extends NodeHandlerSelectionAdapter<FragmentSpreadNode> {\n\n  constructor(util: Util, settings: IConvertSettings) {\n    super('FragmentSpread', util, settings);\n  }\n\n  public handle(fragmentSpreadNode: FragmentSpreadNode, convertContext: IConvertContext): Algebra.Operation {\n    const fragmentDefinitionNode: FragmentDefinitionNode = convertContext\n      .fragmentDefinitions[fragmentSpreadNode.name.value];\n    if (!fragmentDefinitionNode) {\n      throw new Error('Undefined fragment definition: ' + fragmentSpreadNode.name.value);\n    }\n\n    // Wrap in an OPTIONAL, as this pattern should only apply if the type applies\n    const fieldNode: FieldNode = {\n      alias: undefined,\n      arguments: undefined,\n      directives: fragmentDefinitionNode.directives,\n      kind: 'Field',\n      name: fragmentSpreadNode.name,\n      selectionSet: fragmentDefinitionNode.selectionSet,\n    };\n    const auxiliaryPatterns = [\n      this.util.newTypePattern(convertContext.subject, fragmentDefinitionNode.typeCondition, convertContext),\n    ];\n    return this.util.operationFactory.createLeftJoin(\n      this.util.operationFactory.createBgp([]),\n      this.fieldToOperation(convertContext, fieldNode, false, auxiliaryPatterns),\n    );\n  }\n\n}\n"]}