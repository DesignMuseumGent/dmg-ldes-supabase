{"version":3,"file":"DirectiveNodeHandlerAdapter.js","sourceRoot":"","sources":["DirectiveNodeHandlerAdapter.ts"],"names":[],"mappings":";;;AAQA;;GAEG;AACH,MAAsB,2BAA2B;IAO/C,YAAY,UAAkB,EAAE,IAAU,EAAE,QAA0B;QACpE,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC3B,CAAC;IAWD;;;;;OAKG;IACI,4BAA4B,CAAC,SAAwB,EAAE,cAA+B;QAC3F,MAAM,GAAG,GAA6B,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;QACvF,IAAI,CAAC,GAAG,EAAE;YACR,MAAM,IAAI,KAAK,CAAC,iBAAiB,SAAS,CAAC,IAAI,CAAC,KAAK,6BAA6B,CAAC,CAAC;SACrF;QACD,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,KAAK,EAAE,GAAG,CAAC,IAAI,CAAC,KAAK,EAAE,cAAc,CAAC,CAAC;QACtF,IAAI,QAAQ,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,+BAA+B,SAAS,CAAC,IAAI,CAAC,KAAK,eAAe,CAAC,CAAC;SACrF;QACD,OAAO,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC3B,CAAC;IAED;;;;OAIG;IACI,mBAAmB,CAAC,SAAwB;QACjD,MAAM,QAAQ,GAA6B,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QAC/F,OAAO,QAAQ,IAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,KAAK,WAAW,IAAI,QAAQ,CAAC,KAAK,CAAC,KAAK,KAAK,KAAK,CAAC;IAC3F,CAAC;CACF;AAjDD,kEAiDC","sourcesContent":["import {DirectiveNode} from \"graphql\";\nimport * as RDF from \"@rdfjs/types\";\nimport {Algebra} from \"sparqlalgebrajs\";\nimport {IConvertContext} from \"../../IConvertContext\";\nimport {IConvertSettings} from \"../../IConvertSettings\";\nimport {Util} from \"../../Util\";\nimport {ArgumentNode} from \"graphql/language\";\n\n/**\n * An abstract handler for GraphQL directives.\n */\nexport abstract class DirectiveNodeHandlerAdapter {\n\n  public readonly targetKind: string;\n\n  protected readonly util: Util;\n  protected readonly settings: IConvertSettings;\n\n  constructor(targetKind: string, util: Util, settings: IConvertSettings) {\n    this.targetKind = targetKind;\n    this.util = util;\n    this.settings = settings;\n  }\n\n  /**\n   * Get the handler output for the given directive.\n   * @param {IDirectiveContext} directiveContext The current directive context.\n   * @param {IConvertContext} convertContext A conversion context.\n   * @return {IValueNodeHandlerOutput} The RDF terms and patterns.\n   */\n  public abstract handle(directiveContext: IDirectiveContext, convertContext: IConvertContext)\n    : IDirectiveNodeHandlerOutput;\n\n  /**\n   * Get the value of the 'if' argument in a directive.\n   * @param {DirectiveNode} directive A directive.\n   * @param {IConvertContext} convertContext A convert context.\n   * @return {Term} The term.\n   */\n  public getDirectiveConditionalValue(directive: DirectiveNode, convertContext: IConvertContext): RDF.Term {\n    const arg: ArgumentNode | undefined = this.util.getArgument(directive.arguments, 'if');\n    if (!arg) {\n      throw new Error(`The directive ${directive.name.value} is missing an if-argument.`);\n    }\n    const subValue = this.util.handleNodeValue(arg.value, arg.name.value, convertContext);\n    if (subValue.terms.length !== 1) {\n      throw new Error(`Can not apply the directive ${directive.name.value} with a list.`);\n    }\n    return subValue.terms[0];\n  }\n\n  /**\n   * If a `scope: all` directive param is present.\n   * @param {DirectiveNode} directive A directive.\n   * @return {boolean} If `scope: all` is present.\n   */\n  public isDirectiveScopeAll(directive: DirectiveNode) {\n    const scopeArg: ArgumentNode | undefined = this.util.getArgument(directive.arguments, 'scope');\n    return scopeArg && scopeArg.value.kind === 'EnumValue' && scopeArg.value.value === 'all';\n  }\n}\n\n/**\n * The output of converting a directive node to an operation.\n */\nexport interface IDirectiveNodeHandlerOutput {\n  /**\n   * If the field should be ignored.\n   */\n  ignore?: boolean;\n  /**\n   * The optional operation overrider.\n   */\n  operationOverrider?: (operation: Algebra.Operation) => Algebra.Operation;\n}\n\nexport interface IDirectiveContext {\n  /**\n   * The current directive.\n   */\n  directive: DirectiveNode;\n  /**\n   * The current field label.\n   */\n  fieldLabel: string;\n}\n"]}